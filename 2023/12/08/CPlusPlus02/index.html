<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++基础入门第二章 | kyl的博客</title><meta name="author" content="kyl"><meta name="copyright" content="kyl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++变量和基本类型">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础入门第二章">
<meta property="og:url" content="https://alsl521.github.io/2023/12/08/CPlusPlus02/index.html">
<meta property="og:site_name" content="kyl的博客">
<meta property="og:description" content="C++变量和基本类型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4">
<meta property="article:published_time" content="2023-12-08T10:51:00.000Z">
<meta property="article:modified_time" content="2025-04-08T07:46:27.793Z">
<meta property="article:author" content="kyl">
<meta property="article:tag" content="C++基础入门">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++基础入门第二章",
  "url": "https://alsl521.github.io/2023/12/08/CPlusPlus02/",
  "image": "https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4",
  "datePublished": "2023-12-08T10:51:00.000Z",
  "dateModified": "2025-04-08T07:46:27.793Z",
  "author": [
    {
      "@type": "Person",
      "name": "kyl",
      "url": "https://alsl521.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://alsl521.github.io/2023/12/08/CPlusPlus02/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++基础入门第二章',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">kyl的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++基础入门第二章</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++基础入门第二章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-08T10:51:00.000Z" title="发表于 2023-12-08 18:51:00">2023-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-08T07:46:27.793Z" title="更新于 2025-04-08 15:46:27">2025-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><h3 id="2-1基本内置类型"><a href="#2-1基本内置类型" class="headerlink" title="2.1基本内置类型"></a>2.1基本内置类型</h3><p>​		C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p>
<h4 id="2-1-1算数类型"><a href="#2-1-1算数类型" class="headerlink" title="2.1.1算数类型"></a>2.1.1算数类型</h4><p>​		算数类型分为两类：整型(integral type，包括字符和布尔类型在内)和浮点型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr>
<td><code>char</code></td>
<td>字符</td>
<td>8bits</td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>宽字符</td>
<td>16bits</td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>Unicode字符</td>
<td>16bits</td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>Unicode字符</td>
<td>32bits</td>
</tr>
<tr>
<td><code>short</code></td>
<td>短整型</td>
<td>16bits</td>
</tr>
<tr>
<td><code>int</code></td>
<td>整型</td>
<td>16bits (在32位机器中是32bits)</td>
</tr>
<tr>
<td><code>long</code></td>
<td>长整型</td>
<td>32bits</td>
</tr>
<tr>
<td><code>long long</code></td>
<td>长整型</td>
<td>64bits （是在C++11中新定义的）</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td><code>long double</code></td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody></table>
<p>​		布尔类型(bool)：取值是真(true)或者假(false)。</p>
<p>​		整型（integral type）：除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。在整型类型大小方面，C++规定<code>short</code> ≤ <code>int</code> ≤ <code>long</code> ≤ <code>long long</code>（<code>long long</code>是C++11定义的类型）。</p>
<p>​		浮点型（floating-point type）：浮点型可表示单精度、双精度和扩展精度值。浮点型可表示单精度（single-precision）、双精度（double-precision）和扩展精度（extended-precision）值，分别对应<code>float</code>、<code>double</code>和<code>long double</code>类型。</p>
<p>​		字符型（Character type）：</p>
<p>​		**作用：**字符型变量用于显示单个字符</p>
<p>​		<strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用&#x3D;&#x3D;1个字节&#x3D;&#x3D;。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>，</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>，</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>&#x2F;</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>&#x2F;</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>&#x3D;</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>&#96;</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<p>​		其他字符类型用于扩展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型char16_t和char32_t则为Unicode字符集服务(Unicode是用于表示所有自然语言中字符的标准).</p>
<h5 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a><strong>带符号类型和无符号类型</strong></h5><p>​		除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的(signed)和无符号的(unsigned)两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。</p>
<p>​		除去布尔型和扩展字符型，其他整型可以分为带符号（signed）和无符号（unsigned）两种。带符号类型可以表示正数、负数和0，无符号类型只能表示大于等于0的数值。类型<code>int</code>、<code>short</code>、<code>long</code>和<code>long long</code>都是带符号的，在类型名前面添加<code>unsigned</code>可以得到对应的无符号类型，如<code>unsigned int</code>。</p>
<p>​		字符型分为<code>char</code>、<code>signed char</code>和<code>unsigned char</code>三种，但是表现形式只有带符号和无符号两种。类型<code>char</code>和<code>signed char</code>并不一样， <code>char</code>的具体形式由编译器（compiler）决定。</p>
<p>如何选择算数类型：</p>
<ul>
<li>当明确知晓数值不可能为负时，应该使用无符号类型。</li>
<li>使用<code>int</code>执行整数运算，如果数值超过了<code>int</code>的表示范围，应该使用<code>long long</code>类型。</li>
<li>在算数表达式中不要使用<code>char</code>和<code>bool</code>类型。如果需要使用一个不大的整数，应该明确指定它的类型是<code>signed char</code>还是<code>unsigned char</code>。</li>
<li>执行浮点数运算时建议使用<code>double</code>类型。</li>
</ul>
<h4 id="2-1-2类型转换"><a href="#2-1-2类型转换" class="headerlink" title="2.1.2类型转换"></a>2.1.2类型转换</h4><p>对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换(convert)为另一种相关类型。</p>
<p>进行类型转换时，类型所能表示的值的范围决定了转换的过程。</p>
<ul>
<li><p>把非布尔类型的算术值赋给布尔类型时，初始值为0则结果为<code>false</code>，否则结果为<code>true</code>。</p>
</li>
<li><p>把布尔值赋给非布尔类型时，初始值为<code>false</code>则结果为0，初始值为<code>true</code>则结果为1。</p>
</li>
<li><p>把浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中的整数部分。</p>
</li>
<li><p>把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p>
</li>
<li><p>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数（8比特大小的<code>unsigned char</code>能表示的数值总数是256）取模后的余数。</p>
</li>
<li><p>赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。</p>
</li>
</ul>
<h5 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a><strong>含有无符号类型的表达式</strong></h5><ul>
<li>int、无符号变量</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331151059664.png" alt="image-20230331151059664"></p>
<ul>
<li>两无符号变量</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331151240502.png" alt="image-20230331151240502"></p>
<ul>
<li>无符号在循环中的使用</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331151645721.png" alt="image-20230331151645721"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331151813957.png" alt="image-20230331151813957"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331151824133.png" alt="image-20230331151824133"></p>
<ul>
<li>可以用while循环</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331152040119.png" alt="image-20230331152040119"></p>
<h4 id="2-1-3字面值常量"><a href="#2-1-3字面值常量" class="headerlink" title="2.1.3字面值常量"></a>2.1.3字面值常量</h4><h5 id="整形和浮点型字面值"><a href="#整形和浮点型字面值" class="headerlink" title="整形和浮点型字面值"></a><strong>整形和浮点型字面值</strong></h5><p>​		我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331153727770.png" alt="image-20230331153727770"></p>
<p>​		浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识。默认的，浮点型字面值是一个double。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331153736003.png" alt="image-20230331153736003"></p>
<h5 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a><strong>字符和字符串字面值</strong></h5><p>​		由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。</p>
<p>​		字符串字面值的类型实际上是由常量字符构成的数组(aray)。编译器在每个字符串的结尾处添加一个空字符（’\0’），故字符串字面值的实际长度要比它的内容多1。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331153843194.png" alt="image-20230331153843194"></p>
<h5 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a><strong>转义序列</strong></h5><p>​		有两类字符程序员不能直接使用：一类是不可打印(nonprintable)的字符，如退格或其他控制字符，因为它们没有可视的图符：另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线)。在这些情况下需要用到转义序列(escape sequence)，转义序列均以反斜线作为开始.</p>
<p><img src="/2023/12/08/CPlusPlus02/%E8%BD%AC%E4%B9%89.png"></p>
<h5 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a><strong>指定字面值的类型</strong></h5><p>​		通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">L&#x27;a&#x27;</span>;		<span class="comment">//宽字符型字面值，类型是wchar_t</span></span><br><span class="line"><span class="string">u8&quot;hi!&quot;</span>;	<span class="comment">//utf-8字符串字面值(utf-8用8位编码一个Unicode字符)</span></span><br><span class="line"><span class="number">42ULL</span>;		<span class="comment">//无符号整型字面值，类型为unsigned long long</span></span><br><span class="line"><span class="number">1E-3F</span>;		<span class="comment">//单精度浮点型字面值，类型为float</span></span><br><span class="line"><span class="number">3.14159L</span>；	<span class="comment">//扩展精度浮点型字面值，类型为long double</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus02/20160316155707323.png" alt="img"></p>
<h5 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a><strong>布尔字面值和指针字面值</strong></h5><p>​		true和false是布尔类型的字面值，nullptr是指针字面值。</p>
<h3 id="2-2变量"><a href="#2-2变量" class="headerlink" title="2.2变量"></a>2.2变量</h3><p>​		变量提供一个具名的、可供程序操作的存储空间。C+中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量(variable)”和“对象(object)”一般可以互换使用。</p>
<h4 id="2-2-1变量定义"><a href="#2-2-1变量定义" class="headerlink" title="2.2.1变量定义"></a>2.2.1变量定义</h4><p>​		变量定义的基本形式是：首先是类型说明符(type specifier)，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331160317778.png" alt="image-20230331160317778"></p>
<h5 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a><strong>初始值</strong></h5><p>​		当对象在创建时获得了一个特定的值，我们说这个对象被初始化(initialized)了。用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331162757827.png" alt="image-20230331162757827"></p>
<h5 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a><strong>列表初始化</strong></h5><p><img src="/2023/12/08/CPlusPlus02/image-20230331163052359.png" alt="image-20230331163052359"></p>
<p>​		作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，用花括号初始化的形式被称为列表初始化(list initialization)。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。</p>
<p>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331163727229.png" alt="image-20230331163727229"></p>
<h5 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a><strong>默认初始化</strong></h5><p>​		如果定义变量时没有指定初值，则变量被默认初始化(default initialized)，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p>
<p>​		如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化(uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<h4 id="2-2-2变量声明和定义的关系"><a href="#2-2-2变量声明和定义的关系" class="headerlink" title="2.2.2变量声明和定义的关系"></a>2.2.2变量声明和定义的关系</h4><p>​		为了允许把程序拆分成多个逻辑部分来编写，C+语言支持分离式编译(separatecompilation)机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。如果将程序分为多个文件，则需要有在文件间共享代码的方法。</p>
<p>​		为了支持分离式编译，C+语言将声明和定义区分开来。声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(definition)负责创建与名字关联的实体。</p>
<p>​		变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</p>
<p>​		如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331165119668.png" alt="image-20230331165119668"></p>
<p>​		任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331165428628.png" alt="image-20230331165428628"></p>
<p>​		如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h4 id="2-2-3标识符"><a href="#2-2-3标识符" class="headerlink" title="2.2.3标识符"></a>2.2.3标识符</h4><p>​		C++的标识符(identifier)由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写字母敏感。同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
<h5 id="变量命名的规范"><a href="#变量命名的规范" class="headerlink" title="变量命名的规范"></a><strong>变量命名的规范</strong></h5><ol>
<li>需体现实际意义</li>
<li>变量名用小写字母</li>
<li>自定义类名用大写字母开头：Sales_item</li>
<li>标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。</li>
</ol>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331170128338.png" alt="image-20230331170128338"></p>
<h4 id="2-2-4名字的作用域"><a href="#2-2-4名字的作用域" class="headerlink" title="2.2.4名字的作用域"></a>2.2.4名字的作用域</h4><p>​		不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。<br>​		作用域(scope)是程序的一部分，在其中名字有其特定的含义。C+语言中大多数作用域都以花括号分隔。<br>​		同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//sum用于存放从1到10所有数的和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> val=<span class="number">1</span>; val &lt; <span class="number">10</span>; ++val)</span><br><span class="line">		sum += val;<span class="comment">//等价于sum=sum+val</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;1到10的总和为：&quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus02/image-20230331170559447.png" alt="image-20230331170559447"></p>
<p>​		名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有**<code>全局作用域（global scope)</code><strong>。一旦声明之后，全局作用域内的名字在整个程序的范围内都可使用。名字sum定义于main函数所限定的作用域之内，从声明sum开始直到main函数结束为止都可以访问它，但是出了main函数所在的块就无法访问了，因此说变量sum拥有</strong><code>块作用域(block scope)</code>**。名字val定义于for语句内，在for语句之内可以访问val，但是在main函数的其他部分就不能访问它了。</p>
<h5 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a><strong>嵌套的作用域</strong></h5><p>​		作用域能彼此包含，被包含（或者说被嵌套）的作用域称为内层作用域(inner scope)，包含着别的作用域的作用域称为外层作用域(outer scope)。<br>​		作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字：</p>
<blockquote>
<p>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>;<span class="comment">//reused拥有全局作用域</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> unique = <span class="number">0</span>;<span class="comment">//unique拥有块作用域</span></span><br><span class="line">	<span class="comment">//输出#1：使用全局变量reused;输出420</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	<span class="type">int</span> reused = <span class="number">0</span>;<span class="comment">//新建局部变量reused，覆盖了全局变量reused</span></span><br><span class="line">	<span class="comment">//输出#2：使用局部变量reused;输出00</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	<span class="comment">//输出#3：显式地访问全局变量reused;输出420</span></span><br><span class="line">	std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus02/image-20230331172830111.png" alt="image-20230331172830111"></p>
<blockquote>
<p>输出#1出现在局部变量reused定义之前，因此这条语句使用全局作用域中定义的名字reused，输出42 0。</p>
<p>输出#2发生在局部变量reused定义之后，此时局部变量reused正在作用域内(in scope)，因此第二条输出语句使用的是局部变量reused而非全局变量，输出0 0。</p>
<p>输出#3使用作用域操作符（参见1.2节，第7页）来覆盖默认的作用域规则，因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。结果是，第三条输出语句使用全局变量reused，输出42 0。</p>
</blockquote>
<h3 id="2-3复合类型"><a href="#2-3复合类型" class="headerlink" title="2.3复合类型"></a>2.3复合类型</h3><p>​		复合类型(compound type)是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两种：引用和指针。</p>
<p>​		与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很多。2.2节提到，一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。其实更通用的描述是，一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<p>​		目前为止，我们所接触的声明语句中，声明符其实就是变量名，此时变量的类型也就是声明的基本数据类型。其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。</p>
<h4 id="2-3-1引用"><a href="#2-3-1引用" class="headerlink" title="2.3.1引用"></a>2.3.1引用</h4><blockquote>
<p>C++11中新增了一种引用：所谓的“右值引用(rvalue reference)”，我们将在13.6.1节做更详细的介绍。这种引用主要用于内置类。严格来说，当我们使用术语“引用（reference)”时，指的其实是“左值引用(Ivaluereference)”</p>
</blockquote>
<p>​		引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331185116291.png" alt="image-20230331185116291"></p>
<p>​		一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定(bid)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
<blockquote>
<p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字</p>
</blockquote>
<p>​		定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331185628628.png" alt="image-20230331185628628"></p>
<p>​		为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331185635833.png" alt="image-20230331185635833"></p>
<h5 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a><strong>引用的定义</strong></h5><p>​		允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331190442097.png" alt="image-20230331190442097"></p>
<p>​		除了2.4.1节和15.2.3节将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起，相关原因将在2.4.1节详述：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331190600536.png" alt="image-20230331190600536"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">int</span>&amp; refval = ival;				<span class="comment">//refVal指向ival(是ival的另一个名字)</span></span><br><span class="line">	<span class="comment">/*int&amp; refval12;*/</span>				<span class="comment">//报错：引用必须被初始化</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;&amp;refval:&quot;</span> &lt;&lt; &amp;refval &lt;&lt; <span class="string">&quot;\trefval:&quot;</span> &lt;&lt; refval &lt;&lt; <span class="string">&quot;\tival:&quot;</span> &lt;&lt; ival &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	refval = <span class="number">2</span>;						<span class="comment">//把2赋给refval指向的对象，此处即是赋给了ival</span></span><br><span class="line">	<span class="type">int</span> li = refval;				<span class="comment">//与ii=ival执行结果一样</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;li:&quot;</span> &lt;&lt; li &lt;&lt; <span class="string">&quot;\t&amp;refval:&quot;</span> &lt;&lt; &amp;refval &lt;&lt; <span class="string">&quot;\trefval:&quot;</span> &lt;&lt; refval &lt;&lt; <span class="string">&quot;\tival:&quot;</span> &lt;&lt; ival &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上</span></span><br><span class="line">	<span class="type">int</span>&amp; refval3 = refval;</span><br><span class="line">	<span class="comment">//利用与refVal绑定的对象的值初始化变量i</span></span><br><span class="line">	<span class="type">int</span> i = refval;					<span class="comment">//正确：i被初始化为ival的值</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;li:&quot;</span> &lt;&lt; li &lt;&lt; <span class="string">&quot;\t&amp;refval:&quot;</span> &lt;&lt; &amp;refval &lt;&lt; <span class="string">&quot;\trefval:&quot;</span> &lt;&lt; refval &lt;&lt; <span class="string">&quot;\tival:&quot;</span> &lt;&lt; ival &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">1024</span>， i2 = <span class="number">2048</span>;		<span class="comment">//i和i2都是int</span></span><br><span class="line">	<span class="type">int</span>&amp; r = i， r2 = i2;			<span class="comment">//r是一个引用，与i绑定在一起，r2是int</span></span><br><span class="line">	<span class="type">int</span> i3 = <span class="number">1024</span>， &amp; ri = i3;		<span class="comment">//i3是int，ri是一个引用，与i3绑定在一起</span></span><br><span class="line">	<span class="type">int</span>&amp; r3 = i3， &amp; r4 = i2;		<span class="comment">//r3和r4都是引用</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\ti2:&quot;</span> &lt;&lt; i2 &lt;&lt; <span class="string">&quot;\t&amp;r:&quot;</span> &lt;&lt; &amp;r &lt;&lt; <span class="string">&quot;\tr2:&quot;</span> &lt;&lt; r2 &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;i3:&quot;</span> &lt;&lt; i3 &lt;&lt; <span class="string">&quot;\t&amp;ri:&quot;</span> &lt;&lt; &amp;ri &lt;&lt; <span class="string">&quot;\t&amp;r3:&quot;</span> &lt;&lt; &amp;r3 &lt;&lt; <span class="string">&quot;\t&amp;r4:&quot;</span> &lt;&lt; &amp;r4 &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus02/image-20230331191518543.png" alt="image-20230331191518543"></p>
<h4 id="2-3-2指针"><a href="#2-3-2指针" class="headerlink" title="2.3.2指针"></a>2.3.2指针</h4><p>​		指针(pointer)是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li>
<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ul>
<p>定义指针类型的方法将声明符写<code>*d</code>的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号<code>*</code>：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331192728429.png" alt="image-20230331192728429"></p>
<h5 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a><strong>获取对象的地址</strong></h5><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331193409629.png" alt="image-20230331193409629"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331194854449.png" alt="image-20230331194854449"></p>
<p>​		第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>​		除了2.4.2节和15.2.3节将要介绍的两种例外情况，其他所有指针的类型都要和它所指向的对象严格匹配：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331195407996.png" alt="image-20230331195407996"></p>
<h5 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a><strong>指针值</strong></h5><p>指针的值（即地址）应属于下列状态之一：</p>
<ul>
<li><p>指向一个对象。</p>
</li>
<li><p>指向紧邻对象所占空间的下一个位置。</p>
</li>
<li><p>空指针，即指针没有指向任何对象。</p>
</li>
<li><p>无效指针，即上述情况之外的其他值。</p>
</li>
</ul>
<p>试图拷贝或以其他方式访问无效指针的值都会引发错误。</p>
<h5 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a><strong>利用指针访问对象</strong></h5><p>​		如果指针指向一个对象，可以使用解引用（dereference）符<code>*</code>来访问该对象。</p>
<p>​		对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331201845389.png" alt="image-20230331201845389"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331200849583.png" alt="image-20230331200849583"></p>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a><strong>空指针</strong></h5><p>​		空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值<code>nullptr</code>来初始化指针。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331202255535.png" alt="image-20230331202255535"></p>
<p>​		得到空指针最直接的办法就是用字面值nu11ptr来初始化指针，这也是C+11新标准刚刚引入的一种方法。nu11ptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种办法就如对P2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。</p>
<p>​		把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331203808000.png" alt="image-20230331203808000"></p>
<h5 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a><strong>赋值和指针</strong></h5><p>​		指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p>
<p>​		指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331203914153.png" alt="image-20230331203914153"></p>
<p>​		有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331205145533.png" alt="image-20230331205145533"></p>
<p>​		意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。</p>
<h5 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a><strong>其他指针操作</strong></h5><p>​		只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则类似，如果指针的值是0，条件取fa1se:</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331212615488.png" alt="image-20230331212615488"></p>
<p>​		对于两个类型相同的合法指针，可以用相等操作符(&#x3D;&#x3D;)或不相等操作符(!&#x3D;)来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等：反之它们不相等。这里两个指针存放的地址值相同（两个指针相等）有三种可能：</p>
<ul>
<li>它们都为空</li>
<li>都指向同一个对象</li>
<li>或者都指向了同一个对象的下一地址。</li>
</ul>
<p>​		需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</p>
<p>​		因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。</p>
<h5 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a><strong><code>void*</code>指针</strong></h5><p>​		<code>void*</code>是一种特殊的指针类型，可用于存放任意对象的地址。一个<code>void*</code>指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：</p>
<p>​		利用<code>void*</code>指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void指针。不能直接操作<code>void*</code>指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。<br>​		概括说来，以<code>void*</code>的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象.</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331214907947.png" alt="image-20230331214907947"></p>
<h4 id="2-3-3理解复合类型的声明"><a href="#2-3-3理解复合类型的声明" class="headerlink" title="2.3.3理解复合类型的声明"></a>2.3.3理解复合类型的声明</h4><p>​		如前所述，变量的定义包括一个基本数据类型(base type)和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331215540562.png" alt="image-20230331215540562"></p>
<blockquote>
<p>&#x3D;&#x3D;很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明符的一部分罢了。&#x3D;&#x3D;</p>
</blockquote>
<h5 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a><strong>定义多个变量</strong></h5><p>​		涉及指针或引用的声明，一般有两种写法。</p>
<ul>
<li>第一种把修饰符和变量标识符写在一起：</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331220338178.png" alt="image-20230331220338178"></p>
<p>这种形式着重强调变量具有的复合类型。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331220948934.png" alt="image-20230331220948934"></p>
<blockquote>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331220819758.png" alt="image-20230331220819758"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331220716468.png"></p>
</blockquote>
<ul>
<li>第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量：</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230331220350373.png" alt="image-20230331220350373"></p>
<h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a><strong>指向指针的指针</strong></h5><p>​		般来说，声明符中修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。</p>
<p>​		通过*的个数可以区分指针的级别。也就是说，<code>**</code>表示指向指针的指针，<code>***</code>表示指向指针的指针的指针，以此类推：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401124128822.png" alt="image-20230401124128822"></p>
<p>​		此处pi是指向int型数的指针，而ppi是指向int型指针的指针，下图描述了它们之间的关系。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401124042631.png" alt="image-20230401124042631"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">int</span>* pi = &amp;ival;<span class="comment">//pi指向一个int型的数</span></span><br><span class="line">	<span class="type">int</span>** ppi = &amp;pi;<span class="comment">//ppi指向一个int型的指针</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The value of ival\n&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;ival：\t&quot;</span> &lt;&lt; ival &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;*pi：\t&quot;</span> &lt;&lt; *pi &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;pi：\t&quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;**ppi：\t&quot;</span> &lt;&lt; **ppi &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;*ppi：\t&quot;</span> &lt;&lt; *ppi &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;ppi：\t&quot;</span> &lt;&lt; ppi &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">		&lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus02/image-20230401124631609.png" alt="image-20230401124631609"></p>
<h5 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a><strong>指向指针的引用</strong></h5><p>​		引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401125957258.png" alt="image-20230401125957258"></p>
<blockquote>
<p>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</p>
</blockquote>
<h3 id="2-4const限定符"><a href="#2-4const限定符" class="headerlink" title="2.4const限定符"></a>2.4const限定符</h3><p>​		有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字const对变量的类型加以限定，因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往，初始值可以是任意复杂的表达式。</p>
<h5 id="初始化和const"><a href="#初始化和const" class="headerlink" title="初始化和const"></a><strong>初始化和const</strong></h5><p>​		正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限制就是只能在const类型的对象上执行不改变其内容的操作。</p>
<p>​		在不改变cost对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401132237166.png" alt="image-20230401132237166"></p>
<h5 id="默认状态下，const对象仅在文件内有效"><a href="#默认状态下，const对象仅在文件内有效" class="headerlink" title="默认状态下，const对象仅在文件内有效"></a><strong>默认状态下，const对象仅在文件内有效</strong></h5><p>​		如果程序包含多个文件，则每个用了cost对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，cost对象被设定为仅在文件内有效。当多个文件中出现了同名的cost变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>​		某些时候有这样一种cost变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类cost对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。</p>
<p>​		解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401132951913.png" alt="image-20230401132951913"></p>
<blockquote>
<p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
</blockquote>
<h4 id="2-4-1const引用"><a href="#2-4-1const引用" class="headerlink" title="2.4.1const引用"></a>2.4.1const引用</h4><p>​		可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401134505607.png" alt="image-20230401134505607"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401134519729.png" alt="image-20230401134519729"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401142546208.png" alt="image-20230401142546208"></p>
<blockquote>
<p>&#x3D;&#x3D;术语：常量引用是对const的引用&#x3D;&#x3D;</p>
<hr>
<p>​		&#x3D;&#x3D;C++程序员们经常把词组“对const的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。&#x3D;&#x3D;</p>
<p>​		&#x3D;&#x3D;严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。&#x3D;&#x3D;</p>
</blockquote>
<h5 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a><strong>初始化和对const的引用</strong></h5><p>​		一般情况下，引用的类型必须与其所引用对象的类型一致，但是有两个例外。**<code>第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</code>**尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401135058019.png" alt="image-20230401135058019"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401143237811.png" alt="image-20230401143237811"></p>
<p>原因：</p>
<p><img src="../../../../../../HEXO-1/source/_posts/C/image-20230401135248377.png" alt="image-20230401135248377"  /><img src="../../../../../../HEXO-1/source/_posts/C/image-20230401135256192.png" alt="image-20230401135256192"  /></p>
<p>​		此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了右侧，在这种情况下，ri绑定了一个临时量(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C+程序员们常常把临时量对象简称为临时量。</p>
<p>​		接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。**<code>如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。</code>**但此时绑定的对象是一个临时量而非dval。C++语言也就把这种行为<code>归为非法</code>。</p>
<h5 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a><strong>对const的引用可能引用一个并非const的对象</strong></h5><p>​		必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401140704421.png" alt="image-20230401140704421"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401143836616.png" alt="image-20230401143836616"></p>
<h4 id="2-4-2指针和const"><a href="#2-4-2指针和const" class="headerlink" title="2.4.2指针和const"></a>2.4.2指针和const</h4><p>​		与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针(pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401142054539.png" alt="image-20230401142054539"></p>
<p>​		2.3.2节提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401142209766.png" alt="image-20230401142209766"></p>
<p>​		和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</p>
<blockquote>
<p>试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去玫变所指对象的值。</p>
</blockquote>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401145609817.png" alt="image-20230401145609817"></p>
<h5 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><strong>const指针</strong></h5><p>​		指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer)必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址)就不能再改变了。把<code>*</code>放在cost关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401150054016.png" alt="image-20230401150054016"></p>
<p>​	<img src="/2023/12/08/CPlusPlus02/image-20230401150858001.png" alt="image-20230401150858001"></p>
<p>​	指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401150308582.png" alt="image-20230401150308582"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong><code>总结</code></strong></h5><h6 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a><strong><code>常量指针</code></strong></h6><p>常量const，指针<code>*</code>，这里把<code>*</code>p，看做一个整体，被const修饰，<code>const（*p）</code>。</p>
<p><img src="/../../../../../../HEXO-1/source/_posts/C2/253cedd7C24e88e659e612c4a6fe0e1c.png" alt="img"></p>
<ol>
<li><p>定义： 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</p>
<blockquote>
<p>*p1的值不可以被更改</p>
<p>p1的值可以被更改</p>
<p>可以通过修改原来的声明修改*p值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK，仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p1 = <span class="number">56</span>;  	 <span class="comment">//Error，*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK，指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>关键点：</p>
<ol>
<li>常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li>
<li>常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；</li>
<li>指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li>
</ol>
</li>
<li><p>代码形式：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span>* p;  <span class="type">const</span> <span class="type">int</span>* p;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong style="color:#3eb985;">常量指针</strong>就是一个指针指向一个常量，并且这个指针是可以改变的，指针可以改变指向的常量、变量，指针指向的变量是可以修改的，但是只限于变量本身去修改，不能够通过指针的形式来修改该值。</p>
</blockquote>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401161133618.png" alt="image-20230401161133618"></p>
<h6 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a><strong><code>指针常量</code></strong></h6><p>指针<code>*</code>，常量const，const修饰q，，<code>* const（p）</code>。</p>
<p><img src="/2023/12/08/CPlusPlus02/152647b5c91624eb6d2947b7ae3f6a6d.png" alt="img"></p>
<ol>
<li><p>定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p>
<blockquote>
<p>*p2的值可以被更改</p>
<p>p2的值不可以被更改</p>
<p>可以通过修改原来的声明修改*p值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK，仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK，指针是常量，指向的地址不可以变化，但是指向的地址所对应的内容可以变化</span></span><br><span class="line">p2 = &amp;b;     <span class="comment">//Error，因为p2是const 指针，因此不能改变p2指向的内容</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>关键点：</p>
<ol>
<li>它是个常量！</li>
<li>指针本身是常量，指向的地址不可以变化，但是指向的地址所对应的内容可以变化；</li>
</ol>
</li>
<li><p>代码形式：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong style="color:#3eb985;">指针常量</strong>指针常量是指指针本身所指向的常量&#x2F;变量的地址值不能改变，但是可以通过<code>*p</code>去改变变量的值。</p>
</blockquote>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401161258383.png" alt="image-20230401161258383"></p>
<h6 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a><strong><code>指向常量的常指针</code></strong></h6><blockquote>
<p>*p2的值可以被更改</p>
<p>p2的值不可以被更改</p>
<p>可以通过修改原来的声明修改*p值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK，仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//Error，*p2是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p2 = &amp;b;     <span class="comment">//Error，因为p2是const 指针，因此不能改变p2指向的内容</span></span><br></pre></td></tr></table></figure></blockquote>
<ol>
<li>定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量，<code>const(*const(p))</code>。</li>
<li>关键点：<ol>
<li>它是个常量！指向的也是常量！</li>
<li>指针本身是常量，指向的地址不可以变化，但是指向的地址所对应的内容可以变化；</li>
</ol>
</li>
<li>代码形式：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong style="color:#3eb985;">常量指针常量</strong> 就融合了指针常量和常量指针的特性，即指针不能指向别的变量、常量，并且不能通过指针去修改变量的数值。</p>
</blockquote>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401161348741.png" alt="image-20230401161348741"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK，仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error，*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK，指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="type">int</span>*  <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK，仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK，指针是常量，指向的地址不可以变化，但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error，因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK，仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus02/image-20230401153443333.png" alt="image-20230401153443333"></p>
<h4 id="2-4-3顶层const"><a href="#2-4-3顶层const" class="headerlink" title="2.4.3顶层const"></a><code>2.4.3顶层const</code></h4><p>​		指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。&#x3D;&#x3D;<strong>用名词顶层const(top-level const)表示指针<code>本身</code>是个常量</strong>&#x3D;&#x3D;，&#x3D;&#x3D;<strong>而用名词底层const(low-level const)表示指针所指的<code>对象</code>是一个常量</strong>&#x3D;&#x3D;。</p>
<p>​		更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层cost则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显：</p>
<blockquote>
<p>顶层：</p>
<ul>
<li>*p1的值可以被更改</li>
<li>p1的值不可以被更改</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401165858845.png" alt="image-20230401165858845"></p>
<table>
<thead>
<tr>
<th>引用</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>实际上没有常量引用这种东西，因为引用不是一个对象，我们没法让引用本身恒定不变。</td>
<td><strong>常量指针</strong>：指针本身为常量。<br/><code>int a = 0;</code><br/><code>int *const p1 = &amp;a;</code></td>
</tr>
<tr>
<td>引用没有顶层const</td>
<td>1） 指针本身为常量，初始化后，则指针的值（也就是存放在指针中的那个地址）就不能再被改变了。<br/><br/>2） 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做依赖于所指对象的类型。<br/><br/>例子：<br/><code>int a = 0;</code><br/><code>int *const p1 = &amp;a;</code>&#x2F;&#x2F; 所指对象是非常量<br/><code>*p1=2;</code> &#x2F;&#x2F; 可以这样修改所指对象*p1的值&#96;</td>
</tr>
</tbody></table>
<p>底层：</p>
<ul>
<li>*p2的值不可以被更改</li>
<li>p2的值可以被更改</li>
</ul>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401170428942.png" alt="image-20230401170428942"></p>
<table>
<thead>
<tr>
<th>引用</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对const的引用</strong>：把引用绑定到const对象上。对常量的引用不能被用作修改它所绑定的对象。<br/>“对const的引用”简称为“常量引用”，不过你得时刻记得这就是个简称而已。</td>
<td><strong>指向常量的指针</strong>：指针指向const对象。</td>
</tr>
<tr>
<td>1） 正常情况：将const int &amp;绑定到const对象上。<br/>例子：<br/><code>const int a = 1;</code><br/><code>const int &amp;r1 = a;</code><br/>2） 例外情况：引用的类型必须与引用的对象类型一致，但有两个例外：一种例外情况就是允许将const int &amp;绑定到一个普通int对象上。<br/>此时不能通过引用去修改被绑定对象的值，但可以通过别的方式修改对象的值。<br/>例子：<br/><code>int a=0;</code><br/><code>const int &amp;r1 = a;</code><br/>a &#x3D;1; &#x2F;&#x2F; 可以修改a的值，因为a是非常量<br/>3） 允许将const int &amp;和字面值或某个表达式的计算结果绑定到一起。<br/><code>const int &amp;r2 = 2;</code><br/><code>const int &amp;r3 = a*3;</code></td>
<td>1） 正常情况：让const int *指向常量对象。<br/><br/>例子<br/><code>const int a = 1;</code><br/><code>const int *p = &amp;a;</code><br/><code>p =nullptr;</code> &#x2F;&#x2F; 指针本身不是const型，可以修改<br/>2） 例外情况：指针的类型必须与所指对象的类型一致，但有两个例外：一种例外情况就是允许令一个指向常量的指针指向一个非常量的对象（就问你这句话绕不绕）。此时不能通过该指针改变对象的值，但没有规定那个对象的值不能通过其他途径改变。<br/>例子：<br/><code>int a = 0;</code><br/><code>const int *p = &amp;a;</code><br/><code>a = 1;</code> &#x2F;&#x2F; 可以修改a的值，因为a是非常量</td>
</tr>
</tbody></table>
<p><img src="/../../../../../../HEXO-1/source/_posts/C2/watermark%EF%BC%8Ctype_ZmFuZ3poZW5naGVpdGk%EF%BC%8Cshadow_10%EF%BC%8Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIyMjMyNA==%EF%BC%8Csize_16%EF%BC%8Ccolor_FFFFFF%EF%BC%8Ct_70.png" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p1 = &amp;i;			<span class="comment">//  不能改变 p1 的值，这是一个顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;			<span class="comment">//  不能改变 ci 的值，这是一个顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2 = &amp;ci;		<span class="comment">//  允许改变 p2 的值，这是一个底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = p2;   <span class="comment">//  靠右的 const 是顶层 const，靠左的是底层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r = ci;			<span class="comment">//  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const</span></span><br></pre></td></tr></table></figure>

<p>​		当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响，执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ci;     <span class="comment">//  正确：拷贝 ci 的值给 i，ci 是一个顶层 const，对此操作无影响。</span></span><br><span class="line">p2 = p3;    <span class="comment">//  正确：p2 和 p3 指向的对象相同，p3 顶层 const 的部分不影响。</span></span><br></pre></td></tr></table></figure>

<p>​		另一方面，底层cost的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层cost资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = p3;   		 <span class="comment">//  错误：p3 包含底层 const 的定义，而p没有。假设成功，p 就可以改变 p3 指向的对象的值。</span></span><br><span class="line">p2 = p3;             <span class="comment">//  正确：p2 和 p3 都是底层 const</span></span><br><span class="line">p2 = &amp;i;             <span class="comment">//  正确：int* 能够转化为 const int*，这也是形参是底层const的函数形参传递外部非 const 指针的基础。</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci;   		 <span class="comment">//  错误：普通 int&amp; 不能绑定到 int 常量中。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;   <span class="comment">//  正确：const int&amp; 可以绑定到一个普通 int 上。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-4constexper和常量表达"><a href="#2-4-4constexper和常量表达" class="headerlink" title="2.4.4constexper和常量表达"></a>2.4.4constexper和常量表达</h4><p>​		&#x3D;&#x3D;常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式。&#x3D;&#x3D;显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象（或表达式)是不是常量表达式由它的数据类型和初始值共同决定。</p>
<h5 id="constexper变量"><a href="#constexper变量" class="headerlink" title="constexper变量"></a><strong>constexper变量</strong></h5><p>​		在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。当然可以定义一个cost变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。<br>​		C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230401185101245.png" alt="image-20230401185101245"></p>
<blockquote>
<p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p>
</blockquote>
<h5 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a><strong>字面值类型</strong></h5><p>​		常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”(literal type)。到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类Sales item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。</p>
<h5 id="指针和constexper"><a href="#指针和constexper" class="headerlink" title="指针和constexper"></a><strong>指针和constexper</strong></h5><p>​		必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402143224619.png" alt="image-20230402143224619"></p>
<p>​		与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402143235510.png" alt="image-20230402143235510"></p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402144455978.png" alt="image-20230402144455978"></p>
<h3 id="2-5处理类型"><a href="#2-5处理类型" class="headerlink" title="2.5处理类型"></a>2.5处理类型</h3><h4 id="2-5-1类型别名"><a href="#2-5-1类型别名" class="headerlink" title="2.5.1类型别名"></a>2.5.1类型别名</h4><p>​		类型别名(type alias)是一个名字，它是某种类型的同义词。</p>
<p>​		有两种方法可用于定义类型别名。</p>
<ol>
<li><p>传统的方法是使用关键字typedef:</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402151828997.png" alt="image-20230402151828997"></p>
</li>
<li><p>新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402151846694.png" alt="image-20230402151846694"></p>
</li>
</ol>
<p>​		类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wages hourly，weekly;<span class="comment">//等价于double hour1y、weekly;</span></span><br><span class="line">SI item;<span class="comment">//等价于Sales_item item</span></span><br></pre></td></tr></table></figure>

<h5 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a><strong>指针、常量和类型别名</strong></h5><p>​		如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402160239193.png" alt="image-20230402160239193"></p>
<p>​		再强调一遍：这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用<code>char*</code>重写了声明语句后，数据类型就变成了<code>char</code>，<code>*</code>成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。上下两种声明含义截然不同，上面的声明了一个指向char的常量指针，下面的的形式则声明了一个指向const char的指针。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402165618411.png" alt="image-20230402165618411"></p>
<h4 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h4><p>​		编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型，但有时很困难。为了解决这个问题，C++引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double)不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402170336380.png" alt="image-20230402170336380"></p>
<p>​		使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402170405786.png" alt="image-20230402170405786"></p>
<h5 id="复合类型、常量和auto"><a href="#复合类型、常量和auto" class="headerlink" title="复合类型、常量和auto"></a><strong>复合类型、常量和auto</strong></h5><p>​		编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。</span></span><br><span class="line">	<span class="comment">//此时编译器以引用对象的类型作为auto的类型：</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>， &amp; r = i;</span><br><span class="line">	<span class="keyword">auto</span> a = r; <span class="comment">//a是一个整数(r是i的别名， 而i是一个整数）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> ci = i， &amp; cr = ci;</span><br><span class="line">	<span class="keyword">auto</span> b = ci;<span class="comment">//b是一个整数（ci的顶层const特性被忽略掉了)</span></span><br><span class="line">	<span class="keyword">auto</span> c = cr;<span class="comment">//c是一个整数(cx是ci的别名，ci本身是一个顶层const)</span></span><br><span class="line">	<span class="keyword">auto</span> d = &amp;i;<span class="comment">//d是一个整型指针（整数的地址就是指向整数的指针）</span></span><br><span class="line">	<span class="keyword">auto</span> e = &amp;ci;<span class="comment">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果希望推断出的auto类型是一个项层const，需要明确指出：</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> f = ci;<span class="comment">//ci的推演类型是int，f是const int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; g = ci;<span class="comment">//g是一个整型常量引用，绑定到ci</span></span><br><span class="line">	<span class="comment">//auto&amp; h =42;//错误：不能为非常量引用绑定字面值</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span>&amp; j = <span class="number">42</span>;<span class="comment">//正确：可以为常量引用绑定字面值</span></span><br><span class="line">	<span class="comment">//设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：</span></span><br><span class="line">	<span class="keyword">auto</span> k = ci， &amp; l = i;<span class="comment">//k是整数，1是整型引用</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; m = ci， * p = &amp;ci;<span class="comment">//m是对整型常量的引用，p是指向整型常量的指针</span></span><br><span class="line">	<span class="comment">//auto&amp; n = i， * p2 = &amp;ci;//错误：i的类型是int而&amp;ci的类型是const int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h4><p>​		C++引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型，从表达式的类型推断出要定义的变量的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402172633854.png" alt="image-20230402172633854"></p>
<p>​		decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402172829589.png" alt="image-20230402172829589"></p>
<h5 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a><strong>decltype和引用</strong></h5><p>​		如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402185428696.png" alt="image-20230402185428696"></p>
<p>​		另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&amp;，而非int。</p>
<p>​		decltype和auto的另一处重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型：如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：</p>
<p><img src="/2023/12/08/CPlusPlus02/image-20230402185731837.png" alt="image-20230402185731837"></p>
<blockquote>
<p>切记：decltype((variable)(注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p>
</blockquote>
<h3 id="2-6自定义数据结构"><a href="#2-6自定义数据结构" class="headerlink" title="2.6自定义数据结构"></a>2.6自定义数据结构</h3><p>​	数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。C++语言允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的，就像第1章的Sales item类型一样。</p>
<h4 id="2-6-1-定义Sales-data类型"><a href="#2-6-1-定义Sales-data类型" class="headerlink" title="2.6.1 定义Sales_data类型"></a>2.6.1 定义Sales_data类型</h4><p>​		我们的类以关键字struct开始， 紧跟着类名和类体（其中类体部分可以为空）。类体由花括号包围形成了一个新的作用域（参见2.2.4节，第43页)。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="类数据成员"><a href="#类数据成员" class="headerlink" title="类数据成员"></a><strong>类数据成员</strong></h5><p>​		类体定义类的成员，我们的类只有数据成员(data member)。类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。定义数据成员的方法和定义普通变量一样：首先说明一个基本类型，随后紧跟一个或多个声明符。C++新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。对类内初始值的限制与之前介绍的类似：或者放在花括号里，或者放在等号右边，记住不能使用圆括号。</p>
<h4 id="2-6-2使用Sales-data类"><a href="#2-6-2使用Sales-data类" class="headerlink" title="2.6.2使用Sales_data类"></a>2.6.2使用Sales_data类</h4><h5 id="添加两个Sales-data对象"><a href="#添加两个Sales-data对象" class="headerlink" title="添加两个Sales_data对象"></a><strong>添加两个Sales_data对象</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sales_data data1， data2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Sales-data对象读入数据"><a href="#Sales-data对象读入数据" class="headerlink" title="Sales_data对象读入数据"></a><strong>Sales_data对象读入数据</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> price = <span class="number">0</span>;  <span class="comment">//书的单价，用于计算销售收入</span></span><br><span class="line"><span class="comment">//读入第1笔交易：ISBN、销售数量、单价</span></span><br><span class="line">std::cin &gt;&gt; data<span class="number">1.</span>bookNo &gt;&gt; data<span class="number">1.</span>units_sold &gt;&gt; price;</span><br><span class="line"><span class="comment">//计算销售收入</span></span><br><span class="line">data<span class="number">1.</span>revenue = data<span class="number">1.</span>units_sold * price;</span><br><span class="line"><span class="comment">//读入第2笔交易</span></span><br><span class="line">std::cin &gt;&gt; data<span class="number">2.</span>bookNo &gt;&gt; data<span class="number">2.</span>units_sold &gt;&gt; price;</span><br><span class="line">data<span class="number">2.</span>revenue = data<span class="number">2.</span>units_sold * price;</span><br></pre></td></tr></table></figure>

<h5 id="输出两个Sales-data对象的和"><a href="#输出两个Sales-data对象的和" class="headerlink" title="输出两个Sales_data对象的和"></a><strong>输出两个Sales_data对象的和</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查两笔交易涉及的ISBN编号是否相同。如果相同输出它们的和，否则输出一条报错信息.</span></span><br><span class="line"><span class="keyword">if</span> (data<span class="number">1.</span>bookNo == data<span class="number">2.</span>bookNo) &#123;</span><br><span class="line">	<span class="type">unsigned</span> totalCnt = data<span class="number">1.</span>units_sold + data<span class="number">2.</span>units_sold;</span><br><span class="line">	<span class="type">double</span> totalRevenue = data<span class="number">1.</span>revenue + data<span class="number">2.</span>revenue;</span><br><span class="line">	<span class="comment">//输出：ISBN、总销售量、总销售额、平均价格</span></span><br><span class="line">	std::cout &lt;&lt; data<span class="number">1.</span>bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalCnt</span><br><span class="line">		&lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (totalCnt != <span class="number">0</span>)</span><br><span class="line">		std::cout &lt;&lt; totalRevenue / totalCnt &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;(no sales)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//标示成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">//两笔交易的ISBN不一样</span></span><br><span class="line">	std::cerr &lt;&lt; <span class="string">&quot;Data must refer to the same ISBN&quot;</span></span><br><span class="line">		&lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//标示失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3编写自己的头文件"><a href="#2-6-3编写自己的头文件" class="headerlink" title="2.6.3编写自己的头文件"></a>2.6.3编写自己的头文件</h4><p>​		为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。头文件也经常用到其他头文件的功能。</p>
<blockquote>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
</blockquote>
<h5 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a><strong>预处理器概述</strong></h5><p>​		确保头文件多次包含仍能安全工作的常用技术是预处理器(preprocessor)，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。</p>
<p>​		C++程序还会用到的一项预处理功能是头文件保护符(header guard)，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</p>
<p><code>Sales_data.h</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>Sales_data.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sales_data data1， data2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入datal和data2的代码</span></span><br><span class="line">	<span class="type">double</span> price = <span class="number">0</span>;  <span class="comment">//书的单价，用于计算销售收入</span></span><br><span class="line">	std::cin &gt;&gt; data<span class="number">1.</span>bookNo &gt;&gt; data<span class="number">1.</span>units_sold &gt;&gt; price;<span class="comment">//读入第1笔交易：ISBN、销售数量、单价</span></span><br><span class="line">	data<span class="number">1.</span>revenue = data<span class="number">1.</span>units_sold * price;	<span class="comment">//计算销售收入</span></span><br><span class="line">	<span class="comment">//读入第2笔交易</span></span><br><span class="line">	std::cin &gt;&gt; data<span class="number">2.</span>bookNo &gt;&gt; data<span class="number">2.</span>units_sold &gt;&gt; price;</span><br><span class="line">	data<span class="number">2.</span>revenue = data<span class="number">2.</span>units_sold * price;</span><br><span class="line">	<span class="comment">//检查两笔交易涉及的ISBN编号是否相同。如果相同输出它们的和，否则输出一条报错信息.</span></span><br><span class="line">	<span class="keyword">if</span> (data<span class="number">1.</span>bookNo == data<span class="number">2.</span>bookNo) &#123;</span><br><span class="line">		<span class="type">unsigned</span> totalCnt = data<span class="number">1.</span>units_sold + data<span class="number">2.</span>units_sold;</span><br><span class="line">		<span class="type">double</span> totalRevenue = data<span class="number">1.</span>revenue + data<span class="number">2.</span>revenue;</span><br><span class="line">		<span class="comment">//输出：ISBN、总销售量、总销售额、平均价格</span></span><br><span class="line">		std::cout &lt;&lt; data<span class="number">1.</span>bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalCnt</span><br><span class="line">			&lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (totalCnt != <span class="number">0</span>)</span><br><span class="line">			std::cout &lt;&lt; totalRevenue / totalCnt &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;(no sales)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//标示成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;  <span class="comment">//两笔交易的ISBN不一样</span></span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Data must refer to the same ISBN&quot;</span></span><br><span class="line">			&lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//标示失败</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus02/image-20230402201249907.png" alt="image-20230402201249907"></p>
<p>​		整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</p>
<blockquote>
<ol>
<li>预处理变量无视C++语言中关于作用域的规则.</li>
<li>头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要.</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://alsl521.github.io">kyl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://alsl521.github.io/2023/12/08/CPlusPlus02/">https://alsl521.github.io/2023/12/08/CPlusPlus02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://alsl521.github.io" target="_blank">kyl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">C++基础入门</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/12/08/CPlusPlus01/" title="C++基础入门第一章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++基础入门第一章</div></div><div class="info-2"><div class="info-item-1">第一章 开始1.1	编写一个简单的C++程序12345#include &lt;iostream&gt;int main()&#123;    return 0;&#125;  ​		一个函数的定义包含四部分：返回类型(return type)、函数名(function name)、一个括号包围的形参列表(parameter list ，允许为空)以及函数体(function body)。虽然main函数在某种程度上比较特殊，但其定义与其他函数是一样的。 ​		在本例中，main的形参列表是空的(()中什么也没有)。 ​		main函数的返回类型必须为int，即整数类型。int类型是一种内置类型(built-intype)，即语言自身定义的类型。 ​		函数定义的最后一部分是函数体，它是一个以左花括号(curly brace)开始，以右花括号结束的语句块(block of...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus03/" title="C++基础入门第三章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++基础入门第三章</div></div><div class="info-2"><div class="info-item-1">第三章 字符串、向量和数组3.1 命名空间using声明​		目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显式地将这一点标示了出来。因此，std::cin的意思就是要使用命名空间std中的名字cin。有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：  ​		一旦声明了上述语句，就可以直接访问命名空间中的名字. 每个名字都需要独立的using声明​		按照规定，每个using声明引入命名空间中的一个成员。  头文件不应包含using声明​		位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。 3.2 标准库类型string​		标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。 3.2.1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/12/08/CPlusPlus01/" title="C++基础入门第一章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第一章</div></div><div class="info-2"><div class="info-item-1">第一章 开始1.1	编写一个简单的C++程序12345#include &lt;iostream&gt;int main()&#123;    return 0;&#125;  ​		一个函数的定义包含四部分：返回类型(return type)、函数名(function name)、一个括号包围的形参列表(parameter list ，允许为空)以及函数体(function body)。虽然main函数在某种程度上比较特殊，但其定义与其他函数是一样的。 ​		在本例中，main的形参列表是空的(()中什么也没有)。 ​		main函数的返回类型必须为int，即整数类型。int类型是一种内置类型(built-intype)，即语言自身定义的类型。 ​		函数定义的最后一部分是函数体，它是一个以左花括号(curly brace)开始，以右花括号结束的语句块(block of...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus04/" title="C++基础入门第四章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第四章</div></div><div class="info-2"><div class="info-item-1">第四章 表达式​		表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式(expression),其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。 4.1 基础4.1.1 基本概念​		C+定义了一元运算符(unary operator)和二元运算符(binary operator)。作用于一个运算对象的运算符是一元运算符，如取地址符&amp;和解引用符*：作用于两个运算对象的运算符是二元运算符，如相等运算符=和乘法运算符*。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。一些符号既能作为一元运算符也能作为二元运算符。 组合运算符和运算对象​		对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级(precedence)、结合律(associativity)以及运算对象的求值顺序(order of evaluation)。 12345678910#include...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus03/" title="C++基础入门第三章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第三章</div></div><div class="info-2"><div class="info-item-1">第三章 字符串、向量和数组3.1 命名空间using声明​		目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显式地将这一点标示了出来。因此，std::cin的意思就是要使用命名空间std中的名字cin。有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：  ​		一旦声明了上述语句，就可以直接访问命名空间中的名字. 每个名字都需要独立的using声明​		按照规定，每个using声明引入命名空间中的一个成员。  头文件不应包含using声明​		位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。 3.2 标准库类型string​		标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。 3.2.1...</div></div></div></a><a class="pagination-related" href="/2023/12/11/Linux1/" title="黑马程序员--Linux安装各类软件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-11</div><div class="info-item-2">黑马程序员--Linux安装各类软件</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/01/20/Little-knowledge-of-Java-4/" title="Java学习（四）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-20</div><div class="info-item-2">Java学习（四）</div></div><div class="info-2"><div class="info-item-1">接口接口( interface)，接口用来描述类应该做什么，而不指定它们具体应该如何做。一个类可以实现(implement ) 一个或多个接口。有些悄况可能要求符合这些接口，只要有这种要求，就可以使用实现了这个接口的类（即实现类）的对象。 官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 接口的概念在Java 程序设计语言中，接口不是类，而是对希望符合这个接口的类的一组需求。 接口中的所有方法都自动是public 方法。因此，在接口中声明方法时，不必提供关键字public 。不过，在实现接口时，必须把方法声明为public; 否则，编译器将认为这个方法的访问属性是包可见性，这是类的默认访问属性，之后编译器就会报错，指出你试图提供更严格的访问权限。 1234567//接口的定义格式：interface 接口名称&#123;    // 抽象方法&#125;// 接口的声明：interface//...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-4/" title="Java学习-SSM-4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-4</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kyl</div><div class="author-info-description">用于记录平时学习的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/alsl521" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:852970167@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">第二章 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">2.1基本内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1%E7%AE%97%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1.1算数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">带符号类型和无符号类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.1.2类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">含有无符号类型的表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.1.3字面值常量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%BD%A2%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">整形和浮点型字面值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">字符和字符串字面值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">指定字面值的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8C%E6%8C%87%E9%92%88%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">布尔字面值和指针字面值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.2变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.2.1变量定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">初始值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">默认初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2.2变量声明和定义的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.2.3标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E8%A7%84%E8%8C%83"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">变量命名的规范</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.2.4名字的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">嵌套的作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">2.3复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.3.1引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">引用的定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.3.2指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">获取对象的地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%80%BC"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">指针值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">利用指针访问对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">空指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">赋值和指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">其他指针操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">void*指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3%E7%90%86%E8%A7%A3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3.3理解复合类型的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">定义多个变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">指向指针的引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">2.4const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Cconst"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">初始化和const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81%E4%B8%8B%EF%BC%8Cconst%E5%AF%B9%E8%B1%A1%E4%BB%85%E5%9C%A8%E6%96%87%E4%BB%B6%E5%86%85%E6%9C%89%E6%95%88"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">默认状态下，const对象仅在文件内有效</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1const%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">2.4.1const引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AF%B9const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">初始化和对const的引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9const%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%AF%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%B9%B6%E9%9D%9Econst%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">对const的引用可能引用一个并非const的对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.4.2指针和const</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E6%8C%87%E9%92%88"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">const指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">常量指针</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">指针常量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88"><span class="toc-number">1.4.2.2.3.</span> <span class="toc-text">指向常量的常指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%E9%A1%B6%E5%B1%82const"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.4.3顶层const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4constexper%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE"><span class="toc-number">1.4.4.</span> <span class="toc-text">2.4.4constexper和常量表达</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#constexper%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">constexper变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">字面值类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconstexper"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">指针和constexper</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">2.5处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">2.5.1类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E3%80%81%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">指针、常量和类型别名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.5.2 auto类型说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E3%80%81%E5%B8%B8%E9%87%8F%E5%92%8Cauto"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">复合类型、常量和auto</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.5.3.</span> <span class="toc-text">2.5.3 decltype类型指示符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#decltype%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">decltype和引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">2.6自定义数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E5%AE%9A%E4%B9%89Sales-data%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">2.6.1 定义Sales_data类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">类数据成员</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2%E4%BD%BF%E7%94%A8Sales-data%E7%B1%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.6.2使用Sales_data类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%A4%E4%B8%AASales-data%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">添加两个Sales_data对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sales-data%E5%AF%B9%E8%B1%A1%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">Sales_data对象读入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%B8%A4%E4%B8%AASales-data%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%92%8C"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">输出两个Sales_data对象的和</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">2.6.3编写自己的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">预处理器概述</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/21/NET-ASP-13/" title="ASP.NET学习记录-13-实践2-数据库进阶">ASP.NET学习记录-13-实践2-数据库进阶</a><time datetime="2025-04-21T08:39:19.000Z" title="发表于 2025-04-21 16:39:19">2025-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-12/" title="ASP.NET学习记录-12-实践2-使用MySQL数据库">ASP.NET学习记录-12-实践2-使用MySQL数据库</a><time datetime="2025-04-18T08:11:21.000Z" title="发表于 2025-04-18 16:11:21">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-11/" title="ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API">ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API</a><time datetime="2025-04-18T02:13:44.000Z" title="发表于 2025-04-18 10:13:44">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/NET-ASP-10/" title="ASP.NET学习记录-10-过滤">ASP.NET学习记录-10-过滤</a><time datetime="2025-04-16T12:02:16.000Z" title="发表于 2025-04-16 20:02:16">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/15/Software/" title="记录必备软件">记录必备软件</a><time datetime="2025-04-15T11:29:21.000Z" title="发表于 2025-04-15 19:29:21">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By kyl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>