<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++基础入门第三章 | kyl的博客</title><meta name="author" content="kyl"><meta name="copyright" content="kyl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++字符串、向量和数组">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础入门第三章">
<meta property="og:url" content="https://alsl521.github.io/2023/12/08/CPlusPlus03/index.html">
<meta property="og:site_name" content="kyl的博客">
<meta property="og:description" content="C++字符串、向量和数组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4">
<meta property="article:published_time" content="2023-12-08T10:52:00.000Z">
<meta property="article:modified_time" content="2025-04-08T07:48:30.673Z">
<meta property="article:author" content="kyl">
<meta property="article:tag" content="C++基础入门">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++基础入门第三章",
  "url": "https://alsl521.github.io/2023/12/08/CPlusPlus03/",
  "image": "https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4",
  "datePublished": "2023-12-08T10:52:00.000Z",
  "dateModified": "2025-04-08T07:48:30.673Z",
  "author": [
    {
      "@type": "Person",
      "name": "kyl",
      "url": "https://alsl521.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://alsl521.github.io/2023/12/08/CPlusPlus03/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++基础入门第三章',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">kyl的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++基础入门第三章</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++基础入门第三章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-08T10:52:00.000Z" title="发表于 2023-12-08 18:52:00">2023-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-08T07:48:30.673Z" title="更新于 2025-04-08 15:48:30">2025-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h2><h3 id="3-1-命名空间using声明"><a href="#3-1-命名空间using声明" class="headerlink" title="3.1 命名空间using声明"></a>3.1 命名空间using声明</h3><p>​		目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显式地将这一点标示了出来。因此，std::cin的意思就是要使用命名空间std中的名字cin。有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：</p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230402202224898.png" alt="image-20230402202224898"></p>
<p>​		一旦声明了上述语句，就可以直接访问命名空间中的名字.</p>
<h5 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a><strong>每个名字都需要独立的using声明</strong></h5><p>​		按照规定，每个using声明引入命名空间中的一个成员。</p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230402202940589.png" alt="image-20230402202940589"></p>
<h5 id="头文件不应包含using声明"><a href="#头文件不应包含using声明" class="headerlink" title="头文件不应包含using声明"></a><strong>头文件不应包含using声明</strong></h5><p>​		位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>
<h3 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h3><p>​		标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。</p>
<h4 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h4><p>​		如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。</p>
<blockquote>
<p>C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1;<span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line">	string s2 = s1;<span class="comment">//s2是s1的副本</span></span><br><span class="line">	string s3 = <span class="string">&quot;hiya&quot;</span>;<span class="comment">//s3是该字符串字面值的副本</span></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>， <span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//s4的内容是cccccccccc</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230402211523431.png" alt="image-20230402211523431"></p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230402211722177.png" alt="image-20230402211722177"></p>
<h5 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a><strong>直接初始化和拷贝初始化</strong></h5><p>​		C++语言有几种不同的初始化方式，通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号<code>=</code>初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化(direct initialization)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果初始化的值有多个，使用直接初始化的方式。</span></span><br><span class="line">	string s5 = <span class="string">&quot;hiya&quot;</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line">	<span class="function">string <span class="title">s6</span><span class="params">(<span class="string">&quot;hiya&quot;</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line">	<span class="function">string <span class="title">s7</span><span class="params">(<span class="number">10</span>， <span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//直接初始化，s7的内容是cccccccccc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显式地创建一个（临时）对象用于拷贝：</span></span><br><span class="line">	string s8 = <span class="built_in">string</span>(<span class="number">10</span>， <span class="string">&#x27;c&#x27;</span>);<span class="comment">//拷贝初始化，s8的内容是cccccccccc</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//等价于下面的两条语句</span></span><br><span class="line">	<span class="function">string <span class="title">temp</span><span class="params">(<span class="number">10</span>， <span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">// temp的内容是cccccccccc</span></span><br><span class="line">	string s9 = temp;<span class="comment">//将temp拷贝给s8</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s5 &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; s6 &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; s7 &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; s8 &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; s9 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230402212545195.png" alt="image-20230402212545195"></p>
<h4 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h4><p><img src="/../../../../../../HEXO-1/source/_posts/C3/image-20230402212727166.png" alt="image-20230402212727166"></p>
<h5 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a><strong>读写string对象</strong></h5><p>​		可以使用IO操作符读写string对象，这段程序首先定义一个名为s的空string，然后将标准输入的内容读取到s中。在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;<span class="comment">//空字符串</span></span><br><span class="line">	cin &gt;&gt; s;<span class="comment">//将string对象读入s，遇到空白停止</span></span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;<span class="comment">//输出s</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230402213328380.png" alt="image-20230402213328380"></p>
<p>​		和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写在一起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1， s2;<span class="comment">//空字符串</span></span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;<span class="comment">//把第一个输入读到s1中，第二个输入读到s2中</span></span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl;<span class="comment">//输出两个string对象</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230402213728254.png" alt="image-20230402213728254"></p>
<h5 id="读取未知数量的string对象"><a href="#读取未知数量的string对象" class="headerlink" title="读取未知数量的string对象"></a><strong>读取未知数量的string对象</strong></h5><p>​		通过循环语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string word;<span class="comment">//空字符串</span></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; word)<span class="comment">//反复读取，直至到达文件末尾</span></span><br><span class="line">		cout &lt;&lt; word &lt;&lt; endl;<span class="comment">//逐个输出单词，每个单词后面紧跟一个换行</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230402214235031.png" alt="image-20230402214235031"></p>
<h5 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a><strong>使用getline读取一整行</strong></h5><p>​		有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的&gt;&gt;运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。</p>
<p>​		和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline的结果作为条件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string line;</span><br><span class="line">	<span class="comment">//每次读入一整行，直至到达文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin， line))</span><br><span class="line">		cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230402220359896.png" alt="image-20230402220359896"></p>
<blockquote>
<p>触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符</p>
</blockquote>
<h5 id="string的empty和size操作"><a href="#string的empty和size操作" class="headerlink" title="string的empty和size操作"></a><strong>string的empty和size操作</strong></h5><p>​		顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string line;</span><br><span class="line">	<span class="comment">//每次读入一整行，直至到达文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin， line))</span><br><span class="line">		<span class="keyword">if</span> (!line.<span class="built_in">empty</span>())</span><br><span class="line">			cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406113357277.png" alt="image-20230406113357277"></p>
<p>​		size函数返回string对象的长度（即string对象中字符的个数），可以使用size函数只输出长度超过80个字符的行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string line;</span><br><span class="line">	<span class="comment">//每次读入一整行，直至到达文件末尾</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin， line))</span><br><span class="line">		<span class="keyword">if</span> (line.<span class="built_in">size</span>() &gt; <span class="number">80</span>)</span><br><span class="line">			cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406113600536.png" alt="image-20230406113600536"></p>
<h5 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a><strong><code>string:size_type</code>类型</strong></h5><p>​		尽管我们不太清楚<code>string:size_type</code>类型的细节，但有一点是肯定的：它是一个无符号类型的值，而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是<code>string:size_type</code>类型的。</p>
<blockquote>
<p>如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。</p>
</blockquote>
<h5 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a><strong>比较string对象</strong></h5><p>​		string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string对象中的字符，并且对大小写敏感，也就是说，<code>在比较时同一个字母的大写形式和小写形式是不同的</code>。</p>
<p>​		相等性运算符(<code>==</code>和<code>!=</code>)分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全都相同。关系运算符<code>&lt;、&lt;=、&gt;、&gt;=</code>分别检验一个string对象是否小于、小于等于、大于、大于等于另外一个string对象。上述这些运算符都依照（大小写敏感的）字典顺序：</p>
<ol>
<li>如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的<code>字符相同</code>，就说较短string对象小于较长string对象。</li>
<li>如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中<code>第一对相异字符</code>比较的结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string phrase = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	string slang = <span class="string">&quot;hiya&quot;</span>;</span><br><span class="line">	cout &lt;&lt; (str == phrase) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (str != phrase) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (slang &gt;= phrase) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (slang &gt;= str) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (slang &gt; phrase) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (slang &gt; str) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406142358699.png" alt="image-20230406142358699"></p>
<h5 id="为string对象赋值"><a href="#为string对象赋值" class="headerlink" title="为string对象赋值"></a><strong>为string对象赋值</strong></h5><p>​		一般来说，在设计标准库类型时都力求在易用性上向内置类型看齐，因此大多数库类型都支持赋值操作。对于string类而言，允许把一个对象的值赋给另外一个对象.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">str1</span><span class="params">(<span class="number">10</span>， <span class="string">&#x27;c&#x27;</span>)</span>， str2</span>;<span class="comment">//st1的内容是cccccccccc;st2是一个空字符串</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	str1 = str2;<span class="comment">//赋值：用st2的副本替换st1的内容</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;<span class="comment">//此时st1和st2都是空字符串</span></span><br><span class="line">	cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406142904188.png" alt="image-20230406142904188"></p>
<h5 id="两个string对象相加"><a href="#两个string对象相加" class="headerlink" title="两个string对象相加"></a><strong>两个string对象相加</strong></h5><p>​		两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。也就是说，对string对象使用加法运算符(+)的结果是一个新的string对象，它所包含的字符由两部分组成：前半部分是加号左侧string对象所含的字符、后半部分是加号右侧string对象所含的字符。另外，复合赋值运算符(+&#x3D;)负责把右侧string对象的内容追加到左侧string对象的后面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str1=<span class="string">&quot;hello，&quot;</span>， str2=<span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">	string str3 = str1 + str2;<span class="comment">//s3的内容是hello，world\n</span></span><br><span class="line">	cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	str1 += str2;<span class="comment">//等价于s1=s1+s2</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406143236716.png" alt="image-20230406143236716"></p>
<h5 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a><strong>字面值和string对象相加</strong></h5><p>​		即使一种类型并非所需，我们也可以使用它，不过前提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;hello&quot;</span>， str2 = <span class="string">&quot;world&quot;</span>;<span class="comment">//在s1和s2中都没有标，点符号</span></span><br><span class="line">	string str3 = str1 + <span class="string">&quot;，&quot;</span> + str2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str3;</span><br><span class="line"></span><br><span class="line">	string str4 = str1 + <span class="string">&quot;，&quot;</span>;<span class="comment">//正确：把一个string对象和一个字面值相加</span></span><br><span class="line">	<span class="comment">//string str5 = &quot;hello&quot; + &quot;，&quot;;//错误：两个运算对象都不是string</span></span><br><span class="line">	cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str6 = str1 + <span class="string">&quot;，&quot;</span> + <span class="string">&quot;world&quot;</span>; <span class="comment">//正确：每个加法运算符都至少有一个运算对象是string</span></span><br><span class="line">	<span class="comment">//string str7 = &quot;hello&quot; + &quot;，&quot; + str2;//错误：不能把字面值直接相加</span></span><br><span class="line">	cout &lt;&lt; str6;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406144149428.png" alt="image-20230406144149428"></p>
<blockquote>
<p>str6可以理解为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str6 = (str1 + <span class="string">&quot;，&quot;</span>) + <span class="string">&quot;world&quot;</span>; <span class="comment">//子表达式s1 + &quot;，&quot;的结果是一个string对象，它同时作为第二个加法运算符的左侧运算对象</span></span><br><span class="line"><span class="comment">//等价为</span></span><br><span class="line">string tmp = str1 + <span class="string">&quot;，&quot;</span>;<span class="comment">//正确：加法运算符有一个运算对象是string</span></span><br><span class="line">str6 = tmp + <span class="string">&quot;world&quot;</span>;<span class="comment">//正确：加法运算符有一个运算对象是string</span></span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。</p>
</blockquote>
<h4 id="3-2-3-处理string对象中的字符"><a href="#3-2-3-处理string对象中的字符" class="headerlink" title="3.2.3 处理string对象中的字符"></a>3.2.3 处理string对象中的字符</h4><p>​	在cctype头文件中定义了一组标准库函数处理string对象中的字符，表3.3列出了主要的函数名及其含义。</p>
<p><img src="/../../../../../../HEXO-1/source/_posts/C3/image-20230406144856523.png" alt="image-20230406144856523"></p>
<p><code>cctype</code>头文件中定义了一组标准函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>isalnum(c)</code></td>
<td>当<code>c</code>是字母或数字时为真</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>当<code>c</code>是字母时为真</td>
</tr>
<tr>
<td><code>iscntrl(c)</code></td>
<td>当<code>c</code>是控制字符时为真</td>
</tr>
<tr>
<td><code>isdigit(c)</code></td>
<td>当<code>c</code>是数字时为真</td>
</tr>
<tr>
<td><code>isgraph(c)</code></td>
<td>当<code>c</code>不是空格但可以打印时为真</td>
</tr>
<tr>
<td><code>islower(c)</code></td>
<td>当<code>c</code>是小写字母时为真</td>
</tr>
<tr>
<td><code>isprint(c)</code></td>
<td>当<code>c</code>是可打印字符时为真</td>
</tr>
<tr>
<td><code>ispunct(c)</code></td>
<td>当<code>c</code>是标点符号时为真</td>
</tr>
<tr>
<td><code>isspace(c)</code></td>
<td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td>
</tr>
<tr>
<td><code>isupper(c)</code></td>
<td>当<code>c</code>是大写字母时为真</td>
</tr>
<tr>
<td><code>isxdigit(c)</code></td>
<td>当<code>c</code>是十六进制数字时为真</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td>
</tr>
</tbody></table>
<ul>
<li></li>
</ul>
<blockquote>
<p>建议：使用C++版本的C标准库头文件<br>		C+标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name，h，C+则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。<br>		因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。<br>		一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。</p>
</blockquote>
<h5 id="处理每个字符？使用基于范围的for语句"><a href="#处理每个字符？使用基于范围的for语句" class="headerlink" title="处理每个字符？使用基于范围的for语句"></a><strong>处理每个字符？使用基于范围的for语句</strong></h5><p>​		如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：范围for(range for)语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作。</p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230406145617111.png" alt="image-20230406145617111"></p>
<p>​		<code>expression</code>部分是一个对象，用于表示一个序列。<code>declaration</code>部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，<code>declaration</code>部分的变量会被初始化为<code>expression</code>部分的下一个元素值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每行输出str中的一个字符。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : str)<span class="comment">//对于str中的每个字符</span></span><br><span class="line">		cout &lt;&lt; c &lt;&lt; endl;<span class="comment">//输出当前字符，后面紧跟一个换行符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406145901998.png" alt="image-20230406145901998"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello，World!!!&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">decltype</span>(str.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>;<span class="comment">//punct_cnt的类型和s.size的返回类型一样</span></span><br><span class="line">	<span class="comment">//统计str中标点符号的数量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : str)<span class="comment">//对于str中的每个字符</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))<span class="comment">//如果该字符是标点符号</span></span><br><span class="line">			++punct_cnt;<span class="comment">//将标点符号的计数值加1</span></span><br><span class="line">	cout &lt;&lt; punct_cnt &lt;&lt; <span class="string">&quot;个标点在&quot;</span> &lt;&lt; str &lt;&lt; endl;<span class="comment">//输出当前字符，后面紧跟一个换行符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406160217332.png" alt="image-20230406160217332"></p>
<h5 id="使用范围for语句改变字符串中的字符"><a href="#使用范围for语句改变字符串中的字符" class="headerlink" title="使用范围for语句改变字符串中的字符"></a><strong>使用范围for语句改变字符串中的字符</strong></h5><p>​		如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello，World!!!&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//转换成大写形式</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : str)<span class="comment">//对于str中的每个字符(注意c是引用)</span></span><br><span class="line">		c = <span class="built_in">toupper</span>(c);<span class="comment">//C是一个引用，因此赋值语句将改变s中字符的值</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406160717453.png" alt="image-20230406160717453"></p>
<h5 id="只处理一部分字符？"><a href="#只处理一部分字符？" class="headerlink" title="只处理一部分字符？"></a><strong>只处理一部分字符？</strong></h5><p>​		要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。下标运算符([])接收的输入参数是string:size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。</p>
<p>​		string对象的下标从0计起。如果string对象s至少包含两个字符，则s[0]是第1个字符、s[1]是第2个字符、s[s.size()-1]是最后一个字符。下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。</p>
<p>​		在访问指定字符之前，首先检查s是否为空。其实不管什么时候只要对string对象使用了下标，都要确认在那个位置上确实有值。如果s为空，则s[0]的结果将是未定义的。只要字符串不是常量，就能为下标运算符返回的字符赋新值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some thing&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;<span class="comment">//确保s[0]的位置确实有字符</span></span><br><span class="line">		cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//输出s的第一个字符</span></span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">		s[<span class="number">0</span>] = <span class="built_in">toupper</span>(s[<span class="number">0</span>]);<span class="comment">//为s的第一个字符赋一个新值</span></span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406163105539.png" alt="image-20230406163105539"></p>
<blockquote>
<p>string对象的下标必须大于等于0而小于s，size()。</p>
<p><strong style="color:#ff0000;">使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问空string也会引发不可预知的结果。</strong></p>
</blockquote>
<h5 id="使用下标执行迭代"><a href="#使用下标执行迭代" class="headerlink" title="使用下标执行迭代"></a><strong>使用下标执行迭代</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some thing&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//依次处理S中的字符直至我们处理完全部字符或者遇到一个空白</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index]); ++index)</span><br><span class="line">		s[index] = <span class="built_in">toupper</span>(s[index]);<span class="comment">//将当前字符改成大写形式</span></span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406164729949.png" alt="image-20230406164729949"></p>
<blockquote>
<ol>
<li>C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。</li>
<li>使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的size()的值。一种简便易行的方法是，总是设下标的类型为string::size type，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于size()的值就可以了。</li>
<li>C++标准并不要求标准库检测下标是否合法。一旦使用了一个超出范围的下标，就会产生不可预知的结果。</li>
</ol>
</blockquote>
<h5 id="使用下标执行随机访问"><a href="#使用下标执行随机访问" class="headerlink" title="使用下标执行随机访问"></a><strong>使用下标执行随机访问</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> string hexdigits = <span class="string">&quot;0123456789ABCDEF&quot;</span>;<span class="comment">//可能的十六进制数字</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入0-15之间的数，并用空格隔开。当按下回车键（enter）结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">	string result;<span class="comment">//用于保存十六进制的字符串</span></span><br><span class="line">	string::size_type n;<span class="comment">//用于保存从输入流读取的数</span></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">		<span class="keyword">if</span> (n &lt; hexdigits.<span class="built_in">size</span>())<span class="comment">//忽略无效输入</span></span><br><span class="line">			result += hexdigits[n];<span class="comment">//得到对应的十六进制数字</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;16进制的结果为&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406170828826.png" alt="image-20230406170828826"></p>
<p>​		无论何时用到字符串的下标，都应该注意检查其合法性。在上面的程序中，下标是string::size_type类型，也就是无符号类型，所以n可以确保大于或等于0。在实际使用时，还需检查n是否小于hexdigits的长度。</p>
<h3 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h3><p>​			标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常被称作容器(container)。</p>
<p>​			C++语言既有类模板(class template)，也有函数模板，其中vector是一个类模板。模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化(instantiation)，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<p>​			对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。</p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230406171724404.png" alt="image-20230406171724404"></p>
<p>​			vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。</p>
<blockquote>
<ol>
<li>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如<code>vector&lt;int&gt;</code>。</li>
<li>某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如<code>vector&lt;vector&lt;int&gt; &gt;</code>。</li>
</ol>
</blockquote>
<h4 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h4><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>vector&lt;T&gt; v1</code></td>
<td><code>v1</code>是一个空<code>vector</code>，它潜在的元素是<code>T</code>类型的，执行默认初始化</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v2(v1)</code></td>
<td><code>v2</code>中包含有<code>v1</code>所有元素的副本</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v2 = v1</code></td>
<td>等价于<code>v2(v1)</code>，<code>v2</code>中包含<code>v1</code>所有元素的副本</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v3(n， val)</code></td>
<td><code>v3</code>包含了n个重复的元素，每个元素的值都是<code>val</code></td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v4(n)</code></td>
<td><code>v4</code>包含了n个重复地执行了值初始化的对象</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v5&#123;a， b， c...&#125;</code></td>
<td><code>v5</code>包含了初始值个数的元素，每个元素被赋予相应的初始值</td>
</tr>
<tr>
<td><code>vector&lt;T&gt; v5=&#123;a， b， c...&#125;</code></td>
<td>等价于<code>v5&#123;a， b， c...&#125;</code></td>
</tr>
</tbody></table>
<p>​		可以默认初始化vector对象，从而创建一个指定类型的空vector。</p>
<p>​		当然也可以在定义vector对象时指定元素的初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;string&gt; svec;<span class="comment">//默认初始化，svec不含任何元素</span></span><br><span class="line">	cout &lt;&lt; svec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ivec;	<span class="comment">//初始状态为空</span></span><br><span class="line">	cout &lt;&lt; svec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//在此处给ivec添加一些值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">		ivec.<span class="built_in">push_back</span>(i);<span class="comment">//依次把整数值放到ivec尾端</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : ivec)</span><br><span class="line">		cout &lt;&lt; i ;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>;<span class="comment">//把ivec的元素拷贝给ivec2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : ivec2)</span><br><span class="line">		cout &lt;&lt; i;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ivec3 = ivec;<span class="comment">//把ivec的元素拷贝给ivec3</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : ivec3)</span><br><span class="line">		cout &lt;&lt; i;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//vector&lt;string&gt; svec(ivec);//错误：svec的元素是string对象，不是int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406192028936.png" alt="image-20230406192028936"></p>
<h5 id="列表初始化vector对象"><a href="#列表初始化vector对象" class="headerlink" title="列表初始化vector对象"></a><strong>列表初始化vector对象</strong></h5><p>​		C++11新标准还提供了另外一种为vector对象的元素赋初值的方法，即列表初始化。</p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230406192905903.png" alt="image-20230406192905903"></p>
<blockquote>
<p>之前已经讲过，C++语言提供了几种不同的初始化方式。在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此：</p>
<ol>
<li>使用拷贝初始化时（即使用&#x3D;时），只能提供一个初始值；</li>
<li>如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。</li>
<li>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。</li>
</ol>
</blockquote>
<h5 id="创建指定数量的元素"><a href="#创建指定数量的元素" class="headerlink" title="创建指定数量的元素"></a><strong>创建指定数量的元素</strong></h5><p>​				还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象。</p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230406193756697.png" alt="image-20230406193756697"></p>
<h5 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a><strong>值初始化</strong></h5><p>​		通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会创建一个值初始化的(value-initialized)元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。如果vector对象的元素是内置类型，比如int，则元素初始值自动设为0。如果元素是某种类类型，比如string，则元素由类默认初始化。</p>
<p><img src="/2023/12/08/CPlusPlus03/image-20230406194825995.png" alt="image-20230406194825995"></p>
<blockquote>
<p>对这种初始化的方式有两个特殊限制：</p>
<ol>
<li>有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。</li>
<li>如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：</li>
</ol>
</blockquote>
<h5 id="列表初始值还是元素数量？"><a href="#列表初始值还是元素数量？" class="headerlink" title="列表初始值还是元素数量？"></a><strong>列表初始值还是元素数量？</strong></h5><p>​			在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。</p>
<p>​			如果用的是圆括号，可以说提供的值是用来构造(construct)vector对象的。</p>
<p>​			如果用的是花括号，可以表述成我们想列表初始化(list initialize)该vector对象。也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。</p>
<p>​			另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//v1有10个元素，每个的值都是0</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">10</span> &#125;;<span class="comment">//v2有1个元素，该元素的值是10</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;<span class="comment">//v3有10个元素，每个的值都是1</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4&#123; <span class="number">10</span>, <span class="number">1</span> &#125;;<span class="comment">//v4有2个元素，值分别是10和1</span></span><br><span class="line">	vector&lt;string&gt; v5&#123; <span class="string">&quot;hi&quot;</span> &#125;;<span class="comment">//列表初始化：v5有一个元素</span></span><br><span class="line">	<span class="comment">//vector&lt;string&gt; v6(&quot;hi&quot;);//错误：不能使用字符串字面值构建vector对象</span></span><br><span class="line">	vector&lt;string&gt; v7&#123; <span class="number">10</span> &#125;;<span class="comment">//v7有10个默认初始化的元素</span></span><br><span class="line">	vector&lt;string&gt; v8&#123; <span class="number">10</span>,<span class="string">&quot;hi&quot;</span> &#125;;<span class="comment">//v8有10个值为&quot;hi&quot;的元素</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1:&quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;v2:&quot;</span> &lt;&lt; v<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;v3:&quot;</span> &lt;&lt; v<span class="number">3.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;v4:&quot;</span> &lt;&lt; v<span class="number">4.</span><span class="built_in">size</span>() &lt;&lt; endl</span><br><span class="line">		&lt;&lt; <span class="string">&quot;v5:&quot;</span> &lt;&lt; v<span class="number">5.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;v7:&quot;</span> &lt;&lt; v<span class="number">7.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;v8:&quot;</span> &lt;&lt; v<span class="number">8.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406202309040.png" alt="image-20230406202309040"></p>
<h4 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2 向vector对象中添加元素"></a>3.3.2 向vector对象中添加元素</h4><p>​		对vector对象来说，直接初始化的方式适用于三种情况：初始值已知且数量较少、初始值是另一个vector对象的副本、所有元素的初始值都一样。然而更常见的情况是：创建一个vector对象时并不清楚实际所需的元素个数，元素的值也经常无法确定。还有些时候即使元素的初值已知，但如果这些值总量较大而各不相同，那么在创建vector对象的时候执行初始化操作也会显得过于烦琐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ivec;<span class="comment">//空vector对象</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">		ivec.<span class="built_in">push_back</span>(i);<span class="comment">//依次把整数值放到ivec尾端</span></span><br><span class="line">	<span class="comment">//循环结束后v2有100个元素，值从0到99</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : ivec)</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string word;</span><br><span class="line">	vector&lt;string&gt; svec;<span class="comment">//空vector对象</span></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; word) &#123;</span><br><span class="line">		svec.<span class="built_in">push_back</span>(word);<span class="comment">//把word添加到svec后面</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : svec)</span><br><span class="line">		cout &lt;&lt; i;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406203746192.png" alt="image-20230406203746192"></p>
<blockquote>
<p>​		C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实上如果这么做性能可能更差。只有-种例外情况，就是所有(l)元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。此外，vector还提供了方法，允许我们进一步提升动态添加元素的性能。</p>
<p>​		开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。特别是如果用惯了C或者Java,可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。</p>
</blockquote>
<h5 id="向vector对象添加元素蕴含的编程假定"><a href="#向vector对象添加元素蕴含的编程假定" class="headerlink" title="向vector对象添加元素蕴含的编程假定"></a><strong>向vector对象添加元素蕴含的编程假定</strong></h5><p>​		由于能高效便捷地向vector对象中添加元素，很多编程工作被极大简化了。然而，这种简便性也伴随着一些对编写程序更高的要求：其中一条就是必须要确保所写的循环正确无误，特别是在循环有可能改变vector对象容量的时候。<br>​		随着对vector的更多使用，我们还会逐渐了解到其他一些隐含的要求，其中一条是现在就要指出的：如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。</p>
<blockquote>
<p>范围for语句体内不应改变其所遍历序列的大小。</p>
</blockquote>
<h4 id="3-3-3-其他vector操作"><a href="#3-3-3-其他vector操作" class="headerlink" title="3.3.3 其他vector操作"></a>3.3.3 其他vector操作</h4><p><code>vector</code>支持的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>v.emtpy()</code></td>
<td>如果<code>v</code>不含有任何元素，返回真；否则返回假</td>
</tr>
<tr>
<td><code>v.size()</code></td>
<td>返回<code>v</code>中元素的个数</td>
</tr>
<tr>
<td><code>v.push_back(t)</code></td>
<td>向<code>v</code>的尾端添加一个值为<code>t</code>的元素</td>
</tr>
<tr>
<td><code>v[n]</code></td>
<td>返回<code>v</code>中第<code>n</code>个位置上元素的<strong>引用</strong></td>
</tr>
<tr>
<td><code>v1 = v2</code></td>
<td>用<code>v2</code>中的元素拷贝替换<code>v1</code>中的元素</td>
</tr>
<tr>
<td><code>v1 = &#123;a,b,c...&#125;</code></td>
<td>用列表中元素的拷贝替换<code>v1</code>中的元素</td>
</tr>
<tr>
<td><code>v1 == v2</code></td>
<td><code>v1</code>和<code>v2</code>相等当且仅当它们的元素数量相同且对应位置的元素值都相同</td>
</tr>
<tr>
<td><code>v1 != v2</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code></td>
<td>以字典顺序进行比较</td>
</tr>
</tbody></table>
<p>​		访问vector对象中元素的方法和访问string对象中字符的方法差不多，也是通过元素在vector对象中的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : v)<span class="comment">//对于v中的每个元素（注意：1是一个引用）</span></span><br><span class="line">		i *= i;<span class="comment">//求元素值的平方</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v)<span class="comment">//对于v中的每个元素</span></span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;<span class="comment">//输出该元素</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406210646084.png" alt="image-20230406210646084"></p>
<p>​		vector的empty和size两个成员与string的同名成员功能完全一致：empty检查vector对象是否包含元素然后返回一个布尔值：size则返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型。</p>
<blockquote>
<p>​		要使用size type,需首先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size type	<span class="comment">//正确</span></span><br><span class="line">vector::size type		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></blockquote>
<h5 id="计算vector内对象的索引"><a href="#计算vector内对象的索引" class="headerlink" title="计算vector内对象的索引"></a><strong>计算vector内对象的索引</strong></h5><p>​		使用下标运算符能获取到指定的元素。和string一样，vector对象的下标也是从0开始计起，下标的类型是相应的size_type类型。只要vector对象不是一个常量，就能向下标运算符返回的元素赋值。此外，也能通过计算得到vector内对象的索引，然后直接获取索引位置上的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以10分为一个分数段统计成绩的数量：0~9,10~19，...，90~99,100</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">score</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;<span class="comment">//11个分数段，全都初始化为0</span></span><br><span class="line">	<span class="type">unsigned</span> grade;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; grade)<span class="comment">//读取成绩</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)<span class="comment">//只处理有效的成绩</span></span><br><span class="line">			++score[grade / <span class="number">10</span>];<span class="comment">//将对应分数段的计数值加1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : score)</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406211703041.png" alt="image-20230406211703041"></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++score[grade / <span class="number">10</span>];<span class="comment">//将对应分数段的计数值加1</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ind = grade / <span class="number">10</span>;<span class="comment">//得到分数段索引</span></span><br><span class="line">score[ind] = score[ind] + <span class="number">1</span>;<span class="comment">//将计数值加1</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h5 id="不能用下标形式添加元素"><a href="#不能用下标形式添加元素" class="headerlink" title="不能用下标形式添加元素"></a><strong>不能用下标形式添加元素</strong></h5><p>​		空vector根本不包含任何元素，不能通过下标去访问任何元素！</p>
<blockquote>
<p>​		vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。</p>
<p>​		关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;ivec;<span class="comment">//空vector对象</span></span><br><span class="line">cout &lt;&lt; ivec[<span class="number">0</span>];<span class="comment">//错误：ivec不包含任何元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">ivec2</span>(<span class="number">10</span>);<span class="comment">//含有10个元素的vector对象</span></span><br><span class="line">cout &lt;&lt; ivec2[<span class="number">10</span>];<span class="comment">//错误：ivec2元素的合法索引是从0到9</span></span><br></pre></td></tr></table></figure>

<p>​		试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出(buffer overflow)指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。</p>
<pre><code>	&lt;strong style=&quot;color:#ff0000;&quot;&gt;确保下标合法的一种有效手段就是尽可能使用范围for语句。&lt;/strong&gt;
</code></pre>
</blockquote>
<h3 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h3><p>​		我们已经知道可以使用下标运算符来访问string对象的字符或vector对象的元素，还有另外一种更通用的机制也可以实现同样的目的，这就是迭代器(iterator)。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。严格来说，string对象不属于容器类型，但是string支持很多与容器类型类似的操作。vector支持下标运算符，这点和string一样：string支持迭代器，这也和vector是一样的。</p>
<p>​		类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置：其他所有情况都属于无效。</p>
<h4 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h4><p>​		和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由编译器决定b和e的类型</span></span><br><span class="line"><span class="comment">//b表示v的第一个元素，e表示v尾元素的下一位置</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();<span class="comment">//b和e的类型相同</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
</blockquote>
<h5 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a><strong>迭代器运算符</strong></h5><p>​		如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等；否则就说这两个迭代器不相等。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>*iter</code></td>
<td>返回迭代器<code>iter</code>所指向的<strong>元素的引用</strong></td>
</tr>
<tr>
<td><code>iter-&gt;mem</code></td>
<td>解引用<code>iter</code>并获取该元素的名为<code>mem</code>的成员，等价于<code>(*iter).mem</code></td>
</tr>
<tr>
<td><code>++iter</code></td>
<td>令<code>iter</code>指示容器中的下一个元素</td>
</tr>
<tr>
<td><code>--iter</code></td>
<td>令<code>iter</code>指示容器中的上一个元素</td>
</tr>
<tr>
<td><code>iter1 == iter2</code></td>
<td>判断两个迭代器是否相等</td>
</tr>
</tbody></table>
<p>​		和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some thing&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (s.<span class="built_in">begin</span>() != s.<span class="built_in">end</span>()) &#123;<span class="comment">//确保s非空</span></span><br><span class="line">		<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();<span class="comment">//it表示s的第一个字符</span></span><br><span class="line">		*it = <span class="built_in">toupper</span>(*it);<span class="comment">//将当前字符改成大写形式</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406214238002.png" alt="image-20230406214238002"></p>
<h5 id="将迭代器从一个元素移动到另外一个元素"><a href="#将迭代器从一个元素移动到另外一个元素" class="headerlink" title="将迭代器从一个元素移动到另外一个元素"></a><strong>将迭代器从一个元素移动到另外一个元素</strong></h5><p>​		迭代器的递增和整数的递增类似，整数的递增是在整数值上“加1”，迭代器的递增则是将迭代器“向前移动一个位置”。</p>
<blockquote>
<p>因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some thing&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//依次处理s的字符直至我们处理完全部字符或者遇到空白</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it)</span><br><span class="line">		*it = <span class="built_in">toupper</span>(*it);<span class="comment">//将当前字符改成大写形式</span></span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406214608930.png" alt="image-20230406214608930"></p>
<blockquote>
<p>关键概念：泛型编程<br>		原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用!&#x3D;而非&lt;进行判断有点儿奇怪，比如上面的这个程序以及85页的那个。C+程序员习惯性地使用!&#x3D;，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。<br>		之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了&#x3D;&#x3D;和!&#x3D;，但是它们中的大多数都没有定义&lt;运算符。因此，只要我们养成使用迭代器和!&#x3D;的习惯，就不用太在意用的到底是哪种容器类型。</p>
</blockquote>
<h5 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a><strong>迭代器类型</strong></h5><p>​		拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;<span class="comment">//it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">string::iterator it2;<span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;<span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;<span class="comment">//it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义的迭代器类型，还可能是指某个迭代器对象。<br>​		重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。<br>​		每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的套操作。</p>
</blockquote>
<h5 id="begin和end运算符"><a href="#begin和end运算符" class="headerlink" title="begin和end运算符"></a><strong>begin和end运算符</strong></h5><p>​		begin和end返回的具体类型由对象是否是常量决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();<span class="comment">//itl的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230406215955738.png" alt="image-20230406215955738"></p>
<p>​		有时，对象只需读操作而无须写操作，C++新标准引入了两个新函数，分别是cbegin和cend，类似于begin和end,上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();<span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

<h5 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a><strong>结合解引用和成员访问操作</strong></h5><p>​		解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure>

<p>​		注意，<code>(*it).empty()</code>中的圆括号必不可少，该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由it来执行，而非it解引用的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>();<span class="comment">//解引用it,然后调用结果对象的empty成员</span></span><br><span class="line">*it.<span class="built_in">empty</span>();<span class="comment">//错误：试图访问it的名为empty的成员，但it是个迭代器，没有empty成员</span></span><br></pre></td></tr></table></figure>

<p>​		为了简化上述表达式，C++语言定义了箭头运算符(-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it).mem</code>表达的意思相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; text;     </span><br><span class="line"></span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s))  </span><br><span class="line">		text.<span class="built_in">push_back</span>(s);   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;文本大小: &quot;</span> &lt;&lt; text.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//依次输出text的每一行直至遇到第一个空白行为止</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = text.<span class="built_in">cbegin</span>();</span><br><span class="line">		it != text.<span class="built_in">cend</span>() &amp;&amp; !(*it).<span class="built_in">empty</span>(); ++it)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//依次输出text的每一行直至遇到第一个空白行为止</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = text.<span class="built_in">cbegin</span>();</span><br><span class="line">		it != text.<span class="built_in">cend</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); ++it)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230407102359241.png" alt="image-20230407102359241"></p>
<h5 id="某些对vector对象的操作会使迭代器失效"><a href="#某些对vector对象的操作会使迭代器失效" class="headerlink" title="某些对vector对象的操作会使迭代器失效"></a><strong>某些对vector对象的操作会使迭代器失效</strong></h5><p>​			虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back,都会使该vector对象的迭代器失效。</p>
<blockquote>
<p>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p>
</blockquote>
<h4 id="3-4-2-迭代器运算"><a href="#3-4-2-迭代器运算" class="headerlink" title="3.4.2 迭代器运算"></a>3.4.2 迭代器运算</h4><p><code>vector</code>和<code>string</code>迭代器支持的运算：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>iter + n</code></td>
<td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter - n</code></td>
<td>迭代器减去一个整数仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td>
</tr>
<tr>
<td><code>iter1 += n</code></td>
<td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 -= n</code></td>
<td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td>
</tr>
<tr>
<td><code>iter1 - iter2</code></td>
<td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td>
</tr>
<tr>
<td><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td>
<td>迭代器的关系运算符，如果某迭代器</td>
</tr>
</tbody></table>
<h5 id="迭代器的算术运算"><a href="#迭代器的算术运算" class="headerlink" title="迭代器的算术运算"></a><strong>迭代器的算术运算</strong></h5><p>​		可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。执行这样的操作时，结果迭代器或者指示原vector对象（或string对象)内的一个元素，或者指示原vector对象（或string对象）尾元素的下一位置。</p>
<p>​		对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。</p>
<p>​		只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type,因为这个距离可正可负，所以difference_type是带符号类型的。</p>
<h5 id="使用迭代器运算"><a href="#使用迭代器运算" class="headerlink" title="使用迭代器运算"></a><strong>使用迭代器运算</strong></h5><p>​		使用迭代器运算的一个经典算法是二分搜索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;	<span class="comment">//v必须是有序的</span></span><br><span class="line">	<span class="type">int</span> sought = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> beg = v.<span class="built_in">begin</span>(), end = v.<span class="built_in">end</span>();	<span class="comment">//beg和end表示我们搜索的范围</span></span><br><span class="line">	<span class="keyword">auto</span> mid = v.<span class="built_in">begin</span>() + (end - beg) / <span class="number">2</span>;	<span class="comment">//初始状态下的中间点</span></span><br><span class="line">	<span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sought &lt; *mid)	<span class="comment">//我们要找的元素在前半部分吗？</span></span><br><span class="line">			end = mid;		<span class="comment">//如果是，调整搜索范围使得忽略掉后半部分</span></span><br><span class="line">		<span class="keyword">else</span>				<span class="comment">//我们要找的元素在后半部分</span></span><br><span class="line">			beg = mid + <span class="number">1</span>;	<span class="comment">//在mid之后寻找</span></span><br><span class="line">		mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sought == *mid)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230407193004185.png" alt="image-20230407193004185"></p>
<h3 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h3><p>​		数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。<strong>因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</strong></p>
<blockquote>
<p>如果不请楚元素的确切个数，请使用vector。</p>
</blockquote>
<h4 id="3-5-1-定义和初始化内置数组"><a href="#3-5-1-定义和初始化内置数组" class="headerlink" title="3.5.1 定义和初始化内置数组"></a>3.5.1 定义和初始化内置数组</h4><p>​		数组是一种复合类型。数组的声明形如a[d],其中a是数组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>;<span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;<span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];<span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span>* parr[sz];<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line">string bad[cnt];<span class="comment">//错误：cnt不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];<span class="comment">//当get size是constexpr时正确；否则错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p>
</blockquote>
<h5 id="显示初始化数组元素"><a href="#显示初始化数组元素" class="headerlink" title="显示初始化数组元素"></a><strong>显示初始化数组元素</strong></h5><p>​		可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来：相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> a1[sz] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//含有3个元素的数组，元素值分别是0,1,2</span></span><br><span class="line">	<span class="type">int</span> a2[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//维度是3的数组</span></span><br><span class="line">	<span class="type">int</span> a3[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//等价于a3[]=&#123;0,1,2,0,0)</span></span><br><span class="line">	string a4[<span class="number">3</span>] = &#123; <span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span> &#125;;<span class="comment">// 等价于a4[] = &#123; &quot;hi&quot;,&quot;bye&quot;,&quot;&quot;)</span></span><br><span class="line">	<span class="comment">//int a5[2] = &#123; 0,1,2 &#125;;	//错误：初始值过多</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230407204001903.png" alt="image-20230407204001903"></p>
<h5 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a><strong>字符数组的特殊性</strong></h5><p>​		字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> a1[] = &#123; <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span> &#125;;<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line">	<span class="type">char</span> a2[] = &#123; <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span> ,<span class="string">&#x27;\0&#x27;</span> &#125;;<span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line">	<span class="type">char</span> a3[] = <span class="string">&quot;c++&quot;</span>;<span class="comment">//自动添加表示字符串结束的空字符</span></span><br><span class="line">	<span class="comment">//const char a4[6] = &quot;Daniel&quot;;//错误：没有空间可存放空字符！</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230407211951889.png" alt="image-20230407211951889"></p>
<h5 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a><strong>不允许拷贝和赋值</strong></h5><p>​		不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//含有3个整数的数组</span></span><br><span class="line"><span class="type">int</span> a2[] = a;<span class="comment">//错误：不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a1;<span class="comment">//错误：不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>​		一些编译器支持数组的赋值，这就是所谓的编译器扩展(compiler extension)。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。</p>
</blockquote>
<h5 id="理解复杂的数组声明"><a href="#理解复杂的数组声明" class="headerlink" title="理解复杂的数组声明"></a><strong>理解复杂的数组声明</strong></h5><p>​		和vector一样，数组能存放大多数类型的对象。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptrs[<span class="number">10</span>];	<span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span>&amp; refs[<span class="number">10</span>];	<span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;	<span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span>(&amp;arrRef)[<span class="number">10</span>] = arr		<span class="comment">//arrRef引用一个含有I0个整数的数组</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p>
</blockquote>
<h4 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h4><p>​		与标准库类型vector和string一样，数组的元素也能使用范围for语句或下标运算符来访问。<br>​		在使用数组下标的时候，通常将其定义为<code>size_t</code>类型。<code>size_t</code>是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在<code>cstddef</code>头文件中定义了<code>size_t</code>类型，这个文件是C标准库stddef.h头文件的C++语言版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以10分为一个分数段统计成绩的数量：0~9,10~19，...，90~99,100</span></span><br><span class="line">	<span class="type">unsigned</span> scores[<span class="number">11</span>] = &#123;&#125;;<span class="comment">//11个分数段，全都初始化为0</span></span><br><span class="line">	<span class="type">unsigned</span> grade;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; grade)<span class="comment">//读取成绩</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)<span class="comment">//只处理有效的成绩</span></span><br><span class="line">			++scores[grade / <span class="number">10</span>];<span class="comment">//将对应分数段的计数值加1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; scores[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230407215530409.png" alt="image-20230407215530409"></p>
<h5 id="检查下标的值"><a href="#检查下标的值" class="headerlink" title="检查下标的值"></a><strong>检查下标的值</strong></h5><p>​		与vector和string一样，数组的下标是否在合理范围之内由程序员负责检查，所谓合理就是说下标应该大于等于0而且小于数组的大小。要想防止数组下标越界，除了小心谨慎注意细节以及对代码进行彻底的测试之外，没有其他好办法。对于一个程序来说，即使顺利通过编译并执行，也不能肯定它不包含此类致命的错误。</p>
<blockquote>
<p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p>
</blockquote>
<h4 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h4><p>​		在C++语言中，指针和数组有非常紧密的联系。就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。<br>​		通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string nums[] = &#123; <span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span> &#125;;<span class="comment">//数组的元素是string对象</span></span><br><span class="line">	string* p = &amp;nums[<span class="number">0</span>];<span class="comment">//p指向nums的第一个元素</span></span><br><span class="line">	cout &lt;&lt; nums &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230407221118641.png" alt="image-20230407221118641"></p>
<blockquote>
<p>在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。</p>
</blockquote>
<p>​		由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。但当使用decltype关键字时上述转换不会发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;<span class="comment">//ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;<span class="comment">//ia2是一个整型指针，指向ia的第一个元素,类似于auto ia2(&amp;ia[0]);</span></span><br><span class="line">ia2 = <span class="number">42</span>;<span class="comment">//错误：ia2是一个指针，不能用int值给指针赋值</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3= &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;<span class="comment">//ia3是一个含有10个整数的数组</span></span><br><span class="line">ia3 = p;<span class="comment">//错误：不能用整型指针给数组赋值</span></span><br><span class="line">ia3[<span class="number">4</span>] = i;<span class="comment">//正确：把i的值赋给ia3的一个元素</span></span><br></pre></td></tr></table></figure>

<h5 id="指针迭代器"><a href="#指针迭代器" class="headerlink" title="指针迭代器"></a><strong>指针迭代器</strong></h5><p>​		指向数组元素的指针拥有更多功能。vector和string的迭代器支持的运算，数组的指针全都支持。就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素的指针：不过获取尾后指针就要用到数组的另外一个特殊性质了。我们可以设法获取数组尾元素之后的那个并不存在的元素的地址。就像尾后迭代器一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行解引用或递增的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; </span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; </span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* p = arr;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//p指向arr的第一个元素</span></span><br><span class="line">	++p;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//p指向arr[1]</span></span><br><span class="line">	<span class="type">int</span>* e = &amp;arr[<span class="number">10</span>];</span><br><span class="line">	cout &lt;&lt; *e &lt;&lt; endl;<span class="comment">//指向arr尾元素的下一位置的指针</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span>* b = arr; b != e; ++b)</span><br><span class="line">		cout &lt;&lt; *b &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出arr的元素</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408201634486.png" alt="image-20230408201634486"></p>
<h5 id="标准函数begin和end"><a href="#标准函数begin和end" class="headerlink" title="标准函数begin和end"></a><strong>标准函数begin和end</strong></h5><p>​		尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全，c++新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;<span class="comment">//ia是一个含有10个整数的数组</span></span><br><span class="line">	<span class="type">int</span>* beg = <span class="built_in">begin</span>(ia);<span class="comment">//指向ia首元素的指针</span></span><br><span class="line">	cout &lt;&lt; *beg &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span>* last = <span class="built_in">end</span>(ia);<span class="comment">//指向arr尾元素的下一位置的指针</span></span><br><span class="line">	cout &lt;&lt; *last &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//寻找第一个负值元素，如果已经检查完全部元素则结束循环</span></span><br><span class="line">	<span class="keyword">while</span> (beg != last &amp;&amp; *beg &gt;= <span class="number">0</span>)</span><br><span class="line">		++beg;</span><br><span class="line">	<span class="keyword">if</span> (beg == last)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有负数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; *beg &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408202555712.png" alt="image-20230408202555712"></p>
<blockquote>
<p>一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。</p>
</blockquote>
<h5 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a><strong>指针运算</strong></h5><p>​		指向数组元素的指针可以执行几乎所有迭代器运算。这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。</p>
<p>​		给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置。给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。</p>
<p>​		和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。两个指针相减的结果的类型是一种名为<code>ptrdiff_t</code>的标准库类型，和<code>size_t</code>一样，<code>ptrdiff_t</code>也是一种定义在<code>cstddef</code>头文件中的机器相关的类型。因为差值可能为负值，所以<code>ptrdiff_t</code>是一种带符号类型。</p>
<p>​		只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="number">5</span>; <span class="type">int</span> arr[sz] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* ip = arr; 	cout &lt;&lt; <span class="string">&quot;*ip\t&quot;</span> &lt;&lt; *ip &lt;&lt; endl;<span class="comment">//等价于int*ip=&amp;arr[0]</span></span><br><span class="line">	<span class="type">int</span>* ip2 = ip + <span class="number">4</span>;	cout &lt;&lt; <span class="string">&quot;*ip2\t&quot;</span> &lt;&lt; *ip2 &lt;&lt; endl;<span class="comment">//ip2指向arr的尾元素arr[4]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置</span></span><br><span class="line">	<span class="type">int</span>* p = arr + sz;	cout &lt;&lt; <span class="string">&quot;*p\t&quot;</span> &lt;&lt; *p &lt;&lt; endl;<span class="comment">//使用警告：不要解引用！</span></span><br><span class="line">	<span class="type">int</span>* p2 = arr + <span class="number">10</span>;	cout &lt;&lt; <span class="string">&quot;*p2\t&quot;</span> &lt;&lt; *p2 &lt;&lt; endl;<span class="comment">//错误：arr只有5个元素，p2的值未定义</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> n = <span class="built_in">end</span>(arr) - <span class="built_in">begin</span>(arr);	cout &lt;&lt; <span class="string">&quot;n\t&quot;</span> &lt;&lt; n &lt;&lt; endl;<span class="comment">//n的值是5，也就是arr中元素的数量</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* b = arr, * e = arr + sz;</span><br><span class="line">	<span class="keyword">while</span> (b &lt; e) &#123;<span class="comment">//遍历数组中的元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*b\t&quot;</span> &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">		++b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, si = <span class="number">42</span>; <span class="type">int</span>* ipi = &amp;i, * iei = &amp;si;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ipi &lt; iei\t&quot;</span> &lt;&lt; (ipi &lt; iei) &lt;&lt; endl;<span class="comment">//未定义的：p和e无关，因此比较毫无意义！</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408205435027.png" alt="image-20230408205435027"></p>
<h5 id="解引用和指针运算的交互"><a href="#解引用和指针运算的交互" class="headerlink" title="解引用和指针运算的交互"></a><strong>解引用和指针运算的交互</strong></h5><p>​		指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span> &#125;;<span class="comment">//含有5个整数的数组</span></span><br><span class="line">	<span class="type">int</span> last = *(ia + <span class="number">4</span>);<span class="comment">//正确：把last初始化成8，也就是ia[4]的值。ia前进4个元素后的新地址。</span></span><br><span class="line">	cout &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> last1 = *ia + <span class="number">4</span>;<span class="comment">//正确：last1=4等价于ia[0]+4。此时先解引用ia,然后给解引用的结果再加上4。</span></span><br><span class="line">	cout &lt;&lt; last1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408210553225.png" alt="image-20230408210553225"></p>
<h5 id="下标和指针"><a href="#下标和指针" class="headerlink" title="下标和指针"></a><strong>下标和指针</strong></h5><p>​		在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。一个典型的例子是当对数组使用下标运算符时，编译器会自动执行上述转换操作。只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span> &#125;;<span class="comment">//含有5个整数的数组</span></span><br><span class="line">	<span class="type">int</span> i = ia[<span class="number">2</span>]; cout &lt;&lt; <span class="string">&quot;i\t&quot;</span> &lt;&lt; i &lt;&lt; endl;<span class="comment">//ia转换成指向数组首元素的指针，ia[2]得到(ia+2)所指的元素。</span></span><br><span class="line">	<span class="type">int</span>* p = ia; cout &lt;&lt; <span class="string">&quot;* p\t&quot;</span> &lt;&lt; *p &lt;&lt; endl;<span class="comment">//p指向ia的首元素</span></span><br><span class="line">	i = *(p + <span class="number">2</span>); cout &lt;&lt; <span class="string">&quot;i\t&quot;</span> &lt;&lt; i &lt;&lt; endl;<span class="comment">//等价于i=ia[2]</span></span><br><span class="line">	<span class="type">int</span>* p1 = &amp;ia[<span class="number">2</span>]; cout &lt;&lt; <span class="string">&quot;* p1\t&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;<span class="comment">//p指向索引为2的元素</span></span><br><span class="line">	<span class="type">int</span> j = p1[<span class="number">1</span>]; cout &lt;&lt; <span class="string">&quot;j\t&quot;</span> &lt;&lt; j &lt;&lt; endl;<span class="comment">//p[1]等价于*(p+1),就是ia[3]表示的那个元素</span></span><br><span class="line">	<span class="type">int</span> k = p1[<span class="number">-2</span>]; cout &lt;&lt; <span class="string">&quot;k \t&quot;</span> &lt;&lt; k &lt;&lt; endl;<span class="comment">//p[-2]是ia[0]表示的那个元素</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408211534704.png" alt="image-20230408211534704"></p>
<p>​		虽然标准库类型string和vector也能执行下标运算，但是数组与它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求，上面的最后一个例子很好地说明了这一点。内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。</p>
<blockquote>
<p>​		内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p>
</blockquote>
<h4 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h4><blockquote>
<p>​		尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。</p>
</blockquote>
<p>​		字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的C风格字符串(C-style character string)。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束(lterminated)。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符(‘\0’)。般利用指针来操作这些字符串。</p>
<h5 id="C标准库String函数"><a href="#C标准库String函数" class="headerlink" title="C标准库String函数"></a><strong>C标准库String函数</strong></h5><p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen(p)</code></td>
<td>返回<code>p</code>的长度，空字符不计算在内</td>
</tr>
<tr>
<td><code>strcmp(p1, p2)</code></td>
<td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td>
</tr>
<tr>
<td><code>strcat(p1, p2)</code></td>
<td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td>
</tr>
<tr>
<td><code>strcpy(p1, p2)</code></td>
<td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td>
</tr>
</tbody></table>
<p><strong>传入此类函数的指针必须指向以空字符作为结束的数组</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ca[] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;<span class="comment">//不以空字符结束</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; endl;<span class="comment">//严重错误：ca没有以空字符结束，故长度错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408215140911.png" alt="image-20230408215140911"></p>
<h5 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a><strong>比较字符串</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">	cout &lt;&lt; (s1 &lt; s2) &lt;&lt; endl;<span class="comment">//false:s2小于s1</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> ca1[] = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> ca2[] = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">	cout &lt;&lt; (ca1 &lt; ca2) &lt;&lt; endl;<span class="comment">//未定义的：试图比较两个无关地址</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">strcmp</span>(ca1, ca2) &lt;&lt; endl;<span class="comment">//和两个string对象的比较s1&lt;s2效果一样</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408215619416.png" alt="image-20230408215619416"></p>
<p>​		如果把标准库运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身。要想比较两个C风格字符串需要调用<code>strcmp</code>函数，此时比较的就不再是指针了。如果两个字符串相等，<code>strcmp</code>返回0：如果前面的字符串较大，返回正值；如果后面的字符串较大，返回负值。</p>
<h5 id="目标字符串的大小由调用者指定"><a href="#目标字符串的大小由调用者指定" class="headerlink" title="目标字符串的大小由调用者指定"></a><strong>目标字符串的大小由调用者指定</strong></h5><p>​		连接或拷贝C风格字符串也与标准库string对象的同类操作差别很大。一个潜在的问题是，我们在估算所需的空间时不容易估准，而且所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码到处都是，程序员根本没法照顾周全。这类代码充满了风险而且经常导致严重的安全泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">	string largeStr = s1 + <span class="string">&quot; &quot;</span>+s2;<span class="comment">//将largeStr初始化成s1、一个空格和s2的连接</span></span><br><span class="line">	cout &lt;&lt; largeStr &lt;&lt; endl;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> ca1[] = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> ca2[] = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ca3[<span class="number">38</span>]=<span class="string">&quot;&quot;</span>;<span class="comment">//如果我们计算错了ca3的大小将引发严重错误</span></span><br><span class="line">	<span class="built_in">strcpy</span>(ca3, ca1);<span class="comment">//把ca1拷贝给ca3</span></span><br><span class="line">	cout &lt;&lt; ca3 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">strcat</span>(ca3, <span class="string">&quot; &quot;</span>);<span class="comment">//在ca3的末尾加上一个空格</span></span><br><span class="line">	cout &lt;&lt; ca3 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">strcat</span>(ca3, ca2);<span class="comment">//把ca2连接到largeStr后面</span></span><br><span class="line">	cout &lt;&lt; ca3 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230408220846684.png" alt="image-20230408220846684"></p>
<blockquote>
<p>对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。</p>
</blockquote>
<h4 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h4><p>​		很多C++程序在标准库出现之前就已经写成了，它们肯定没用到string和vector类型。而且，有一些C++程序实际上是与C语言或其他语言的接口程序，当然也无法使用C++标准库。因此，现代的C++程序不得不与那些充满了数组和（或）C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。</p>
<h5 id="混用string对象和C风格字符串"><a href="#混用string对象和C风格字符串" class="headerlink" title="混用string对象和C风格字符串"></a>混用string对象和C风格字符串</h5><p>​		c++允许使用字符串字面值来初始化string对象，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：</p>
<ul>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。</li>
<li>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）：在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。</li>
</ul>
<p>​		上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。为了完成用string对象直接初始化指向字符的指针，string专门提供了一个名为<code>c_str</code>的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello world&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;s\t&quot;</span> &lt;&lt; s &lt;&lt; endl;<span class="comment">//s的内容是Hello world</span></span><br><span class="line">	<span class="comment">//char* str = s;//错误：不能用string对象初始化char*</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = s.<span class="built_in">c_str</span>();<span class="comment">//正确</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*str\t&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str\t&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230409150340246.png" alt="image-20230409150340246"></p>
<p>​		顾名思义，<code>c_str</code>函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char*,从而确保我们不会改变字符数组的内容。我们无法保证<code>c_str</code>函数返回的数组一直有效，事实上，如果后续的操作改变了S的值就可能让之前返回的数组失去效用。</p>
<blockquote>
<p>如果执行完<code>c_str</code>()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p>
</blockquote>
<h5 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h5><p>​		c++不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了。用于初始化vector对象的值也可能仅是数组的一部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> int_arr[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;<span class="comment">//ivec有6个元素，分别是int_arr中对应元素的副本</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i :ivec)</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr + <span class="number">1</span>, int_arr + <span class="number">4</span>)</span></span>;<span class="comment">//拷贝三个元素：int_arr[1]、int_arr[2]、int_arr[3]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : subVec)</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230409150952795.png" alt="image-20230409150952795"></p>
<blockquote>
<p>​		使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误，特别是声明指针时的语法错误。<br>​		现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string,避免使用C风格的基于数组的字符串。</p>
</blockquote>
<h3 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h3><p>​		多维数组其实是数组的数组。当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小。对于二维数组来说，常把第一个维度称作行，第二个维度称作列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line">	<span class="comment">//大小为10的数组，它的每个元素都是大小为20的数组，这些数组的元素是含有30个整数的数组</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//将所有元素初始化为0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230409153751276.png" alt="image-20230409153751276"></p>
<h5 id="多维数组的初始化"><a href="#多维数组的初始化" class="headerlink" title="多维数组的初始化"></a>多维数组的初始化</h5><p>​		允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来。其中内层嵌套着的花括号并非必需的。类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内，其他未列出的元素执行默认值初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="comment">//三个元素，每个元素都是大小为4的数组</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="comment">//第1行的初始值</span></span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,<span class="comment">//第2行的初始值</span></span><br><span class="line">		&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125; <span class="comment">//第3行的初始值</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> ia1[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span> &#125;;<span class="comment">//没有标识每行的花括号，与之前的初始化语句是等价的</span></span><br><span class="line">	<span class="type">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125; &#125;;<span class="comment">//显式地初始化每行的首元素</span></span><br><span class="line">	<span class="type">int</span> ia3[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span> &#125;;<span class="comment">//显式地初始化第1行，其他元素执行值初始化</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../../../../../HEXO-1/source/_posts/C3/image-20230409160529378.png" alt="image-20230409160529378"></p>
<h5 id="多维数组的下标引用"><a href="#多维数组的下标引用" class="headerlink" title="多维数组的下标引用"></a>多维数组的下标引用</h5><p>​		可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="comment">//三个元素，每个元素都是大小为4的数组</span></span><br><span class="line">			&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="comment">//第1行的初始值</span></span><br><span class="line">			&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,<span class="comment">//第2行的初始值</span></span><br><span class="line">			&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125; <span class="comment">//第3行的初始值</span></span><br><span class="line">	&#125;;</span><br><span class="line">	ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//用arr的首元素为ia最后一行的最后一个元素赋值</span></span><br><span class="line">	cout &lt;&lt; ia[<span class="number">2</span>][<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">int</span>(&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];<span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br><span class="line">	cout &lt;&lt; row &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> ia1[rowCnt][colCnt];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rowCnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; colCnt; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ia1[i][j] = i * colCnt + j;</span><br><span class="line">			cout &lt;&lt; ia1[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230409165610781.png" alt="image-20230409165610781"></p>
<h5 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h5><p>​		因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。如果row不是引用类型，编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的row的类型就是<code>int*</code>,显然内层的循环就不合法了，编译器将试图在一个<code>int*</code>内遍历，这显然和程序的初衷相去甚远。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> ia[rowCnt][colCnt];</span><br><span class="line">	<span class="type">size_t</span> cnt = <span class="number">0</span>, rowc = <span class="number">0</span>, colc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : ia)<span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; col : row)<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">		&#123;</span><br><span class="line">			col = cnt;<span class="comment">//将下一个值赋给该元素</span></span><br><span class="line">			cout &lt;&lt; ia[rowc][colc] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			++cnt;<span class="comment">//将cnt加1</span></span><br><span class="line">			colc++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		rowc++;</span><br><span class="line">		colc = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230409170919534.png" alt="image-20230409170919534"></p>
<blockquote>
<p>​		要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</p>
</blockquote>
<h5 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a><strong>指针和多维数组</strong></h5><p>​		当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。通过使用auto或者decltype就能尽可能地避免在数组前面加上一个指针类型了。</p>
<blockquote>
<p>​		定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;, &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125; &#125;;<span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>, d = <span class="number">40</span>;</span><br><span class="line">	<span class="type">int</span>* ip[<span class="number">4</span>] = &#123; &amp;a, &amp;b, &amp;c, &amp;d &#125;;<span class="comment">//整型指针的数组</span></span><br><span class="line">	cout &lt;&lt; *ip[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ip[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ip[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *ip[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">int</span>(*p)[<span class="number">4</span>] = ia;<span class="comment">//P指向含有4个整数的数组</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;(*p)[4]\t&quot;</span> &lt;&lt; (*p) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">&quot;ia\t&quot;</span> &lt;&lt; ia &lt;&lt; endl;</span><br><span class="line">	p = &amp;ia[<span class="number">2</span>];<span class="comment">//p指向ia的尾元素</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p\t&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="string">&quot;&amp;ia[2]\t&quot;</span> &lt;&lt; &amp;ia[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)<span class="comment">//输出ia中每个元素的值，每个内层数组各占一行，p指向含有4个整数的数组</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)<span class="comment">//q指向4个整数数组的首元素，也就是说，q指向一个整数</span></span><br><span class="line">			cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p != <span class="built_in">end</span>(ia); ++p)	<span class="comment">//p指向ia的第一个数组</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); ++q)<span class="comment">//q指向内层数组的首元素</span></span><br><span class="line">			cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//输出q所指的整数值</span></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230409202351389.png" alt="image-20230409202351389"></p>
<h5 id="类型别名简化多维数组的指针"><a href="#类型别名简化多维数组的指针" class="headerlink" title="类型别名简化多维数组的指针"></a><strong>类型别名简化多维数组的指针</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; </span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;, &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125; &#125;;<span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line">	<span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];<span class="comment">//新标准下类型别名的声明</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">int</span> int_array[<span class="number">4</span>];<span class="comment">//等价的typedef声明</span></span><br><span class="line">	<span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line">	<span class="keyword">for</span> (int_array* p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span>* q = *p; q != *p + <span class="number">4</span>; q++)</span><br><span class="line">			cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus03/image-20230409203808984-1744098506793-61.png" alt="image-20230409203808984"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://alsl521.github.io">kyl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://alsl521.github.io/2023/12/08/CPlusPlus03/">https://alsl521.github.io/2023/12/08/CPlusPlus03/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://alsl521.github.io" target="_blank">kyl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">C++基础入门</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/12/08/CPlusPlus02/" title="C++基础入门第二章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++基础入门第二章</div></div><div class="info-2"><div class="info-item-1">第二章 变量和基本类型2.1基本内置类型​		C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。 2.1.1算数类型​		算数类型分为两类：整型(integral type，包括字符和布尔类型在内)和浮点型。    类型 含义 最小尺寸    bool 布尔类型 未定义   char 字符 8bits   wchar_t 宽字符 16bits   char16_t Unicode字符 16bits   char32_t Unicode字符 32bits   short 短整型 16bits   int 整型 16bits (在32位机器中是32bits)   long 长整型 32bits   long long 长整型 64bits （是在C++11中新定义的）   float 单精度浮点数 6位有效数字   double 双精度浮点数 10位有效数字   long...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus04/" title="C++基础入门第四章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++基础入门第四章</div></div><div class="info-2"><div class="info-item-1">第四章 表达式​		表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式(expression),其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。 4.1 基础4.1.1 基本概念​		C+定义了一元运算符(unary operator)和二元运算符(binary operator)。作用于一个运算对象的运算符是一元运算符，如取地址符&amp;和解引用符*：作用于两个运算对象的运算符是二元运算符，如相等运算符=和乘法运算符*。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。一些符号既能作为一元运算符也能作为二元运算符。 组合运算符和运算对象​		对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级(precedence)、结合律(associativity)以及运算对象的求值顺序(order of evaluation)。 12345678910#include...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/12/08/CPlusPlus02/" title="C++基础入门第二章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第二章</div></div><div class="info-2"><div class="info-item-1">第二章 变量和基本类型2.1基本内置类型​		C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。 2.1.1算数类型​		算数类型分为两类：整型(integral type，包括字符和布尔类型在内)和浮点型。    类型 含义 最小尺寸    bool 布尔类型 未定义   char 字符 8bits   wchar_t 宽字符 16bits   char16_t Unicode字符 16bits   char32_t Unicode字符 32bits   short 短整型 16bits   int 整型 16bits (在32位机器中是32bits)   long 长整型 32bits   long long 长整型 64bits （是在C++11中新定义的）   float 单精度浮点数 6位有效数字   double 双精度浮点数 10位有效数字   long...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus04/" title="C++基础入门第四章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第四章</div></div><div class="info-2"><div class="info-item-1">第四章 表达式​		表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式(expression),其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。 4.1 基础4.1.1 基本概念​		C+定义了一元运算符(unary operator)和二元运算符(binary operator)。作用于一个运算对象的运算符是一元运算符，如取地址符&amp;和解引用符*：作用于两个运算对象的运算符是二元运算符，如相等运算符=和乘法运算符*。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。一些符号既能作为一元运算符也能作为二元运算符。 组合运算符和运算对象​		对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级(precedence)、结合律(associativity)以及运算对象的求值顺序(order of evaluation)。 12345678910#include...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus01/" title="C++基础入门第一章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第一章</div></div><div class="info-2"><div class="info-item-1">第一章 开始1.1	编写一个简单的C++程序12345#include &lt;iostream&gt;int main()&#123;    return 0;&#125;  ​		一个函数的定义包含四部分：返回类型(return type)、函数名(function name)、一个括号包围的形参列表(parameter list ，允许为空)以及函数体(function body)。虽然main函数在某种程度上比较特殊，但其定义与其他函数是一样的。 ​		在本例中，main的形参列表是空的(()中什么也没有)。 ​		main函数的返回类型必须为int，即整数类型。int类型是一种内置类型(built-intype)，即语言自身定义的类型。 ​		函数定义的最后一部分是函数体，它是一个以左花括号(curly brace)开始，以右花括号结束的语句块(block of...</div></div></div></a><a class="pagination-related" href="/2023/12/11/Linux1/" title="黑马程序员--Linux安装各类软件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-11</div><div class="info-item-2">黑马程序员--Linux安装各类软件</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/02/01/SSM-2/" title="Java学习-SSM-2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">Java学习-SSM-2</div></div><div class="info-2"><div class="info-item-1">核心容器前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的核心容器。 这里所说的核心容器，大家可以把它简单的理解为ApplicationContext，前面虽然已经用到过，但是并没有系统的学习，接下来咱们从以下几个问题入手来学习下容器的相关知识:  如何创建容器? 创建好容器后，如何从容器中获取bean对象? 容器类的层次结构是什么? BeanFactory是什么?  环境准备在学习和解决上述问题之前，先来准备下案例环境:  创建一个Maven项目  pom.xml添加Spring的依赖 1234567&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;   ...</div></div></div></a><a class="pagination-related" href="/2024/02/14/Little-knowledge-of-Java-5/" title="Java学习（五）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-14</div><div class="info-item-2">Java学习（五）</div></div><div class="info-2"><div class="info-item-1">处理错误为了尽量避免错误的发生，至少应该做到以下几点：  向用户通知错误； 保存所有的工作； 允许用户妥善地退出程序。  假设在一个Java...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kyl</div><div class="author-info-description">用于记录平时学习的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/alsl521" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:852970167@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">第三章 字符串、向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4using%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">3.1 命名空间using声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E5%90%8D%E5%AD%97%E9%83%BD%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84using%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">每个名字都需要独立的using声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8D%E5%BA%94%E5%8C%85%E5%90%ABusing%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">头文件不应包含using声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 标准库类型string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96string%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2.1 定义和初始化string对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">直接初始化和拷贝初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2.2 string对象上的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99string%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">读写string对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%9C%AA%E7%9F%A5%E6%95%B0%E9%87%8F%E7%9A%84string%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">读取未知数量的string对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8getline%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">使用getline读取一整行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E7%9A%84empty%E5%92%8Csize%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">string的empty和size操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string-size-type%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">string:size_type类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83string%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">比较string对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BAstring%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">为string对象赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.2.2.8.</span> <span class="toc-text">两个string对象相加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8Cstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.2.2.9.</span> <span class="toc-text">字面值和string对象相加</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2.3 处理string对象中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">处理每个字符？使用基于范围的for语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E6%94%B9%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">使用范围for语句改变字符串中的字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E5%A4%84%E7%90%86%E4%B8%80%E9%83%A8%E5%88%86%E5%AD%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">只处理一部分字符？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E6%89%A7%E8%A1%8C%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">使用下标执行迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E6%89%A7%E8%A1%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">使用下标执行随机访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector"><span class="toc-number">1.3.</span> <span class="toc-text">3.3 标准库类型vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.3.1 定义和初始化vector对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">列表初始化vector对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">创建指定数量的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">值初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%80%BC%E8%BF%98%E6%98%AF%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">列表初始值还是元素数量？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%90%91vector%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.3.2 向vector对象中添加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91vector%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%95%B4%E5%90%AB%E7%9A%84%E7%BC%96%E7%A8%8B%E5%81%87%E5%AE%9A"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">向vector对象添加元素蕴含的编程假定</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%85%B6%E4%BB%96vector%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3.3 其他vector操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97vector%E5%86%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">计算vector内对象的索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%8B%E6%A0%87%E5%BD%A2%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">不能用下标形式添加元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.</span> <span class="toc-text">3.4 迭代器介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.4.1 使用迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">迭代器运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">将迭代器从一个元素移动到另外一个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">迭代器类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#begin%E5%92%8Cend%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">begin和end运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">结合解引用和成员访问操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E5%AF%B9vector%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">某些对vector对象的操作会使迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.4.2 迭代器运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">迭代器的算术运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">使用迭代器运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.</span> <span class="toc-text">3.5 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">3.5.1 定义和初始化内置数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">显示初始化数组元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">字符数组的特殊性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">不允许拷贝和赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">理解复杂的数组声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.2.</span> <span class="toc-text">3.5.2 访问数组元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%B8%8B%E6%A0%87%E7%9A%84%E5%80%BC"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">检查下标的值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.5.3 指针和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">指针迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0begin%E5%92%8Cend"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">标准函数begin和end</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">解引用和指针运算的交互</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">下标和指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.4.</span> <span class="toc-text">3.5.4 C风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E6%A0%87%E5%87%86%E5%BA%93String%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">C标准库String函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%B1%E8%B0%83%E7%94%A8%E8%80%85%E6%8C%87%E5%AE%9A"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">目标字符串的大小由调用者指定</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-5-%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.5.</span> <span class="toc-text">3.5.5 与旧代码的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E7%94%A8string%E5%AF%B9%E8%B1%A1%E5%92%8CC%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">混用string对象和C风格字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">使用数组初始化vector对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">3.6 多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">多维数组的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">多维数组的下标引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">使用范围for语句处理多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">指针和多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">类型别名简化多维数组的指针</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/05/NET-ASP-17/" title="NET-ASP-17-实战-Day04">NET-ASP-17-实战-Day04</a><time datetime="2025-06-05T01:57:52.000Z" title="发表于 2025-06-05 09:57:52">2025-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/28/NET-ASP-16/" title="NET-ASP-16-实战-Day03">NET-ASP-16-实战-Day03</a><time datetime="2025-05-28T02:57:23.000Z" title="发表于 2025-05-28 10:57:23">2025-05-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/26/NET-ASP-15/" title="ASP.NET学习记录-15-实战-Day02">ASP.NET学习记录-15-实战-Day02</a><time datetime="2025-05-26T11:25:36.000Z" title="发表于 2025-05-26 19:25:36">2025-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/NET-ASP-14/" title="ASP.NET学习记录-14-实战-Day01">ASP.NET学习记录-14-实战-Day01</a><time datetime="2025-05-25T12:02:17.000Z" title="发表于 2025-05-25 20:02:17">2025-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/21/NET-ASP-13/" title="ASP.NET学习记录-13-实践2-数据库进阶">ASP.NET学习记录-13-实践2-数据库进阶</a><time datetime="2025-04-21T08:39:19.000Z" title="发表于 2025-04-21 16:39:19">2025-04-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By kyl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>