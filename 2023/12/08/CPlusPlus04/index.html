<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++基础入门第四章 | kyl的博客</title><meta name="author" content="kyl"><meta name="copyright" content="kyl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础入门第四章">
<meta property="og:url" content="https://alsl521.github.io/2023/12/08/CPlusPlus04/index.html">
<meta property="og:site_name" content="kyl的博客">
<meta property="og:description" content="C++表达式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4">
<meta property="article:published_time" content="2023-12-08T10:53:00.000Z">
<meta property="article:modified_time" content="2025-04-08T07:49:08.228Z">
<meta property="article:author" content="kyl">
<meta property="article:tag" content="C++基础入门">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++基础入门第四章",
  "url": "https://alsl521.github.io/2023/12/08/CPlusPlus04/",
  "image": "https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4",
  "datePublished": "2023-12-08T10:53:00.000Z",
  "dateModified": "2025-04-08T07:49:08.228Z",
  "author": [
    {
      "@type": "Person",
      "name": "kyl",
      "url": "https://alsl521.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://alsl521.github.io/2023/12/08/CPlusPlus04/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++基础入门第四章',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">kyl的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C++基础入门第四章</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++基础入门第四章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-08T10:53:00.000Z" title="发表于 2023-12-08 18:53:00">2023-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-08T07:49:08.228Z" title="更新于 2025-04-08 15:49:08">2025-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h2><p>​		表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式(expression),其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。</p>
<h3 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h3><h4 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h4><p>​		C+定义了一元运算符(unary operator)和二元运算符(binary operator)。作用于一个运算对象的运算符是一元运算符，如取地址符<code>&amp;</code>和解引用符<code>*</code>：作用于两个运算<br>对象的运算符是二元运算符，如相等运算符<code>=</code>和乘法运算符<code>*</code>。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。一些符号既能作为一元运算符也能作为二元运算符。</p>
<h5 id="组合运算符和运算对象"><a href="#组合运算符和运算对象" class="headerlink" title="组合运算符和运算对象"></a>组合运算符和运算对象</h5><p>​		对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级(precedence)、结合律(associativity)以及运算对象的求值顺序(order of evaluation)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">5</span> + <span class="number">10</span> * <span class="number">20</span> / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230409205446658.png" alt="image-20230409205446658"></p>
<h5 id="运算对象转换"><a href="#运算对象转换" class="headerlink" title="运算对象转换"></a>运算对象转换</h5><p>​		在表达式求值的过程中，运算对象常常由一种类型转换成另外一种类型。类型转换的规则虽然有点复杂，但大多数都合乎情理、容易理解。让人稍微有点意外的是，小整数类型（如bool、char、short等）通常会被提升(promoted)成较大的整数类型，主要是int。</p>
<h5 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h5><p>​		C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载运算符(overloadedoperator)。</p>
<p>​		我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的：但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p>
<h5 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h5><p>​		C++的表达式要不然是右值,要不然就是左值。这两个名词是从C语言继承过来的，原本是为了帮助记忆：左值可以位于赋值语句的左侧，右值则不能。</p>
<p>​		在C++中，一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。<strong style="color:#ff0000;">可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容）：当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</strong></p>
<p>​		不同的运算符对运算对象的要求各不相同，有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到左值结果、有的得到右值结果。一个重要的原则是在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。到目前为止，已经有几种我们熟悉的运算符是要用到左值的。</p>
<ul>
<li>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。</li>
</ul>
<p>​		使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。另一方面，因为取地址运算符生成右值，结果是一个指向整型指针的指针。</p>
<h4 id="4-1-2-优先级与结合律"><a href="#4-1-2-优先级与结合律" class="headerlink" title="4.1.2 优先级与结合律"></a>4.1.2 优先级与结合律</h4><p>​		<code>复合表达式</code>(compound expression)是指含有两个或多个运算符的表达式。求复合表达式的值需要首先将运算符和运算对象合理地组合在一起，优先级与结合律决定了运算对象组合的方式。也就是说，它们决定了表达式中每个运算符对应的运算对象来自表达式的哪一部分。表达式中的括号无视上述规则，程序员可以使用括号将表达式的某个局部括起来使其得到优先运算。</p>
<p>​		一般来说，表达式最终的值依赖于其子表达式的组合方式。高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组合在一起。如果优先级相同，则其组合规则由结合律确定。算术运算符满足左结合律，意味着如果运算符的优先级相同，将按照从左向右的顺序组合运算对象。</p>
<h5 id="括号无视优先级与结合律"><a href="#括号无视优先级与结合律" class="headerlink" title="括号无视优先级与结合律"></a>括号无视优先级与结合律</h5><p>​		括号无视普通的组合规则，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; (<span class="number">6</span> + <span class="number">3</span>) * (<span class="number">4</span> / <span class="number">2</span> + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    std::cout &lt;&lt; ((<span class="number">6</span> + <span class="number">3</span>) * <span class="number">4</span>) / <span class="number">2</span> + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">6</span> + <span class="number">3</span> * <span class="number">4</span> / (<span class="number">2</span> + <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230409210645286.png" alt="image-20230409210645286"></p>
<h5 id="优先级与结合律有何影响"><a href="#优先级与结合律有何影响" class="headerlink" title="优先级与结合律有何影响"></a>优先级与结合律有何影响</h5><p>​		优先级会影响程序的正确性。结合律对表达式产生影响的一个典型示例是输入输出运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="type">int</span> last = *(ia + <span class="number">4</span>);<span class="comment">//把last初始化成8，也就是ia[4]的值</span></span><br><span class="line">    std::cout &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">    last = *ia + <span class="number">4</span>;<span class="comment">//last=4,等价于ia[0]+4</span></span><br><span class="line">    std::cout &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230409210949379.png" alt="image-20230409210949379"></p>
<h4 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a>4.1.3 求值顺序</h4><p>​		有4种运算符明确规定了运算对象的求值顺序。第一种是逻辑与<code>(&amp;&amp;)</code>运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。另外三种分别是逻辑或<code>(||)</code>运算符、条件<code>(?:)</code>运算符和逗号<code>(,)</code>运算符。</p>
<h5 id="求值顺序、优先级、结合律"><a href="#求值顺序、优先级、结合律" class="headerlink" title="求值顺序、优先级、结合律"></a>求值顺序、优先级、结合律</h5><p>​		运算对象的求值顺序与优先级和结合律无关。</p>
<blockquote>
<p>​		以下两条经验准则对书写复合表达式有益。</p>
<ol>
<li><p>拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。</p>
</li>
<li><p>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</p>
<p>第2条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。</p>
</li>
</ol>
</blockquote>
<h3 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h3><p><img src="/2023/12/08/CPlusPlus04/image-20230409212024780.png" alt="image-20230409212024780"></p>
<p>​		按照运算符的优先级将其分组。一元运算符的优先级最高，接下来是乘法和除法，优先级最低的是加法和减法。优先级高的运算符比优先级低的运算符组合得更紧密。上面的所有运算符都满足左结合律，意味着当优先级相同时按照从左向右的顺序进行组合。除非另做特殊说明，算术运算符都能作用于任意算术类型以及任意能转换为算术类型的类型。算术运算符的运算对象和求值结果都是右值。一元正号运算符、加法运算符和减法运算符都能作用于指针。</p>
<p>​		对大多数运算符来说，布尔类型的运算对象将被提升为int类型。</p>
<blockquote>
<p><code>提示：溢出和其他算术运算异常</code></p>
<p>​		算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是0的情况；另外一部分则源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时就会产生溢出。很多系统在编译和运行时都不报溢出错误，像其他未定义的行为一样，溢出的结果是不可预知的。该值发生了“环绕(wrapped around”,符号位本来是0，由于溢出被改成了1，于是结果变成一个负值。在别的系统中也许会有其他结果，程序的行为可能不同甚至直接崩遗。</p>
</blockquote>
<p>​		当作用于算术类型的对象时，算术运算符<code>+、-、*、/</code>的含义分别是加法、减法、乘法和除法。整数相除结果还是整数，也就是说，如果商含有小数部分，直接弃除。</p>
<p>​		在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++11新标准则规定商一律向0取整（即直接切除小数部分）。</p>
<p>​		根据取余运算的定义，如果m和n是整数且n非0，则表达式(m&#x2F;n)*n+m号n的求值结果与m相等。隐含的意思是，如果m%n不等于0，则它的符号和m相同。C+语言的早<br>期版本允许m号n的符号匹配n的符号，而且商向负无穷一侧取整，这一方式在新标准中已经被禁止使用了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> k = -i;<span class="comment">//k是-1024</span></span><br><span class="line">    std::cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    <span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="type">bool</span> b2 = -b;<span class="comment">//b2是true!布尔值不应该参与运算</span></span><br><span class="line">    std::cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> ival1 = <span class="number">21</span> / <span class="number">6</span>;<span class="comment">//ival1是3，结果进行了删节，余数被抛弃掉了</span></span><br><span class="line">    std::cout &lt;&lt; ival1 &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> ival2 = <span class="number">21</span> / <span class="number">7</span>;<span class="comment">//ival2是3，没有余数，结果是整数值</span></span><br><span class="line">    std::cout &lt;&lt; ival2 &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; ival1 &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; dval &lt;&lt; endl;</span><br><span class="line">    ival % <span class="number">12</span>;<span class="comment">//正确：结果是6</span></span><br><span class="line">    std::cout &lt;&lt; ival % <span class="number">12</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//ival% dval;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230409213433949.png" alt="image-20230409213433949"></p>
<h3 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h3><p>​		关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象（算术类型或指针类型)表示假，否则表示真。对于这两类运算符来说，运算对象和求值结果都是右值。</p>
<p><img src="/2023/12/08/CPlusPlus04/image-20230409213720152.png" alt="image-20230409213720152"></p>
<h5 id="逻辑与和逻辑或运算符"><a href="#逻辑与和逻辑或运算符" class="headerlink" title="逻辑与和逻辑或运算符"></a>逻辑与和逻辑或运算符</h5><p>​		对于逻辑与运算符<code>&amp;&amp;</code>来说，当且仅当两个运算对象都为真时结果为真；对于逻辑或运算符<code>||</code>来说，只要两个运算对象中的一个为真结果就为真。逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为短路求值。</p>
<ul>
<li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值</li>
<li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string word;</span><br><span class="line">    vector&lt;string&gt; text;<span class="comment">//空vector对象</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; word) &#123;</span><br><span class="line">        text.<span class="built_in">push_back</span>(word);<span class="comment">//把word添加到svec后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s是对常量的引用；元素既没有被拷贝也不会被改变</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp;s:text)<span class="comment">//对于text的每个元素，输出当前元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; s;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()||s[s.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)<span class="comment">//遇到空字符串或者以句号结束的字符串进行换行</span></span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//否则用空格隔开</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230409223230450.png" alt="image-20230409223230450"></p>
<h5 id="逻辑非运算符"><a href="#逻辑非运算符" class="headerlink" title="逻辑非运算符"></a>逻辑非运算符</h5><p>​		逻辑非运算符<code>!</code>将运算对象的值取反后返回。</p>
<h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><p>​		顾名思义，关系运算符比较运算对象的大小关系并返回布尔值。关系运算符都满足左结合律。因为关系运算符的求值结果是布尔值，所以将几个关系运算符连写在一起会产生意想不到的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">1</span>, k = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; (i &lt; j &lt; k) &lt;&lt; endl;<span class="comment">//拿i&lt;j的布尔值结果和k比较,若k大于1则为真！</span></span><br><span class="line">    cout &lt;&lt; (i &lt; j&amp;&amp; j &lt; k) &lt;&lt; endl;<span class="comment">//正确：当i小于j并且j小于k时条件为真</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230411203820386.png" alt="image-20230411203820386"></p>
<h5 id="相等性测试与布尔字面值"><a href="#相等性测试与布尔字面值" class="headerlink" title="相等性测试与布尔字面值"></a>相等性测试与布尔字面值</h5><p>​		如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为if语句的条件：</p>
<blockquote>
<p>进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。</p>
</blockquote>
<h3 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//赋值运算符的左侧运算对象必须是一个可修改的左值。</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>,k = <span class="number">0</span>;<span class="comment">//初始化而非赋值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci = i;<span class="comment">//初始化而非赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//则下面的赋值语句都是非法的：</span></span><br><span class="line">    <span class="number">1024</span> = k; <span class="comment">//错误：字面值是右值</span></span><br><span class="line">    i + j = k;<span class="comment">//错误：算术表达式是右值</span></span><br><span class="line">    ci = k;<span class="comment">//错误：C4是常量（不可修改的)左值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值运算的结果是它的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。</span></span><br><span class="line">    <span class="comment">//如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</span></span><br><span class="line">    k = <span class="number">0</span>;<span class="comment">//结果：类型是int,值是0</span></span><br><span class="line">    k = <span class="number">3.1415926</span>;<span class="comment">//结果：类型是int,值是3</span></span><br><span class="line"></span><br><span class="line">    k = &#123; <span class="number">3.14</span> &#125;;<span class="comment">//错误：窄化转换</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vi;<span class="comment">//初始为空</span></span><br><span class="line">    vi = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;<span class="comment">//vi现在含有10个元素了，值从0到9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230411210659368.png" alt="image-20230411210659368"></p>
<h5 id="赋值运算满足右结合律"><a href="#赋值运算满足右结合律" class="headerlink" title="赋值运算满足右结合律"></a>赋值运算满足右结合律</h5><p>​		赋值运算符满足右结合律，这一点与其他二元运算符不太一样。对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ival, jval;</span><br><span class="line">    ival = jval = <span class="number">0</span>;<span class="comment">//正确：都被赋值为0</span></span><br><span class="line">    cout &lt;&lt; ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; jval &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    <span class="type">int</span>* pval;<span class="comment">//ival的类型是int;pval是指向int的指针</span></span><br><span class="line">    <span class="comment">//ival = pval = 0;//错误：不能把指针的值赋给int</span></span><br><span class="line"></span><br><span class="line">    string s1, s2;</span><br><span class="line">    s1 = s2 = <span class="string">&quot;OK&quot;</span>;<span class="comment">//字符串字面值&quot;OK&quot;转换成string对象</span></span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230411213802946.png" alt="image-20230411213802946"></p>
<h5 id="赋值运算优先级较低"><a href="#赋值运算优先级较低" class="headerlink" title="赋值运算优先级较低"></a>赋值运算优先级较低</h5><p>​		赋值语句经常会出现在条件当中。因为赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的原意。</p>
<blockquote>
<p>因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。</p>
</blockquote>
<h5 id="切勿混淆相等运算符和赋值运算符"><a href="#切勿混淆相等运算符和赋值运算符" class="headerlink" title="切勿混淆相等运算符和赋值运算符"></a>切勿混淆相等运算符和赋值运算符</h5><p>​		相等运算符<code>==</code></p>
<p>​		赋值运算符<code>=</code></p>
<h5 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h5><p>​		我们经常需要对对象施以某种运算，然后把计算的结果再赋给该对象。</p>
<p><img src="/2023/12/08/CPlusPlus04/image-20230411214821325.png" alt="image-20230411214821325"></p>
<p>​		每种运算符都有相应的复合赋值形式</p>
<table>
<thead>
<tr>
<th><code>+=</code></th>
<th><code>-=</code></th>
<th><code>*=</code></th>
<th><code>/=</code></th>
<th><code>%=</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;&lt;=</code></td>
<td><code>&gt;&gt;=</code></td>
<td><code>&amp;=</code></td>
<td><code>^=</code></td>
<td>&#96;</td>
</tr>
</tbody></table>
<h3 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h3><p>​		递增运算符(++)和递减运算符(-一)为对象的加1和减1操作提供了一种简洁的书写形式。这两个运算符还可应用于迭代器，因为很多迭代器本身不支持算术运算，所以此时递增和递减运算符除了书写简洁外还是必须的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    j = ++i;<span class="comment">//j=1,i=1:前置版本得到递增之后的值</span></span><br><span class="line">    cout &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    j = i++;<span class="comment">//j=1,i=2:后置版本得到递增之前的值</span></span><br><span class="line">    cout &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    <span class="comment">//前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230411215336917.png" alt="image-20230411215336917"></p>
<blockquote>
<p>​		有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因非常简单：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。<br>​		对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。</p>
</blockquote>
<h5 id="在一条语句中混用解引用和递增运算符"><a href="#在一条语句中混用解引用和递增运算符" class="headerlink" title="在一条语句中混用解引用和递增运算符"></a>在一条语句中混用解引用和递增运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//输出元素直至遇到第一个负值为止</span></span><br><span class="line">    <span class="keyword">while</span> (pbeg != v.<span class="built_in">end</span>() &amp;&amp; *pbeg &gt;= <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; *pbeg++ &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出当前值并将pbeg向前移动一个元素</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412195416017.png" alt="image-20230412195416017"></p>
<blockquote>
<p>​		形如<code>*pbeg+</code>的表达式一开始可能不太容易理解，但其实这是一种被广泛使用的、有效的写法。当对这种形式熟悉之后，书写<br><code>		cout &lt;*iter++&lt;endl;</code><br>​		要比书写下面的等价语句更简洁、也更少出错<br><code>		cout &lt;*iter &lt;endl;</code><br><code>		++iter;</code><br>​		不断研究这样的例子直到对它们的含义一目了然。大多数C++程序追求简洁、摒弃冗长，因此C++程序员应该习惯于这种写法。而且，一旦熟练掌握了这种写法后，程序出错的可能性也会降低。</p>
</blockquote>
<h5 id="运算对象可按任意顺序求值"><a href="#运算对象可按任意顺序求值" class="headerlink" title="运算对象可按任意顺序求值"></a>运算对象可按任意顺序求值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some thing&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it)</span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it);<span class="comment">//将当前字符玫成大写形式</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412200046780.png" alt="image-20230412200046780"></p>
<blockquote>
<p>用一个看似等价的while循环进行代替：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该循环的行为是未定义的！</span></span><br><span class="line"><span class="keyword">while</span> (beg != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*beg))</span><br><span class="line">  *beg = <span class="built_in">toupper</span>(*beg++);<span class="comment">//错误：该赋值语句未定义</span></span><br></pre></td></tr></table></figure>

<p>编译器可能按照下面的任意一种思路处理该表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*beg = <span class="built_in">toupper</span>(*beg);<span class="comment">//如果先求左侧的值</span></span><br><span class="line">*(beg + <span class="number">1</span>) = <span class="built_in">toupper</span>(*beg);<span class="comment">//如果先求右侧的值</span></span><br></pre></td></tr></table></figure></blockquote>
<h3 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h3><p>​		点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类对象的一个成员：箭头运算符与点运算符有关，表达式<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;a string&quot;</span>, * p = &amp;s1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> n = s<span class="number">1.</span><span class="built_in">size</span>();<span class="comment">//运行string对象s1的size成员</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    n = (*p).<span class="built_in">size</span>();<span class="comment">//运行p所指对象的size成员</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    n = p-&gt;<span class="built_in">size</span>();<span class="comment">//等价于(*p).size()</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412201338007.png" alt="image-20230412201338007"></p>
<p>​		因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没加括号，代码的含义就大不相同了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行p的size成员，然后解引用size的结果</span></span><br><span class="line">*p.<span class="built_in">size</span>();<span class="comment">//错误：p是一个指针，它没有名为size的成员</span></span><br></pre></td></tr></table></figure>

<p>​		箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值：反之，如果成员所属的对象是右值，那么结果是右值。</p>
<h3 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h3><p>​		条件运算符<code>?:</code>允许我们把简单的<code>if-else</code>逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond?expr1:expr2</span><br></pre></td></tr></table></figure>

<p>​		条件运算符的执行过程是：首先求<code>cond</code>的值，如果条件为真对<code>expr1</code>求值并返回该值，否则对<code>exp2</code>求值并返回该值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string finalgrade = (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​		当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值：否则运算的结果是右值。</p>
<h5 id="嵌套条件运算符"><a href="#嵌套条件运算符" class="headerlink" title="嵌套条件运算符"></a>嵌套条件运算符</h5><p>​		允许在条件运算符的内部嵌套另外一个条件运算符。也就是说，条件表达式可以作为另外一个条件运算符的<code>cond</code>或<code>expr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>随着条件运算嵌套层数的增加，代码的可读性急剧下降。因此，条件运算的嵌套最好别超过两到三层</p>
</blockquote>
<h5 id="在输出表达式中使用条件运算符"><a href="#在输出表达式中使用条件运算符" class="headerlink" title="在输出表达式中使用条件运算符"></a>在输出表达式中使用条件运算符</h5><p>​		条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ((grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>); <span class="comment">// 输出pass或者fail</span></span><br><span class="line">cout &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;<span class="comment">//输出1或者0！</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">cout &lt;&lt; (grade &lt; <span class="number">60</span>);<span class="comment">//输出1或者0</span></span><br><span class="line">cout ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;<span class="comment">//根据cout的值是true还是false产生对应的字面值</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;<span class="comment">//错误：试图比较cout和60</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">cout &lt;&lt; grade;<span class="comment">//小于运算符的优先级低于移位运算符，所以先输出grade</span></span><br><span class="line">cout &lt; <span class="number">60</span> ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;<span class="comment">//然后比较cout和60！</span></span><br></pre></td></tr></table></figure>

<h3 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h3><p>​		位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能。</p>
<p><img src="/2023/12/08/CPlusPlus04/image-20230412210435420.png" alt="image-20230412210435420"></p>
<blockquote>
<p>关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。</p>
</blockquote>
<h5 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h5><p>​		之前在处理输入和输出操作时，我们已经使用过标准O库定义的&lt;&lt;运算符和&gt;&gt;运算符的重载版本。这两种运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的(可能还进行了提升)左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移(&lt;&lt;)或者向右移(&gt;&gt;)，移出边界之外的位就被舍弃掉了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits = <span class="number">0233</span>;<span class="comment">//0233是八进制的字面值</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412213054024.png" alt="image-20230412213054024"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits &lt;&lt; <span class="number">8</span>;<span class="comment">//bits提升成int类型，然后向左移动8位</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412213105446.png" alt="image-20230412213105446"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits &lt;&lt; <span class="number">31</span>;<span class="comment">//向左移动31位，左边超出边界的位丢弃掉了</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412213112720.png" alt="image-20230412213112720"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits &gt;&gt; <span class="number">3</span>;<span class="comment">//向右移动3位，最右边的3位丢弃掉了</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412213132280.png" alt="image-20230412213132280"></p>
<p>​		左移运算符(&lt;&lt;)在右侧插入值为0的二进制位。右移运算符(&gt;&gt;)的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位：如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。</p>
<h5 id="位求反运算符"><a href="#位求反运算符" class="headerlink" title="位求反运算符"></a>位求反运算符</h5><p>​		位求反运算符<code>~</code>将运算对象逐位求反后生成一个新值，将1置为0、将0置为1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits = <span class="number">0227</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412213308691.png" alt="image-20230412213308691"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~bits;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412213320938.png" alt="image-20230412213320938"></p>
<p>​		char类型的运算对象首先提升成int类型，提升时运算对象原来的位保持不变，往高位(high order position)添加0即可。因此在本例中，首先将bits提升成int类型，增加24个高位0，随后将提升后的值逐位求反。</p>
<h5 id="位与、位或、位异或运算符"><a href="#位与、位或、位异或运算符" class="headerlink" title="位与、位或、位异或运算符"></a>位与、位或、位异或运算符</h5><p>​		与<code>&amp;</code>、或<code>!</code>、异或<code>^</code>运算符在两个运算对象上逐位执行相应的逻辑操作.</p>
<p><img src="/2023/12/08/CPlusPlus04/image-20230412213520249.png" alt="image-20230412213520249"></p>
<p>​		对于位与运算符<code>&amp;</code>来说，如果两个运算对象的对应位置都是1则运算结果中该位为1，否则为0。对于位或运算符<code>|</code>来说，如果两个运算对象的对应位置至少有一个为1则运算结果中该位为1，否则为0。对于位异或运算符<code>^</code>来说，如果两个运算对象的对应位置有且只有一个为1则运算结果中该位为1，否则为0。</p>
<blockquote>
<p>​		有一种常见的错误是把位运算符和逻辑运算符搞混了，比如位与<code>&amp;</code>和逻辑与<code>&amp;&amp;</code>人位或<code>|</code>和逻辑或<code>||</code>、位求反<code>~</code>和逻辑非<code>!</code>。</p>
</blockquote>
<h5 id="使用位运算符"><a href="#使用位运算符" class="headerlink" title="使用位运算符"></a>使用位运算符</h5><p>不常用</p>
<h5 id="移位运算符（又叫IO运算符）满足左结合律"><a href="#移位运算符（又叫IO运算符）满足左结合律" class="headerlink" title="移位运算符（又叫IO运算符）满足左结合律"></a>移位运算符（又叫IO运算符）满足左结合律</h5><p>​		尽管很多程序员从未直接用过位运算符，但是几乎所有人都用过它们的重载版本来进行IO操作。重载运算符的优先级和结合律都与它的内置版本一样，因此即使程序员用不到移位运算符的内置含义，也仍然有必要理解其优先级和结合律。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector; <span class="keyword">using</span> std::begin;</span><br><span class="line"><span class="keyword">using</span> std::end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">42</span> + <span class="number">10</span> &lt;&lt; endl;<span class="comment">//正确：+的优先级更高，因此输出求和结果</span></span><br><span class="line">    cout &lt;&lt; (<span class="number">10</span> &lt; <span class="number">42</span>);<span class="comment">//正确：括号使运算对象按照我们的期望组合在一起，输出1</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; 10 &lt; 42;//错误：试图比较cout和42！</span></span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="comment">//(cout &lt;&lt; 10) &lt; 42;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/12/08/CPlusPlus04/image-20230412214632674.png" alt="image-20230412214632674"></p>
<p>​		移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。因此在一次使用多个运算符时，有必要在适当的地方加上括号使其满足我们的要求。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://alsl521.github.io">kyl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://alsl521.github.io/2023/12/08/CPlusPlus04/">https://alsl521.github.io/2023/12/08/CPlusPlus04/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://alsl521.github.io" target="_blank">kyl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">C++基础入门</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/12/08/CPlusPlus03/" title="C++基础入门第三章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++基础入门第三章</div></div><div class="info-2"><div class="info-item-1">第三章 字符串、向量和数组3.1 命名空间using声明​		目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显式地将这一点标示了出来。因此，std::cin的意思就是要使用命名空间std中的名字cin。有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：  ​		一旦声明了上述语句，就可以直接访问命名空间中的名字. 每个名字都需要独立的using声明​		按照规定，每个using声明引入命名空间中的一个成员。  头文件不应包含using声明​		位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。 3.2 标准库类型string​		标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。 3.2.1...</div></div></div></a><a class="pagination-related" href="/2023/12/08/vue1/" title="vue学习笔记--Vue基础知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">vue学习笔记--Vue基础知识</div></div><div class="info-2"><div class="info-item-1">1    Vue基础知识1.1    Vue简介1.1.1	官网 英文官网 中文官网  1.1.2	介绍与描述 $\textcolor{red}{Vue}$ 是一套用来动态构建用户界面的渐进式JavaScript框架  构建用户界面：把数据通过某种办法变成用户界面 渐进式：Vue可以自底向上逐层的应用，简单应用只需要一个轻量小巧的核心库，复杂应用可以引入各式各样的Vue插件   作者：尤雨溪    1.1.3    Vue 的特点 遵循MVVM模式  编码简洁, 体积小, 运行效率高, 适合移动&#x2F;PC 端开发  它本身只关注UI, 也可以引入其它第三方库开发项目  采用**$\textcolor{red}{组件化}$**模式，提高代码复用率、且让代码更好维护   **$\textcolor{red}{声明式}$**编码，让编码人员无需直接操作DOM，提高开发效率   使用**$\textcolor{red}{虚拟DOM}$** 和**$\textcolor{red}{Diff算法}$** ，尽量复用DOM节点    1.1.4	与其他 JS 框架的关联 借鉴...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/12/08/CPlusPlus02/" title="C++基础入门第二章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第二章</div></div><div class="info-2"><div class="info-item-1">第二章 变量和基本类型2.1基本内置类型​		C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。 2.1.1算数类型​		算数类型分为两类：整型(integral type，包括字符和布尔类型在内)和浮点型。    类型 含义 最小尺寸    bool 布尔类型 未定义   char 字符 8bits   wchar_t 宽字符 16bits   char16_t Unicode字符 16bits   char32_t Unicode字符 32bits   short 短整型 16bits   int 整型 16bits (在32位机器中是32bits)   long 长整型 32bits   long long 长整型 64bits （是在C++11中新定义的）   float 单精度浮点数 6位有效数字   double 双精度浮点数 10位有效数字   long...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus03/" title="C++基础入门第三章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第三章</div></div><div class="info-2"><div class="info-item-1">第三章 字符串、向量和数组3.1 命名空间using声明​		目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显式地将这一点标示了出来。因此，std::cin的意思就是要使用命名空间std中的名字cin。有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：  ​		一旦声明了上述语句，就可以直接访问命名空间中的名字. 每个名字都需要独立的using声明​		按照规定，每个using声明引入命名空间中的一个成员。  头文件不应包含using声明​		位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。 3.2 标准库类型string​		标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。 3.2.1...</div></div></div></a><a class="pagination-related" href="/2023/12/08/CPlusPlus01/" title="C++基础入门第一章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-08</div><div class="info-item-2">C++基础入门第一章</div></div><div class="info-2"><div class="info-item-1">第一章 开始1.1	编写一个简单的C++程序12345#include &lt;iostream&gt;int main()&#123;    return 0;&#125;  ​		一个函数的定义包含四部分：返回类型(return type)、函数名(function name)、一个括号包围的形参列表(parameter list ，允许为空)以及函数体(function body)。虽然main函数在某种程度上比较特殊，但其定义与其他函数是一样的。 ​		在本例中，main的形参列表是空的(()中什么也没有)。 ​		main函数的返回类型必须为int，即整数类型。int类型是一种内置类型(built-intype)，即语言自身定义的类型。 ​		函数定义的最后一部分是函数体，它是一个以左花括号(curly brace)开始，以右花括号结束的语句块(block of...</div></div></div></a><a class="pagination-related" href="/2023/12/11/Linux1/" title="黑马程序员--Linux安装各类软件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-11</div><div class="info-item-2">黑马程序员--Linux安装各类软件</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/02/01/SSM-2/" title="Java学习-SSM-2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">Java学习-SSM-2</div></div><div class="info-2"><div class="info-item-1">核心容器前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的核心容器。 这里所说的核心容器，大家可以把它简单的理解为ApplicationContext，前面虽然已经用到过，但是并没有系统的学习，接下来咱们从以下几个问题入手来学习下容器的相关知识:  如何创建容器? 创建好容器后，如何从容器中获取bean对象? 容器类的层次结构是什么? BeanFactory是什么?  环境准备在学习和解决上述问题之前，先来准备下案例环境:  创建一个Maven项目  pom.xml添加Spring的依赖 1234567&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;   ...</div></div></div></a><a class="pagination-related" href="/2024/02/14/Little-knowledge-of-Java-5/" title="Java学习（五）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-14</div><div class="info-item-2">Java学习（五）</div></div><div class="info-2"><div class="info-item-1">处理错误为了尽量避免错误的发生，至少应该做到以下几点：  向用户通知错误； 保存所有的工作； 允许用户妥善地退出程序。  假设在一个Java...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kyl</div><div class="author-info-description">用于记录平时学习的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/alsl521" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:852970167@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">第四章 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">4.1.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">组合运算符和运算对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">运算对象转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">重载运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">左值和右值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">4.1.2 优先级与结合律</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E6%97%A0%E8%A7%86%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">括号无视优先级与结合律</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E5%BE%8B%E6%9C%89%E4%BD%95%E5%BD%B1%E5%93%8D"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">优先级与结合律有何影响</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">4.1.3 求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">求值顺序、优先级、结合律</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 逻辑和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">逻辑与和逻辑或运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">逻辑非运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">相等性测试与布尔字面值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E6%BB%A1%E8%B6%B3%E5%8F%B3%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">赋值运算满足右结合律</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7%E8%BE%83%E4%BD%8E"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">赋值运算优先级较低</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E5%8B%BF%E6%B7%B7%E6%B7%86%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">切勿混淆相等运算符和赋值运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">复合赋值运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">4.5 递增和递减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%B7%B7%E7%94%A8%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">在一条语句中混用解引用和递增运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%AF%B9%E8%B1%A1%E5%8F%AF%E6%8C%89%E4%BB%BB%E6%84%8F%E9%A1%BA%E5%BA%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">运算对象可按任意顺序求值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">4.6 成员访问运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">4.7 条件运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">嵌套条件运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E8%BE%93%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">在输出表达式中使用条件运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.</span> <span class="toc-text">4.8 位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">移位运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E6%B1%82%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.0.2.</span> <span class="toc-text">位求反运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E4%B8%8E%E3%80%81%E4%BD%8D%E6%88%96%E3%80%81%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.0.3.</span> <span class="toc-text">位与、位或、位异或运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.0.4.</span> <span class="toc-text">使用位运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%8F%88%E5%8F%ABIO%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E6%BB%A1%E8%B6%B3%E5%B7%A6%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">1.8.0.5.</span> <span class="toc-text">移位运算符（又叫IO运算符）满足左结合律</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/21/NET-ASP-13/" title="ASP.NET学习记录-13-实践2-数据库进阶">ASP.NET学习记录-13-实践2-数据库进阶</a><time datetime="2025-04-21T08:39:19.000Z" title="发表于 2025-04-21 16:39:19">2025-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-12/" title="ASP.NET学习记录-12-实践2-使用MySQL数据库">ASP.NET学习记录-12-实践2-使用MySQL数据库</a><time datetime="2025-04-18T08:11:21.000Z" title="发表于 2025-04-18 16:11:21">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-11/" title="ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API">ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API</a><time datetime="2025-04-18T02:13:44.000Z" title="发表于 2025-04-18 10:13:44">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/NET-ASP-10/" title="ASP.NET学习记录-10-过滤">ASP.NET学习记录-10-过滤</a><time datetime="2025-04-16T12:02:16.000Z" title="发表于 2025-04-16 20:02:16">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/15/Software/" title="记录必备软件">记录必备软件</a><time datetime="2025-04-15T11:29:21.000Z" title="发表于 2025-04-15 19:29:21">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By kyl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>