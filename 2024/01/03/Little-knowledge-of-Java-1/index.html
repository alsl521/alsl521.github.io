<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java学习（一） | kyl的博客</title><meta name="author" content="kyl"><meta name="copyright" content="kyl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java程序设计概述、Java的基本程序设计结构的相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习（一）">
<meta property="og:url" content="https://alsl521.github.io/2024/01/03/Little-knowledge-of-Java-1/index.html">
<meta property="og:site_name" content="kyl的博客">
<meta property="og:description" content="Java程序设计概述、Java的基本程序设计结构的相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4">
<meta property="article:published_time" content="2024-01-03T12:15:02.000Z">
<meta property="article:modified_time" content="2025-04-08T08:06:34.569Z">
<meta property="article:author" content="kyl">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java学习（一）",
  "url": "https://alsl521.github.io/2024/01/03/Little-knowledge-of-Java-1/",
  "image": "https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4",
  "datePublished": "2024-01-03T12:15:02.000Z",
  "dateModified": "2025-04-08T08:06:34.569Z",
  "author": [
    {
      "@type": "Person",
      "name": "kyl",
      "url": "https://alsl521.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://alsl521.github.io/2024/01/03/Little-knowledge-of-Java-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习（一）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">kyl的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Java学习（一）</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java学习（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-03T12:15:02.000Z" title="发表于 2024-01-03 20:15:02">2024-01-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-08T08:06:34.569Z" title="更新于 2025-04-08 16:06:34">2025-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Java三大平台"><a href="#Java三大平台" class="headerlink" title="Java三大平台"></a><code>Java</code>三大平台</h1><p><code>JavaSE</code>、<code>JavaME</code>、<code>JavaE E</code></p>
<h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a><code>JavaSE</code></h2><p>Java语言的标准版，用于桌面应用的开发。是其他两个版本的基础。</p>
<h2 id="JavaME"><a href="#JavaME" class="headerlink" title="JavaME"></a><code>JavaME</code></h2><p>Java语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。</p>
<p>其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。但是，安卓也是可以用Java来开发的。</p>
<h2 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a><code>JavaEE</code></h2><p>用于Web方向的网站开发。（主要从事后台服务器的开发）</p>
<p>在服务器领域，Java是当之无愧的龙头老大。</p>
<h2 id="Java的主要特性"><a href="#Java的主要特性" class="headerlink" title="Java的主要特性"></a><code>Java</code>的主要特性</h2><ul>
<li>面向对象</li>
<li>安全性</li>
<li>多线程</li>
<li>简单易用</li>
<li>开源</li>
<li>跨平台</li>
</ul>
<h2 id="Java语言跨平台的原理"><a href="#Java语言跨平台的原理" class="headerlink" title="Java语言跨平台的原理"></a>Java语言跨平台的原理</h2><p>编写源代码文件，用<code>javac</code>编译程序把文件进行编译，然后在某个<code>Java虚拟机</code>上执行编译过的字节码。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240122211928618.png" alt="image-20240122211928618"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106102415288.png" alt="image-20240106102415288"></p>
<p>高级语言的编译运行方式</p>
<ul>
<li>编译型</li>
<li>解释型</li>
<li>混合型，半编译，半解释</li>
</ul>
<h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>典型的如<code>C</code>、<code>C++</code>、<code>Pascal</code>等语言，都属于编译型语言。它是编译的时候直接编译成机器可以执行或调用的程序，如<code>exe</code>、<code>dll</code>或<code>ocx</code><br>等类型。如将<code>C</code>语言可直接编译成<code>exe</code>程序，运行时直接运行<code>exe</code>程序就可以了，无需重新编译，所以程序执行效率较高。</p>
<p><strong>编译过程</strong>就好比有个翻译师，你说一句，翻译师就会直接将你这句话翻译出来，从而传达给别人。</p>
<p>编译型语言不是跨平台的。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106102545695.png" alt="image-20240106102545695"></p>
<h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>典型的如<code>Java</code>、<code>Python</code>、<code>Matlab</code>等语言，都属于解释型语言。这类程序不需要编译，运行时使用一个专门的解释器去翻译，每一条语句都是执行的时候才翻译，所以这类程序每执行一次就要翻译一次，运行效率较称低。</p>
<p><strong>解释过程</strong>就好比将你所说的话先全部记到一张纸上，然后将通过一些翻译软件等，将这张纸上的全部内容翻译出来，再传达给别人。</p>
<p>交由个平台的解释器运行。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106102610149.png" alt="image-20240106102610149"></p>
<ul>
<li>操作系统本身其实是不认识Java语言的。</li>
<li>但是针对于不同的操作系统，<code>Java</code>交由虚拟机运行，Java提供了不同的虚拟机。</li>
</ul>
<p>虚拟机会把Java语言翻译成操作系统能看得懂的语言。<strong>即先生成一个二进制字节码文件，随后再一行一行的翻译。</strong></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106102723994.png" alt="image-20240106102723994"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240225145508930.png" alt="image-20240225145508930"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20210923091350952.png" alt="image-20210923091350952"></p>
<h2 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a><code>JRE</code>和<code>JDK</code></h2><p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20210923091544110.png" alt="image-20210923091544110"></p>
<p><code>JVM（Java Virtual Machine）</code>，<code>Java</code>虚拟机</p>
<p><code>JRE（Java Runtime Environment）</code>，<code>Java</code>运行环境，包含了<code>JVM</code>和<code>Java</code>的核心类库<code>（Java API）</code></p>
<p><code>JDK（Java Development Kit）</code>称为<code>Java</code>开发工具，包含了<code>JRE</code>和开发工具</p>
<p>总结：我们只需安装<code>JDK</code>即可，它包含了<code>java</code>的运行环境和虚拟机。<code>JDK</code>包含了<code>JRE</code>。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106103236142.png" alt="image-20240106103236142"></p>
<h1 id="认识Java"><a href="#认识Java" class="headerlink" title="认识Java"></a>认识<code>Java</code></h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a><code>main</code></h2><p>不管你的程序有多大（也可以说不管有多少个类），一定都会有一个<code>main()</code><br>来作为程序的起点。每个Java程序最少都会有一个类以及一个<code>main()</code>。每个应用程序只有一个<code>main()</code>函数。</p>
<blockquote>
<p>当Java虚拟机启动执行时，它会寻找你在命令列所指定的类。然后它会锁定main方法：</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240225150153987.png" alt="image-20240225150153987"></p>
<p>接着Java虚拟机就会执行main方法在花括号间的函数所有指令。在Java中的所有东西都会属于某个类。你会建立源文件（扩展名为，java)<br>,然后将它编译成新的类文件（扩展名为.class)。真正被执行的是类。</p>
</blockquote>
<p>Main()的两种用途：</p>
<ul>
<li>测试真正的类</li>
<li>启动你的Java应用程序</li>
</ul>
<h2 id="Java特性"><a href="#Java特性" class="headerlink" title="Java特性"></a><code>Java</code>特性</h2><p>1、简单性 2、面向对象 3、分布式 4、健壮性 5、安全性 6、体系结构中立 7、可移植性 8、解释型 9、高性能 10、多线程 11、动态性</p>
<h2 id="Java内存"><a href="#Java内存" class="headerlink" title="Java内存"></a><code>Java</code>内存</h2><p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120104147026.png" alt="image-20240120104147026"></p>
<p>Java的内存需要划分为5个部分：</p>
<p>1.1 栈（Stack）<br>数据存储在随机存取存储器（random-access memory,RAM)里，处理器可以通过栈指针(stack pointer)直接操作该数据。具体来说，栈指针向下移动将申请一块新的内存，向上移动则会释放这块内存。这是一种极其迅速和高效的内存分配方式，其效率仅次于寄存器。只不过Java系统在创建应用程序时就必须明确栈上所有对象的生命周期。这种限制约束了程序的灵活性，因此虽然有一些数据会保存在栈上（尤其是对象用)，对象本身却并非如此。<br>栈:方法调用和局部变量<br><code>局部变量（局部变量）：方法的参数，或者方法 &#123; &#125; 内部的变量</code><br>作用域：一旦超出作用域，立刻从栈内存中消失</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题"></p>
<p>1.2 堆<br>堆(heap)<br>这是一个通用的内存池（使用的也是RAM空间），用于存放所有Java对象。与栈不同的是，编译器并不关心位于堆上的对象需要存在多久。因此，堆的使用是非常灵活的。比如，当你需要一个对象时，可以随时使用new来创建这个对象，那么当这段代码被执行时，Java会在难上为该对象分配内存空间。然而这种灵活性是有代价的：分配和清理堆存储要比栈存储花费更多的时间（如果你可以像C++那样在栈上创建对象的话)。好消息是，随着时间的推移，Java的堆内存分配机制已经变得非常高效了，所以你并不需要太过关注此类问题。<br>堆：凡是 new 出来的东西，都在堆内存中。所有对象，以及创建的<code>实例变量</code>。<br>堆内存中的东西都有一个地址值：16进制<br>堆内存里面的数据，都有默认值，规则如下：<br>① 如果是整数 默认值为0<br>② 如果是浮点数 默认值为0.0<br>③ 如果是字符 默认值为’\u0000’<br>④ 如果是布尔型 默认值为false<br>⑤ 如果是引用类型 默认值为null</p>
<blockquote>
<p>当一个新建对象带有对象引用的变量时，此时真正的问题是：是否需要保留对象带有的所有对象的空间？不是这样的。无论如何，Java会留下空间给实例变量的值。但是引用变量的值并不是对象本身，所以若CellPhone带有Antenna,Java只会留下Antenna引用量而不是对象本身所用到的空间。<br>那么Antenna对象会取得在堆上的空间吗？我们得先知道Antenna对象是在何时创建的。这要看实例变量是如何声明的。如果有声明变量但没有给它赋值，则只会留下变量的空间。</p>
<p>private Antenna ant;</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240305194957765.png" alt="image-20240305194957765"></p>
<p>private Antenna ant new Antenna();</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240305195009697.png" alt="image-20240305195009697"></p>
</blockquote>
<p>1.3 方法区（Method Area）<br>方法区：存储.class相关信息，包含方法的信息<br>注意：方法区只是储存了.class的死信息，一旦运行，还是要在栈里运行</p>
<p>1.4 本地方法栈（Native Method Stack）<br>本地方法栈与操作系统相关</p>
<p>1.5 寄存器（Pc Register）<br>寄存器（register)。这是速度最快的数据存储方式，因为它保存数据的位置不同于其他方式：数据会直接保存在中央处理器(central<br>processing unit,CPU)<br>里，然而寄存器的数量是有限的，所以只能按需分配。此外，你不能直接控制寄存器的分配、甚至你在程序中都找不到寄存器存在过的证据(<br>C和C++是例外，它们允许你向编译器申请分配寄存器)。</p>
<h1 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h1><p>Java中的所有函数都是某个类的方法(标准术语将其称为方法，而不是成员函数)。因此，Java中的main方法必须有一个外壳(shell)<br>类。Java中的main方法必须是静态的。如果main方法正常退出，那么Java应用程序的退出码为0，表示成功地运行了程序。如果希望在终止程序时返回其他的退出码，那就需要使用<code>System.exit()</code><br>方法。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240225145642470.png" alt="image-20240225145642470"></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>三种类型</p>
<p>单行注释：<code>//</code>，注释内容从<code>//</code>开始到本行结尾</p>
<p>多行注释：<code>/* */</code>，在<code>/* </code>和<code> */</code>之间的所有内容</p>
<p>文档注释：<code>/** */</code>，在<code>/** </code>和<code> */</code>之间的所有内容</p>
<p>后两种方式不能嵌套，即不能在<code>/* */</code>中再添加<code>/* */</code>，因为没有意义。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型的四类八种"><a href="#基本数据类型的四类八种" class="headerlink" title="基本数据类型的四类八种"></a>基本数据类型的四类八种</h3><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">字节(byte)&#x2F;内存占用</th>
<th>所占位数(bit)</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数</td>
<td align="center"><code>byte</code></td>
<td align="center">1</td>
<td>8</td>
<td align="center">-2^7 ~ 2^7-1 (-128 ~ 127)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>short</code></td>
<td align="center">2</td>
<td>16</td>
<td align="center">-2^15 ~2^15-1 (-32768 ~ 32767)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>int</code></td>
<td align="center">4</td>
<td>32</td>
<td align="center">-2^31 ~ 2^31-1 (-2147483648 ~ 2147483647)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>long</code></td>
<td align="center">8</td>
<td>64</td>
<td align="center">-2^63 ~ 2^63-1 ( -9223372036854775808 ~ 9223372036854775807)</td>
</tr>
<tr>
<td align="center">浮点数</td>
<td align="center"><code>float</code></td>
<td align="center">4</td>
<td>32</td>
<td align="center">±3.4E+38 (大约±3.40282347E+38F(有效位数为6~7位))</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><code>double</code></td>
<td align="center">8</td>
<td>64</td>
<td align="center">±1.7E+308 (大约±1.79769313486231570E+308(有效位数为15位))</td>
</tr>
<tr>
<td align="center">字符</td>
<td align="center"><code>char</code></td>
<td align="center">2</td>
<td>16</td>
<td align="center">0-65535</td>
</tr>
<tr>
<td align="center">布尔</td>
<td align="center"><code>boolean</code></td>
<td align="center">由Java虚拟机决定</td>
<td>由Java虚拟机决定</td>
<td align="center">true，false</td>
</tr>
</tbody></table>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p> e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。</p>
<p> 在java中整数默认是int类型，浮点数默认是double类型。</p>
<p>整数类型和小数类型的取值范围大小关系：</p>
<p>double &gt; float &gt; long &gt; int &gt; short &gt; byte</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106105847029.png" alt="image-20240106105847029"></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h4><ul>
<li>如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。</li>
<li>如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。</li>
<li>如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）</li>
<li>如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）</li>
<li>在Java中，整型值和布尔值之间不能相互转换。且整数表达式<code>x=0</code>不能转换为布尔值。</li>
</ul>
<h3 id="Unicode和char类型"><a href="#Unicode和char类型" class="headerlink" title="Unicode和char类型"></a><code>Unicode</code>和<code>char</code>类型</h3><h4 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a><code>ASCII</code>码</h4><p><img src="/2024/01/03/Little-knowledge-of-Java-1/1-729-jpg_6_0_______-1107-0-0-1107.jpg" alt="ascii字符对照表完整版 - ASCII码中文站"></p>
<p>在计算机中，1字节对应 8 位二进制数，而每位二进制数有 0、1 两种状态，因此 1 字节可以组合出 256 种状态。如果这 256<br>中状态每一个都对应一个符号，就能通过 1 字节的数据表示 256 个字符。美国人于是就制定了一套编码（其实就是个字典），描述英语中的字符和这<br>8 位二进制数的对应关系，这被称为 ASCII 码。</p>
<p>ASCII 码一共定义了 128 个字符，例如大写的字母 A 是 65（这是十进制数，对应二进制是0100 0001）。这 128 个字符只使用了 8<br>位二进制数中的后面 7 位，最前面的一位统一规定为 0。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。于是，一些欧洲的国家就决定，将 ASCII<br>码中闲置的最高位利用起来，这样一来就能表示 256 个字符。但是，这里又有了一个问题，那就是不同的国家的字符集可能不同，就算它们都能用<br>256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的<br>ASCII 码中是 ђ。</p>
<p>因此，ASCII 码的问题在于尽管所有人都在 0 - 127 号字符上达成了一致，但对于 128 - 255<br>号字符上却有很多种不同的解释。与此同时，亚洲语言有更多的字符需要被存储，一个字节已经不够用了。</p>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>最终，美国人意识到他们应该提出一种标准方案来展示世界上所有语言中的所有字符，出于这个目的，Unicode诞生了。</p>
<p>Unicode可以看成就是一个字符集，它对世界上大部分的文字系统进行了整理、编码，为每一个字符而非字形定义唯一的整数，这个整数称为码点（Code<br>Point）。码点（Code Point）是指与一个编码表中的某个字符对应的代码值。</p>
<h4 id="Unicode-编码方案"><a href="#Unicode-编码方案" class="headerlink" title="Unicode 编码方案"></a>Unicode 编码方案</h4><p>当前的 Unicode 字符分为17组编排，每组称为一个<strong>平面</strong>（Plane），而每一个平面拥有65536（即2^16）个码点。然而当前只用了少数平面。在表示一个<br>Unicode 的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。</p>
<table>
<thead>
<tr>
<th align="left">平面</th>
<th align="left">始末字符值</th>
<th align="left">中文名称</th>
<th align="left">英文名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0号平面</td>
<td align="left"><code>U+0000</code> - <code>U+FFFF</code></td>
<td align="left"><strong>基本多文种平面</strong></td>
<td align="left">Basic Multilingual Plane，简称<strong>BMP</strong></td>
</tr>
<tr>
<td align="left">1号平面</td>
<td align="left"><code>U+10000</code> - <code>U+1FFFF</code></td>
<td align="left"><strong>多文种补充平面</strong></td>
<td align="left">Supplementary Multilingual Plane，简称<strong>SMP</strong></td>
</tr>
<tr>
<td align="left">2号平面</td>
<td align="left"><code>U+20000</code> - <code>U+2FFFF</code></td>
<td align="left"><strong>表意文字补充平面</strong></td>
<td align="left">Supplementary Ideographic Plane，简称<strong>SIP</strong></td>
</tr>
<tr>
<td align="left">3号平面</td>
<td align="left"><code>U+30000</code> - <code>U+3FFFF</code></td>
<td align="left"><strong>表意文字第三平面</strong></td>
<td align="left">Tertiary Ideographic Plane，简称<strong>TIP</strong></td>
</tr>
<tr>
<td align="left">4号平面 至 13号平面</td>
<td align="left"><code>U+40000</code> - <code>U+DFFFF</code></td>
<td align="left">（尚未使用）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14号平面</td>
<td align="left"><code>U+E0000</code> - <code>U+EFFFF</code></td>
<td align="left"><strong>特别用途补充平面</strong></td>
<td align="left">Supplementary Special-purpose Plane，简称<strong>SSP</strong></td>
</tr>
<tr>
<td align="left">15号平面</td>
<td align="left"><code>U+F0000</code> - <code>U+FFFFF</code></td>
<td align="left">保留作为<strong>私人使用区（A区）</strong></td>
<td align="left">Private Use Area-A，简称<strong>PUA-A</strong></td>
</tr>
<tr>
<td align="left">16号平面</td>
<td align="left"><code>U+100000</code> - <code>U+10FFFF</code></td>
<td align="left">保留作为<strong>私人使用区（B区）</strong></td>
<td align="left">Private Use Area-B，简称<strong>PUA-B</strong></td>
</tr>
</tbody></table>
<h4 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h4><p>UTF是 Unicode&#x2F;UCS Transformation Format 的缩写，是将 Unicode 码点映射到唯一字节序列的算法，根据映射方法的的不同，有<br>UTF-8、UTF-16 和 UTF-32 等具体的编码格式。</p>
<h5 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h5><p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc2781">RFC 2781 - UTF-16，ISO 10646 的编码</a></p>
<p>Unicode 的第一个平面称为<strong>基本多语言平面</strong>（Basic Multilingual Plane, <strong>BMP</strong>），或称第零平面（Plane 0），其他平面称为**辅助平面</p>
<p>**（Supplementary Planes）。</p>
<p>UTF-16编码采用不同长度的编码表示所有Unicode码点。在基本多语言平面中，每个字符用16位表示，通常称为代码单元(code unit)<br>；而辅助字符编码为一对连续的代码单元。采用这种编码对表示的各个值落入基本多语言平面中未用的2048个值范围内，通常称为替代区域（surrogate<br>area)(<code>U+D800</code> ~ <code>U+DBFF</code>用于第一个代码单元，U+DC00 ~ <code>U+DFFF</code>用于第二个代码单元)<br>。这样设计十分巧妙，我们可以从中迅速知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。由于基本平面内，从<code>U+D800</code><br>到<code>U+DFFF</code>之间的码点区段是永久保留不映射到Unicode字符。UTF-16就利用保留下来的<code>0xD800</code>-<code>0xDFFF区</code>块的码点来对辅助平面的字符的码点进行编码。</p>
<table>
<thead>
<tr>
<th align="left">Unicode 编码范围</th>
<th align="left">UTF-16 编码形式（二进制）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>U+000000</code> - <code>U+00FFFF</code></td>
<td align="left"><code>xxxx xxxx</code> <code>xxxx xxxx</code></td>
</tr>
<tr>
<td align="left"><code>U+010000</code> - <code>U+10FFFF</code></td>
<td align="left"><code>1101 10yy</code> <code>yyyy yyyy</code> <code>1101 11xx</code> <code>xxxx xxxx</code></td>
</tr>
</tbody></table>
<p>可以看到，UTF-16 用二个字节来表示基本平面，用四个字节来表示辅助平面。</p>
<p>基本平面中的码点，UTF-16编码为16位的单个码元，数值等价于对应的码点。</p>
<p>辅助平面中的码点，在UTF-16中被编码为<strong>一对</strong>16位长的码元（即32位，4字节），称作<em>代理对</em>（Surrogate Pair），具体方法是：</p>
<ol>
<li>Unicode 码点减去 <code>0x10000</code>，得到的值的范围为20位长的 <code>0...0xFFFFF</code></li>
<li>将高位的10位的值（值的范围为 <code>0...0x3FF</code>）加上 <code>0xD800</code>（<code>11011000 00000000</code>） 得到第一个码元或称作高位代理（high<br>surrogate），值的范围是 <code>0xD800...0xDBFF</code>。由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为<br><strong>前导代理</strong>（lead surrogates）。</li>
<li>将低位的10位的值（值的范围也是 <code>0...0x3FF</code>）加上 <code>0xDC00</code> （<code>11011100 00000000</code>） 得到第二个码元或称作低位代理（low<br>surrogate），现在值的范围是 <code>0xDC00...0xDFFF</code>。由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为<br><strong>后尾代理</strong>（trail surrogates）。</li>
</ol>
<p>由于前导代理、后尾代理、BMP中的有效字符的码点，三者互不重叠，搜索是简单的：一个字符编码的一部分不可能与另一个字符编码的不同部分相重叠。这意味着UTF-16是自同步（self-synchronizing）的：可以通过仅检查一个码元来判定给定字符的下一个字符的起始码元。</p>
<h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><p><strong>UTF-8</strong>是一种可变长度字符编码格式，它的码元是8位的，即 UTF-8 把 Unicode 码点映射为字节序列。其编码形式如下表</p>
<table>
<thead>
<tr>
<th align="left">码点的位数</th>
<th align="left">码点范围</th>
<th align="left">字节序列</th>
<th align="left">Byte 1</th>
<th align="left">Byte 2</th>
<th align="left">Byte 3</th>
<th align="left">Byte 4</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left"><code>U+0000</code> - <code>U+007F</code></td>
<td align="left">1</td>
<td align="left"><code>0xxxxxxx</code></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>U+0080</code> - <code>U+07FF</code></td>
<td align="left">2</td>
<td align="left"><code>110xxxxx</code></td>
<td align="left"><code>10xxxxxx</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><code>U+0800</code> - <code>U+FFFF</code></td>
<td align="left">3</td>
<td align="left"><code>1110xxxx</code></td>
<td align="left"><code>10xxxxxx</code></td>
<td align="left"><code>10xxxxxx</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><code>U+10000</code> - <code>U+10FFFF</code></td>
<td align="left">4</td>
<td align="left"><code>11110xxx</code></td>
<td align="left"><code>10xxxxxx</code></td>
<td align="left"><code>10xxxxxx</code></td>
<td align="left"><code>10xxxxxx</code></td>
</tr>
</tbody></table>
<p>每个使用 UTF-8 存储的字符，除了第一个字节外，其余字节的最高两位都是以”10”开始。</p>
<p>在ASCII码的范围，用一个字节表示，超出 ASCII 码的范围就用多个字节表示，这就形成了我们上面看到的UTF-8的表示方法。这样的好处是当文本文件中只有<br>ASCII 字符（ASCII 编码与其在 Unicode 中的编码相同）时，存储的文件每个字符都为一个字节，与旧的普通 ASCII<br>文件无异，读取的时候也是如此，所以能与以前的 ASCII 文件兼容。</p>
<p>大于 ASCII<br>码的，就会由第一字节的前几位表示该字符编码字节序列的长度，比如110xxxxx前三位的二进制表示告诉我们这是个2字节长的序列；1110xxxx是个3字节长的的序列，依此类推；xxx的位置由字符编码的二进制表示的位填入。越靠右的x具有越少的特殊意义。只用最短的那个足够表达一个字符编码数的多字节串。在多字节串中，第一个字节的开头”<br>1”的数目就是该字符编码字节的数目。</p>
<h5 id="Java中的char类型"><a href="#Java中的char类型" class="headerlink" title="Java中的char类型"></a>Java中的char类型</h5><p>Java 中的 <code>char</code> 类型的长度为2字节，其存放的是 Unicode 码点，范围为<code>U+0000</code> - <code>U+FFFF</code> ，即 Java 中的 <code>char</code> 类型只能表示<br>Unicode 标准中的基本平面（<strong>BMP</strong>）的字符。由于早期的 Unicode 标准（1991年到1995年，Unicode<br>2.0以前）使用了固定16位长的编码形式，<code>char</code>类型长度设计为16位也就不难理解了。</p>
<p>另外 Java 中的字符串使用了UTF-16 的编码（The Java programming language represents text in sequences of 16-bit code units,<br>using the UTF-16 encoding.），此处指的是 Java 语言的<strong>内码</strong>是UTF-16 编码。所谓内码，指的是程序内部使用的字符编码，特别是某种语言的字符和字符串在内存里用的编码；相对地，<br><strong>外码</strong>是程序与外部交互时外部使用的字符编码。</p>
<h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>作用：告诉程序员，数据在程序中的书写格式。</p>
<table>
<thead>
<tr>
<th><strong>字面量类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>程序中的写法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>整数</td>
<td>不带小数的数字</td>
<td>666，-88</td>
</tr>
<tr>
<td>小数</td>
<td>带小数的数字</td>
<td>13.14，-5.21</td>
</tr>
<tr>
<td>字符</td>
<td>必须使用单引号，有且仅能一个字符</td>
<td>‘A’，‘0’，   ‘我’</td>
</tr>
<tr>
<td>字符串</td>
<td>必须使用双引号，内容可有可无</td>
<td>“HelloWorld”，“黑马程序员”</td>
</tr>
<tr>
<td>布尔值</td>
<td>布尔值，表示真假，只有两个值：true，false</td>
<td>true 、false</td>
</tr>
<tr>
<td>空值</td>
<td>一个特殊的值，空值</td>
<td>值是：null</td>
</tr>
</tbody></table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java中有两种变量，分别是基本数据类型（又称（primitive主数据类型））和引用数据类型。变量就像是杯子，是一种容器，承装某些事物。</p>
<ul>
<li><strong>基本数据类型</strong></li>
</ul>
<p>primitive主数据类型用来保存基本类型的值，包括整数、布尔和浮点数等。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240119101917752.png" alt="image-20240119101917752"></p>
<ul>
<li><strong>引用数据类型</strong></li>
</ul>
<p>对象引用保存的是对象的引用</p>
<ul>
<li>事实上没有对象变量这样的东西存在。</li>
<li>只有引用(reference)到对象的变量。</li>
<li>对象引用变量保存的是存取对象的方法。</li>
<li>它并不是对象的容器，而是<code>类似指向对象的指针</code>。或者可以说是<code>地址</code><br>。但在Java中我们不会也不该知道引用变量中实际装载的是什么，它只是用来代表单一的对象。<code>只有Java虚拟机才会知道如何使用引用来取得该对象。</code></li>
</ul>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240119101955290.png" alt="image-20240119101955290"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/yinyongshuju.png"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240119102205121.png" alt="image-20240119102205121"></p>
<blockquote>
<p>变量分类</p>
<ul>
<li>局部变量</li>
<li>实例变量（成员变量）</li>
<li>静态变量</li>
</ul>
</blockquote>
<ul>
<li>局部变量</li>
</ul>
<blockquote>
<ul>
<li><p><code>在方法体内声明的变量被称为局部变量，该变量只能在该方法内使用，类中的其他方法并不知道该变量。</code></p>
</li>
<li><p>局部变量声明在方法、构造方法或者语句块中。</p>
</li>
<li><p>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。</p>
</li>
<li><p>访问修饰符不能用于局部变量。</p>
</li>
<li><p>局部变量只在声明它的方法、构造方法或者语句块中可见。</p>
</li>
<li><p>局部变量是在栈上分配的。</p>
</li>
<li><p>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</p>
</li>
</ul>
</blockquote>
<ul>
<li>实例变量（成员变量）</li>
</ul>
<blockquote>
<ul>
<li><code>在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。</code></li>
<li>成员变量声明在一个类中，但在方法、构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li>
<li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁。</li>
<li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</li>
<li>成员变量可以声明在使用前或者使用后。</li>
<li>访问修饰符可以修饰成员变量。</li>
<li>成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</li>
</ul>
</blockquote>
<ul>
<li>静态变量</li>
</ul>
<blockquote>
<ul>
<li><p><code>通过static关键字声明的变量被称为静态变量（类变量），它可以直接被类访问</code></p>
</li>
<li><p>静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。</p>
</li>
<li><p>无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝。</p>
</li>
<li><p>静态变量除了被声明为常量外很少使用。</p>
</li>
<li><p>静态变量储存在静态存储区。</p>
</li>
<li><p>静态变量在程序开始时创建，在程序结束时销毁。</p>
</li>
<li><p>与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</p>
</li>
<li><p>静态变量的默认值和实例变量相似。</p>
</li>
<li><p>静态变量还可以在静态语句块中初始化。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>注一：<code>成员变量又分为类变量（静态变量）和实例变量（非静态变量）。</code></li>
<li>注二：成员变量虽然有默认值，但是建议显示地对其赋予初值，这样可以提高程序代码的可读性。</li>
<li>注三：如果局部变量名和成员变量名相同，则在这个方法中成员变量被隐藏，想要访问则需使用 this<br> 关键字。但是建议不要定义与成员变量同名的局部变量，比如说如果在构造器中这么做，可能造成无法初始化某些成员变量的错误，而这种错误又很难被检测出来。</li>
<li>注四：变量名可大小写混写，首字符小写，字间分隔符用字的首字母大写。<strong>不用下划线</strong>，少用美元符号。给变量命名是尽量做到<strong>见名知意</strong>。更多java代码规范，参见：<a target="_blank" rel="noopener" href="http://www.hawstein.com/posts/google-java-style.html">Google Java 编程风格指南</a>。</li>
<li>注五：局部变量没有默认值，但成员变量有默认值。</li>
</ul>
</blockquote>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在Java中，每个变量都有一个类型(type)。在声明变量时，先指定变量的类型，然后是变量名。变量名对大小写敏感。</p>
<p><code>double salary;</code><br><code>int vacationDays;</code><br><code>long earthPopulation;</code><br><code>boolean done;</code></p>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>要想对一个已经声明过的变量进行赋值，就需要将变量名放在等号)左侧，再把一个适<br>当取值的Java表达式放在等号的右侧。<br>int vacationDays;<br>vacationDays &#x3D;12;<br>也可以将变量的声明和初始化放在同一行中。例如：<br>int vacationDays 12;<br>最后，在Java中可以将声明放在代码中的任何地方。</p>
<h4 id="变量的注意事项"><a href="#变量的注意事项" class="headerlink" title="变量的注意事项"></a>变量的注意事项</h4><ul>
<li>变量名不能重复</li>
<li>在一条语句中，可以定义多个变量。</li>
<li>变量在使用之前必须要赋值。</li>
<li>变量只能存一个值。</li>
</ul>
<h4 id="标识符（类、变量等的名称）"><a href="#标识符（类、变量等的名称）" class="headerlink" title="标识符（类、变量等的名称）"></a>标识符（类、变量等的名称）</h4><ul>
<li>必须由数字、字母、下划线<code>_</code>、美元符号<code>$</code>组成。</li>
<li>数字不能开头</li>
<li>不能是关键字</li>
<li>区分大小写的。</li>
</ul>
<h4 id="小驼峰命名法"><a href="#小驼峰命名法" class="headerlink" title="小驼峰命名法"></a>小驼峰命名法</h4><p>适用于变量名和方法名</p>
<ul>
<li><p>如果是一个单词，那么全部小写，比如：name</p>
</li>
<li><p>如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge</p>
</li>
</ul>
<h4 id="大驼峰命名法"><a href="#大驼峰命名法" class="headerlink" title="大驼峰命名法"></a>大驼峰命名法</h4><p>适用于类名</p>
<ul>
<li><p>如果是一个单词，那么首字母大写。比如：Demo、Test。</p>
</li>
<li><p>如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld</p>
</li>
</ul>
<p>不管起什么名字，都要做到见名知意。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在<code>Java</code>中，利用关键字<code>final</code>指示常量。</p>
<p>关键字fial表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。</p>
<p>在Java中，经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量(class constant)。可以使用关键字static<br>final设置一个类常量。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203112920047.png" alt="image-20240203112920047"></p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>有时候，变量的取值只在一个有限的集合内。<br>针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。例如，<br><code>enum Size &#123;SMALL,MEDIUM,LARGE,EXTRA LARGE &#125;</code><br>现在，可以声明这种类型的变量：<br><code>Size s Size.MEDIUM;</code><br>Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null,null表示这个变量没有设置任何值。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p> 就是对常量或者变量进行操作的符号。</p>
<p> 比如： <code>+ -  *  /</code></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p> 用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。</p>
<p> 比如：a + b 这个整体就是表达式。</p>
<p> 而其中+是算术运算符的一种，所以这个表达式也称之为算术表达式。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>分类：分类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / %</span><br></pre></td></tr></table></figure>

<p>运算特点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ - * :跟小学数学中一模一样没有任何区别.</span><br><span class="line">/：</span><br><span class="line"><span class="number">1.</span>整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。</span><br><span class="line"><span class="number">2.</span>小数直接参与运算，得到的结果有可能是不精确的。</span><br><span class="line">%：取模、取余。</span><br><span class="line">   他做的也是除法运算，只不过获取的是余数而已。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203114125103.png" alt="image-20240203114125103"></p>
<h3 id="扩展赋值运算符"><a href="#扩展赋值运算符" class="headerlink" title="扩展赋值运算符"></a>扩展赋值运算符</h3><p>分类：</p>
<p> +&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</p>
<p>运算规则：</p>
<p> 就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。</p>
<p>注意点：</p>
<p> 扩展的赋值运算符中隐层还包含了一个强制转换。</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。</p>
<p>分类：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false</td>
</tr>
<tr>
<td>&gt;</td>
<td>就是判断左边是否大于右边，如果成立就是true，如果不成立就是false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false</td>
</tr>
<tr>
<td>&lt;</td>
<td>就是判断左边是否小于右边，如果成立就是true，如果不成立就是false</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false</td>
</tr>
</tbody></table>
<p>注意点：</p>
<ul>
<li>关系运算符最终的结果一定是布尔类型的。要么是true，要么是false</li>
<li>在写&#x3D;&#x3D;的时候，千万不要写成&#x3D;</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp; 和 | 的使用：</p>
<p>&amp;：逻辑与（而且）</p>
<p> 两边都为真，结果才是真，只要有一个为假，那么结果就是假。</p>
<p>|：逻辑或（或者）</p>
<p> 两边都为假，结果才是假，只要有一个为真，那么结果就是真。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;  //两边都是真，结果才是真。</span></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp; <span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> &amp; <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp; <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">false</span> &amp; <span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// | 或  //两边都是假，结果才是假，如果有一个为真，那么结果就是真。</span></span><br><span class="line">System.out.println(<span class="literal">true</span> | <span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> | <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> | <span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> | <span class="literal">true</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>^（异或）的使用：</p>
<p> 在以后用的不多，了解一下即可。</p>
<p>计算规则：如果两边相同，结果为false，如果两边不同，结果为true</p>
<p>可以理解为无进位相加。</p>
<blockquote>
<p>性质：</p>
<ol>
<li>0^N&#x3D;N    N^N&#x3D;0</li>
<li>B^A  &#x3D; A^B    (B^A) ^C  &#x3D; B^ (A^C)</li>
<li>同一批数运算的结果，与顺序无关，结果固定。<br>下列代码实现顺序交换：（arr[i]&#x3D;甲，arr[j]&#x3D;乙）<br>  arr[i] &#x3D; arr[i] ^ arr[j];<br>  arr[j] &#x3D; arr[i] ^ arr[j];<br>  arr[i] &#x3D; arr[i] ^ arr[j];<br>  原理（关键arr[i]和arr[j]所指向的内存中的内容不能是同一个，即地址不能相同，但值可以）<br>  arr[i]&#x3D;甲^乙，arr[j]&#x3D;乙；即arr[i]&#x3D;甲 ^乙，arr[j]&#x3D;乙<br>  arr[i]&#x3D;甲^乙， arr[j]&#x3D;乙^ （甲^乙）&#x3D; （乙^ 乙）^甲&#x3D;甲； 即arr[i]&#x3D;甲^乙， arr[j]&#x3D;甲<br>  arr[i]&#x3D;（甲^乙 ）^甲&#x3D; （甲^ 甲）^乙&#x3D;乙， arr[j]&#x3D;甲；即arr[i]&#x3D;&#x3D;乙， arr[j]&#x3D;甲</li>
</ol>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//^   //左右不相同，结果才是true，左右相同结果就是false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> ^ <span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">false</span> ^ <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> ^ <span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> ^ <span class="literal">true</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>!（取反）的使用：</p>
<p> 是取反，也叫做非。</p>
<p>计算规则：false取反就是true，true取反就是false</p>
<p>温馨提示：<strong>取反最多只用一个。</strong></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(!<span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(!<span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(!!<span class="literal">false</span>);<span class="comment">//注意点：取反最多只用一个。</span></span><br></pre></td></tr></table></figure>

<p>短路逻辑运算符</p>
<p>分类： &amp;&amp; ||</p>
<p>&amp;&amp;：</p>
<p> 运算结果跟&amp;是一模一样的，只不过具有短路效果。</p>
<p>||：</p>
<p> 运算结果跟|是一模一样的。只不过具有短路效果。</p>
<p>逻辑核心：</p>
<p> 当左边不能确定整个表达式的结果，右边才会执行。</p>
<p> 当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。</p>
<p>总结：</p>
<p> &amp;&amp; 和 &amp; 、||和|的运行结果都是一模一样的。</p>
<p> 但是短路逻辑运算符可以提高程序的运行效率。</p>
<p>建议：</p>
<p> 最为常用： &amp;&amp; || ！</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>又叫做：三元表达式或者问号冒号表达式。</p>
<p>格式：</p>
<p> 关系表达式 ？ 表达式1 ：表达式2 ；</p>
<p>计算规则：</p>
<ul>
<li>计算关系表达式的值。</li>
<li>如果关系表达式的值为真，那么执行表达式1。</li>
<li>如果关系表达式的值为假，那么执行表达式2。</li>
</ul>
<p>注意点：</p>
<p> 三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105203733240.png" alt="image-20240105203733240"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105203756080.png" alt="image-20240105203756080"></p>
<p>左移一次，原数乘2</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105203914237.png" alt="image-20240105203914237"></p>
<p>右移一次，原数除2</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105204016646.png" alt="image-20240105204016646"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105204042338.png" alt="image-20240105204042338"></p>
<h3 id="运算级别"><a href="#运算级别" class="headerlink" title="运算级别"></a>运算级别</h3><p>如果不使用圆括号，就按照给出的运算符优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外）。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203114614053.png" alt="image-20240203114614053"></p>
<h3 id="隐式转换（自动类型提升，前面补0）"><a href="#隐式转换（自动类型提升，前面补0）" class="headerlink" title="隐式转换（自动类型提升，前面补0）"></a>隐式转换（自动类型提升，前面补0）</h3><p>把一个取值范围小的数据，变为取值范围大的数据。</p>
<h4 id="什么时候转换？"><a href="#什么时候转换？" class="headerlink" title="什么时候转换？"></a>什么时候转换？</h4><p>数据类型不一样，不能进行计算，需要转成一样的才可以进行计算。</p>
<h4 id="转换规则1"><a href="#转换规则1" class="headerlink" title="转换规则1"></a>转换规则1</h4><p>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算</p>
<h4 id="转换规则2"><a href="#转换规则2" class="headerlink" title="转换规则2"></a>转换规则2</h4><p><code>byte</code> <code>short</code> <code>char</code>三种类型的数据在运算的时候，都会直接先提升为<code>int</code>， 然后再进行运算</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105203101883.png" alt="image-20240105203101883"></p>
<h3 id="强制数据转换（前面去0）"><a href="#强制数据转换（前面去0）" class="headerlink" title="强制数据转换（前面去0）"></a>强制数据转换（前面去0）</h3><p>把一个取值范围较大的变量，赋值给取值范围较小的变量。这种情况下不允许直接赋值，如果非要赋值，则必须进行强制转换。</p>
<p>格式 目标数据类型 变量名 &#x3D; （目标数据类型）被强转变量</p>
<p>但有可能会出现数据溢出、丢失等等现象。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105203523820.png" alt="image-20240105203523820"><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105203537793.png" alt="image-20240105203537793"></p>
<h3 id="截尾和舍入"><a href="#截尾和舍入" class="headerlink" title="截尾和舍入"></a>截尾和舍入</h3><p>将float或double转型为整型值时，总是对该数值执行截尾。如果想要对结果进行舍入，就需要使用java.lang.Math中的round()方法。</p>
<h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><h4 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h4><p><strong>机器数</strong></p>
<p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用机器数的<strong>最高位</strong>存放符号，正数为0，负数为1。并将<br><strong>8位</strong>数作为一个字节。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/v2-a6b9510c180051a6fccf62a9adbbdb05_r.jpg"></p>
<p>所以一个字节能存储的最大值是<code>01111111</code>转换后为+127</p>
<p>所以一个字节能存储的最小值是<code>11111111</code>转换后为-128</p>
<p>与<code>byte</code>的取值范围一样-2^7 ~ 2^7-1</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</p>
<p>[+1]原&#x3D; 0000 0001</p>
<p>[-1]原&#x3D; 1000 0001</p>
<p>利用源码对正数运算时不会出现问题。但是复数进行计算时会有问题。</p>
<p>例如[-0]原&#x3D; 1000 0000 所以0+1&#x3D;[-0]+[+1]&#x3D; 1000 0000+0000 0001&#x3D;1000 0001&#x3D;[-1]</p>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>反码：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。为了解决原码不能计算负数而设计的。</p>
<p>计算规则：正数的反码不变，<strong>等于原码</strong>。负数的反码在原码的基础上，符号位不变。数值取反，0变1,1变0。</p>
<p>原码<br>-56&#x3D;10111000<br>反码<br>-56&#x3D;11000111</p>
<p>-56+1&#x3D;11000111+0000 0001&#x3D;11001000&#x3D;-55</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240103215356375.png" alt="image-20240103215356375"></p>
<p>但由于0有两种表现形式，因此当数据计算跨<strong>0</strong>后，计算会出现问题。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240103215547533.png" alt="image-20240103215547533"></p>
<p>例如-4+7&#x3D;11111011+00000111&#x3D;00000010&#x3D;2。</p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>补码：正数的补码是其本身，负数的补码是在其反码的基础上+1。目的是将两个0错开一位。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240105194855027.png" alt="image-20240105194855027"></p>
<p>-128&#x3D;无[原码]&#x3D;无[补码]&#x3D;10000000</p>
<p>所以计算机内的数据都是按照补码进行运算的。因此<code>byte</code>的取值范围为-2^7 ~ 2^7-1</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="原码-1"><a href="#原码-1" class="headerlink" title="原码"></a>原码</h5><p>十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。</p>
<h5 id="原码的弊端"><a href="#原码的弊端" class="headerlink" title="原码的弊端"></a>原码的弊端</h5><p>利用原码进行计算的时候，如果是正数完全没有问题。<br>但是如果是负数计算，结果就出错，实际运算的方向，跟正确的运算方向是相反的。</p>
<h5 id="反码出现的目的"><a href="#反码出现的目的" class="headerlink" title="反码出现的目的"></a>反码出现的目的</h5><p>为了解决原码不能计算负数的问题而出现的。</p>
<h5 id="反码的计算规则"><a href="#反码的计算规则" class="headerlink" title="反码的计算规则"></a>反码的计算规则</h5><p>正数的反码不变，负数的反码在原码的基础上，符号位不变。数值取反，0变1,1变0。</p>
<h5 id="反码的弊端"><a href="#反码的弊端" class="headerlink" title="反码的弊端"></a>反码的弊端</h5><p>负数运算的时候，如果结果不跨0，是没有任何问题的，但是如果结果跨0，跟实际结果会有1的偏差。</p>
<h5 id="补码出现的目的"><a href="#补码出现的目的" class="headerlink" title="补码出现的目的"></a>补码出现的目的</h5><p>为了解决负数计算时跨0的问题而出现的。</p>
<h5 id="补码的计算规则"><a href="#补码的计算规则" class="headerlink" title="补码的计算规则"></a>补码的计算规则</h5><p>正数的补码不变，负数的补码在反码的基础上+1。<br>另外补码还能多记录一个特殊的值-128，该数据在1个字节下，没有原码和反码。</p>
<h5 id="补码的注意点"><a href="#补码的注意点" class="headerlink" title="补码的注意点"></a>补码的注意点</h5><p>计算机中的存储和计算都是以补码的形式进行的。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>从概念上讲，Java字符串就是Unicode字符序列。例如，字符串”Java\u22122”<br>由5个Unicode字符J、a、v、a和TM组成。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。</p>
<p><strong>注释：类似于C和C++,Java字符串中的代码单元和代码点从0开始计数。</strong></p>
<p>String类的<code>substring</code>方法可以从一个较大的字符串提取出一个子串。</p>
<h3 id="String类的特点"><a href="#String类的特点" class="headerlink" title="String类的特点"></a>String类的特点</h3><ul>
<li>字符串不可变，它们的值在创建后不能被更改</li>
<li>虽然 String 的值是不可变的，但是它们可以被共享</li>
<li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li>
</ul>
<h3 id="String类的构造方法"><a href="#String类的构造方法" class="headerlink" title="String类的构造方法"></a>String类的构造方法</h3><ul>
<li><p>常用的构造方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public   String()</code></td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td><code>public   String(char[] chs)</code></td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td><code>public   String(byte[] bys)</code></td>
<td>根据字节数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td><code>String s =   “abc”;</code></td>
<td>直接赋值的方式创建字符串对象，内容就是abc</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="创建字符串对象两种方式的区别"><a href="#创建字符串对象两种方式的区别" class="headerlink" title="创建字符串对象两种方式的区别"></a>创建字符串对象两种方式的区别</h3><p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120153718351.png" alt="image-20240120153718351"></p>
<ul>
<li><p>通过构造方法创建</p>
<p>通过 <code>new</code> 创建的字符串对象，每一次 <code>new</code> 都会申请一个内存空间，虽然内容相同，但是地址值不同</p>
</li>
<li><p>直接赋值方式创建</p>
<p>以<code>“”</code>方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，<code>JVM</code> 都只会建立一个 <code>String</code><br>对象，并在字符串池中维护</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120153840571.png" alt="image-20240120153840571"></p>
</li>
</ul>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203143420140.png" alt="image-20240203143420140"></p>
<blockquote>
<p>注意点：String str &#x3D; new String(“Hello”); 会产生几个对象？<br>如果字符串池里面没有“Hello”对象，会在字符串池里面生成一个对象，然后再生成一个字符串对象，str指向这个对象；如果字符串池里面已经有了“Hello”对象，则只会生成一个对象，str指向这个对象。</p>
<p>所以会有两个对象。</p>
</blockquote>
<p>面试题（Java8）：</p>
<p>题1： String str &#x3D;new String(“ab”) 会创建几个对象？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>javap -v StringNewTest.class</code> <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8D%E7%BC%96%E8%AF%91&spm=1001.2101.3001.7020">反编译</a>后， 部分片段如下：</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/20200528143739276.png" alt="在这里插入图片描述"></p>
<p>根据反编译后字节码分析：</p>
<ol>
<li>一个对象是：new关键字在堆空间创建的；</li>
<li>另一个对象是：字符串常量池中的对象”ab”。 （如果前后文中还有代码，并且已经有 ab 常量在常量池存在时，ab<br>将不再创建，因为在常量池只能存在一份相同的对象）</li>
</ol>
<p>结论是至多是2个对象。</p>
<p>题2：String str &#x3D;new String(“a”) + new String(“b”) 会创建几个对象 ?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javap -v StringNewTest.class 反编译后， 部分片段如下：</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/20200528143750392.png" alt="在这里插入图片描述"></p>
<p>根据反编译后字节码分析：</p>
<p>对象1： new StringBuilder()<br>对象2： new String(“a”)<br>对象3： 常量池中的”a”<br>对象4： new String(“b”)<br>对象5： 常量池中的”b”</p>
<p>深入剖析： StringBuilder 的 toString() 方法中有 new String(value, 0, count) ，<br>对象6 ：new String(“ab”)</p>
<p>Java11则又做了优化：</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240322143324561.png" alt="image-20240322143324561"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240322143417356.png" alt="image-20240322143417356"></p>
<p><strong>强调一下：</strong><br>StringBuilder 的 toString()<br>的调用，在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0&spm=1001.2101.3001.7020">字符串常量池</a>中，没有生成”ab”。<br>如果前后文中还有代码，并且已经常量在常量池存在时，相同的常量 将不再创建，因为在常量池只能存在一份相同的对象。</p>
<p>结论是至多是6个对象。</p>
<p>题3：String str &#x3D;“a”+ “b” 会创建几个对象 ?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javap -v StringNewTest.class 反编译后， 部分片段如下：</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/20200528144808867.png" alt="在这里插入图片描述"></p>
<p>“a” + “b” 在编译时，就已经编译为 ab， 被放到常量池中。<br>所以只有一个对象 ：ab</p>
<p>注意：<br>如果前后文中还有代码，并且已经有 ab 常量在常量池存在时，ab 将不再创建，因为在常量池只能存在一份相同的对象。</p>
<p><strong>字符串拼接操作的总结</strong></p>
<ul>
<li><strong>常量</strong> 与 <strong>常量</strong> 的拼接结果在 常量池，原理是 <strong>编译期</strong> 优化；</li>
<li>常量池 中不会存在相同内容的常量；</li>
<li>只要其中一个是变量，结果在堆中。 如： String s2 &#x3D; s1+”DEF” ;</li>
<li>变量拼接的原理 是StringBuilder 。</li>
<li>如果拼接的结果是调用 intern() 方法，则主动将常量池中 <strong>还没有的字符串</strong> 对象放入池中，并返回地址。</li>
</ul>
<h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>当将一个字符串与一个非字符串的值进行拼接时，后者会转换成字符串（任何一个Java对象都可以转换成字符串)。</p>
<p>字符串的+操作</p>
<ul>
<li>当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。</li>
<li>当连续进行+操作时，从左到右逐个执行的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;abc&quot;</span> + <span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="comment">//“3abc21”</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当+操作中出现了字符，会拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c + <span class="number">0</span>;</span><br><span class="line">System.out.println(result);<span class="comment">//97</span></span><br></pre></td></tr></table></figure>

<h3 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h3><p>String类没有提供修改字符串中某个字符的方法。</p>
<p>由于不能修改Java字符串中的单个字符，所以在Java文档中将String类对象称为是不可变的(immutable)<br>。不过，可以修改字符串变量，让它引用另外一个字符串。不可变字符串却有一个优点：编译器可以让字符串共享。</p>
<p>为了弄清具体的工作方式，可以想象将各种字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p>
<p>总而言之，Java的设计者认为共享带来的高效率远远胜过于提取子串、拼接字符串所带来的低效率。可以看看你自己的程序，我们发现：大多数情况下都不会修改字符串，而只是需要对字符串进行比较。</p>
<h3 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h3><p>可以使用equals方法检测两个字符串是否相等。对于表达式：<br><code>s.equals(t)</code><br>如果字符串s与字符串t相等，则返回true;否则，返回false。需要注意的是，s与t可以是字符串变量，也可以是字符串字面量。要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。</p>
<p>String字符串可以使用“<code>==</code>”和equals()方法比较。当两个字符串使用“<code>==</code><br>”进行比较时，比较的是两个字符串在内存中的地址。当两个字符串使用equals方法比较时，比较的是两个字符串的值是否相等。</p>
<h3 id="空串与Null串"><a href="#空串与Null串" class="headerlink" title="空串与Null串"></a>空串与Null串</h3><p>空串”是长度为0的字符串。可以调用以下代码检查一个字符串是否为空：<br>if (str.length()&#x3D;&#x3D;0)<br>或<br>if (str.equals(“”))<br>空串是一个Java对象，有自己的串长度(0)和内容（空）。不过，String变量还可以存放一个特殊的值，名为null,表示目前没有任何对象与该变量关联。要检查一个字符串是否为ull,要使用以下条件：<br>if (str &#x3D;&#x3D;null)<br>有时要检查一个字符串既不是null也不是空串，这种情况下就需要使用以下条件：<br>if (str !&#x3D;null &amp;&amp; str.length()!&#x3D;0)</p>
<h3 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h3><p>Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元。最常用的Unicode字符使用一个代码单元就可以表示，而辅助字符需要<code>一对</code><br>代码单元表示。</p>
<p><strong>所以代码单元指的是一个char字符，码点指的是实际的一个具有现实意义的字符。<br>我们可以这样认为：一个char字符我们可以称之为代码单元，一个Unicode字符我们称之为码点。</strong></p>
<p>例如，一个雪人字符（☃），是一个Unicode码点，也就是一个Unicode编码所代表的符号，在UTF-8中用3个代码单元表示，在UTF-16中用一个代码单元表示。</p>
<p>Length方法将返回采用UTF-16编码表示给定字符串所需要的代码单元数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//🍷Hello 需要7个char字符进行存储，其中🍷占两个</span></span><br><span class="line">String test=<span class="string">&quot;🍷Hello&quot;</span>;</span><br><span class="line"><span class="comment">//得到的是代码单元的数量 7 🍷占两个代码单元(两个char)</span></span><br><span class="line">System.out.println(test.length());</span><br></pre></td></tr></table></figure>

<p>要想得到实际的长度，即码点数量，可以调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.codePointCount用来计算字符串中的真实Unicode的数量，也就是码点数量</span></span><br><span class="line"><span class="comment">// 所以它的结果应该是6</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cpCount</span> <span class="operator">=</span> greeting.codePointCount(<span class="number">0</span>,greeting.length());</span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203154352729.png" alt="image-20240203154352729"></p>
<p>调用<code>charAt(n)</code>将返回位置n的代码单元。</p>
<p>要想得到第i个码点，应该使用下列语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> greeting.offsetByCodePoints(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">cp</span> <span class="operator">=</span> greeting.codePointAt(index);</span><br></pre></td></tr></table></figure>

<h4 id="遍历一个字符串"><a href="#遍历一个字符串" class="headerlink" title="遍历一个字符串"></a>遍历一个字符串</h4><p>对于<strong>有非常规字符的字符串</strong>，使用charAt来遍历会出现问题。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203154802146.png" alt="image-20240203154802146"></p>
<p>所以应当使用码点来遍历。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203155036396.png" alt="image-20240203155036396"></p>
<h4 id="将码点数组转为字符串"><a href="#将码点数组转为字符串" class="headerlink" title="将码点数组转为字符串"></a>将码点数组转为字符串</h4><p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203155135355.png" alt="image-20240203155135355"></p>
<h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><code>StringBuilder</code></h4><p><code>StringBuilder</code> 可以看成是一个容器，创建之后里面的内容是可变的。</p>
<p>当我们在拼接字符串和反转字符串的时候会使用到</p>
<p>在字符串构建完成时就调用<code>toString</code>方法，将可以得到一个String对象，其中包含了构建器中的字符序列。</p>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        <span class="comment">/*sb.append(1);</span></span><br><span class="line"><span class="comment">        sb.append(2.3);</span></span><br><span class="line"><span class="comment">        sb.append(true);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        sb.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        System.out.println(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//普及：</span></span><br><span class="line">        <span class="comment">//因为StringBuilder是Java已经写好的类</span></span><br><span class="line">        <span class="comment">//java在底层对他做了一些特殊处理。</span></span><br><span class="line">        <span class="comment">//打印对象不是地址值而是属性值。</span></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加字符串</span></span><br><span class="line">        sb.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot;bbb&quot;</span>).append(<span class="string">&quot;ccc&quot;</span>).append(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(sb);<span class="comment">//aaabbbcccddd</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.再把StringBuilder变回字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(str);<span class="comment">//aaabbbcccddd</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a><code>StringJoiner</code></h4><ul>
<li><code>StringJoiner</code>跟<code>StringBuilder</code>一样，也可以看成是一个容器，创建之后里面的内容是可变的。</li>
<li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。</li>
<li><code>JDK8</code>出现的</li>
</ul>
<p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个对象，并指定中间的间隔符号</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">sj.add(<span class="string">&quot;aaa&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="comment">//3.打印结果</span></span><br><span class="line">System.out.println(sj);<span class="comment">//aaa---bbb---ccc</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">sj.add(<span class="string">&quot;aaa&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sj.length();</span><br><span class="line">System.out.println(len);<span class="comment">//15</span></span><br><span class="line"><span class="comment">//3.打印</span></span><br><span class="line">System.out.println(sj);<span class="comment">//[aaa, bbb, ccc]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sj.toString();</span><br><span class="line">System.out.println(str);<span class="comment">//[aaa, bbb, ccc]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120163437797.png" alt="image-20240120163437797"></p>
<h3 id="关于字符串的小扩展："><a href="#关于字符串的小扩展：" class="headerlink" title="关于字符串的小扩展："></a>关于字符串的小扩展：</h3><ol>
<li><p>字符串存储的内存原理</p>
<p><code>String s = “abc”；</code>直接赋值</p>
<p>特点：</p>
<p> 此时字符串<code>abc</code>是存在字符串常量池中的。</p>
<p> 先检查字符串常量池中有没有字符串<code>abc</code>，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。</p>
<p>所以，直接赋值的方式，代码简单，而且节约内存。</p>
</li>
<li><p>new出来的字符串</p>
<p>看到new关键字，一定是在堆里面开辟了一个小空间。</p>
<p><code>String s1 = new String（“abc”）；</code></p>
<p><code>String s2 = “abc”；</code></p>
<p>s1记录的是<code>new</code>出来的，在堆里面的地址值。</p>
<p>s2是直接赋值的，所以记录的是字符串常量池中的地址值。</p>
</li>
<li><p><code>==</code>号比较的到底是什么？</p>
<p>如果比较的是基本数据类型：比的是具体的数值是否相等。</p>
<p>如果比较的是引用数据类型：比的是地址值是否相等。</p>
<p>结论：<code>==</code>只能用于比较基本数据类型。不能比较引用数据类型。</p>
</li>
</ol>
<p>4.字符串拼接</p>
<p>无变量参与：</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120163806844.png" alt="image-20240120163806844"></p>
<p>有变量参与：</p>
<p><code>Jdk8</code>以前</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120164134558.png" alt="image-20240120164134558"></p>
<p><code>Jdk8</code>以后，进行数组预估来拼接。</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/Snipaste_2024-01-20_16-42-47.png" alt="Snipaste_2024-01-20_16-42-47"></p>
<p>5.<code>StringBuilder</code>提高效率</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120164430231.png" alt="image-20240120164430231"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120164605992.png" alt="image-20240120164605992"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240120165838807.png" alt="image-20240120165838807"></p>
<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><p>前面已经看到，将输出打印到“标准输出流”（即控制台窗口）是一件非常容易的事情，只要调用System.out.println即可。然而，读取“标准输入流”System.in就没有那么简单了。<br>要想通过控制台进行输入，首先需要构造一个与“标准输入流”System.in关联的Scanner对象。<br>Scanner in &#x3D; new Scanner(System.in);</p>
<p>现在，就可以使用Scanner类的各种方法读取输入了。</p>
<p>例如：next() 与 nextLine()</p>
<p>next():</p>
<ul>
<li>一定要读取到有效字符后才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()：</p>
<ul>
<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>可以获得空白。</li>
</ul>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>Java 中的 <code>System.out.format();</code>和 <code>System.out.printf();</code>方法用于格式化输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用printf输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**关键技术点</span></span><br><span class="line"><span class="comment"> * 使用java.io.PrintStream的printf方法实现C风格的输出</span></span><br><span class="line"><span class="comment"> * printf 方法的第一个参数为输出的格式,第二个参数是可变长的,表示待输出的数据对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printf</span> &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              <span class="comment">/*** 输出字符串 ***/</span></span><br><span class="line">              <span class="comment">// %s表示输出字符串，也就是将后面的字符串替换模式中的%s</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%s&quot;</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1212</span>));</span><br><span class="line">              <span class="comment">// %n表示换行</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%s%n&quot;</span>, <span class="string">&quot;end line&quot;</span>);</span><br><span class="line">              <span class="comment">// 还可以支持多个参数</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%s = %s%n&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Zhangsan&quot;</span>);</span><br><span class="line">              <span class="comment">// %S将字符串以大写形式输出</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%S = %s%n&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Zhangsan&quot;</span>);</span><br><span class="line">              <span class="comment">// 支持多个参数时，可以在%s之间插入变量编号，1$表示第一个字符串，3$表示第3个字符串</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$s = %3$s %2$s%n&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;san&quot;</span>, <span class="string">&quot;Zhang&quot;</span>);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">/*** 输出boolean类型 ***/</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;true = %b; false = &quot;</span>, <span class="literal">true</span>);</span><br><span class="line">              System.out.printf(<span class="string">&quot;%b%n&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">              <span class="comment">/*** 输出整数类型***/</span></span><br><span class="line">              <span class="type">Integer</span> <span class="variable">iObj</span> <span class="operator">=</span> <span class="number">342</span>;</span><br><span class="line">              <span class="comment">// %d表示将整数格式化为10进制整数</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%d; %d; %d%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line">              <span class="comment">// %o表示将整数格式化为8进制整数</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%o; %o; %o%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line">              <span class="comment">// %x表示将整数格式化为16进制整数</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%x; %x; %x%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line">              <span class="comment">// %X表示将整数格式化为16进制整数，并且字母变成大写形式</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%X; %X; %X%n&quot;</span>, -<span class="number">500</span>, <span class="number">2343L</span>, iObj);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">/*** 输出浮点类型***/</span></span><br><span class="line">              <span class="type">Double</span> <span class="variable">dObj</span> <span class="operator">=</span> <span class="number">45.6d</span>;</span><br><span class="line">              <span class="comment">// %e表示以科学技术法输出浮点数</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%e; %e; %e%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line">              <span class="comment">// %E表示以科学技术法输出浮点数，并且为大写形式            </span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%E; %E; %E%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line">              <span class="comment">// %f表示以十进制格式化输出浮点数</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%f; %f; %f%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line">              <span class="comment">// 还可以限制小数点后的位数</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%.1f; %.3f; %f%n&quot;</span>, -<span class="number">756.403f</span>, <span class="number">7464.232641d</span>, dObj);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">/*** 输出日期类型***/</span></span><br><span class="line">              <span class="comment">// %t表示格式化日期时间类型，%T是时间日期的大写形式，在%t之后用特定的字母表示不同的输出格式</span></span><br><span class="line">              <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">              <span class="type">long</span> <span class="variable">dataL</span> <span class="operator">=</span> date.getTime();</span><br><span class="line">              <span class="comment">// 格式化年月日</span></span><br><span class="line">              <span class="comment">// %t之后用y表示输出日期的年份（2位数的年，如99）</span></span><br><span class="line">              <span class="comment">// %t之后用m表示输出日期的月份，%t之后用d表示输出日期的日号</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n&quot;</span>, date, dataL);</span><br><span class="line">              <span class="comment">// %t之后用Y表示输出日期的年份（4位数的年），</span></span><br><span class="line">              <span class="comment">// %t之后用B表示输出日期的月份的完整名， %t之后用b表示输出日期的月份的简称</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n&quot;</span>, date, dataL);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">// 以下是常见的日期组合</span></span><br><span class="line">              <span class="comment">// %t之后用D表示以 &quot;%tm/%td/%ty&quot;格式化日期</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tD%n&quot;</span>, date);</span><br><span class="line">              <span class="comment">//%t之后用F表示以&quot;%tY-%tm-%td&quot;格式化日期</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tF%n&quot;</span>, date);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">/*** 输出时间类型***/</span></span><br><span class="line">              <span class="comment">// 输出时分秒</span></span><br><span class="line">              <span class="comment">// %t之后用H表示输出时间的时（24进制），%t之后用I表示输出时间的时（12进制），</span></span><br><span class="line">              <span class="comment">// %t之后用M表示输出时间的分，%t之后用S表示输出时间的秒</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n&quot;</span>, date, dataL);</span><br><span class="line">              <span class="comment">// %t之后用L表示输出时间的秒中的毫秒</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tH:%1$tM:%1$tS %1$tL%n&quot;</span>, date);</span><br><span class="line">              <span class="comment">// %t之后p表示输出时间的上午或下午信息</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tH:%1$tM:%1$tS %1$tL %1$tp%n&quot;</span>, date);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">// 以下是常见的时间组合</span></span><br><span class="line">              <span class="comment">// %t之后用R表示以&quot;%tH:%tM&quot;格式化时间</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tR%n&quot;</span>, date);</span><br><span class="line">              <span class="comment">// %t之后用T表示以&quot;%tH:%tM:%tS&quot;格式化时间</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tT%n&quot;</span>, date);</span><br><span class="line">              <span class="comment">// %t之后用r表示以&quot;%tI:%tM:%tS %Tp&quot;格式化时间</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tr%n&quot;</span>, date);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">/*** 输出星期***/</span></span><br><span class="line">              <span class="comment">// %t之后用A表示得到星期几的全称</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tF %1$tA%n&quot;</span>, date);</span><br><span class="line">              <span class="comment">// %t之后用a表示得到星期几的简称</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tF %1$ta%n&quot;</span>, date);</span><br><span class="line">             </span><br><span class="line">              <span class="comment">// 输出时间日期的完整信息</span></span><br><span class="line">              System.out.printf(<span class="string">&quot;%1$tc%n&quot;</span>, date);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *printf方法中,格式为&quot;%s&quot;表示以字符串的形式输出第二个可变长参数的第一个参数值;</span></span><br><span class="line"><span class="comment"> *格式为&quot;%n&quot;表示换行;格式为&quot;%S&quot;表示将字符串以大写形式输出;在&quot;%s&quot;之间用&quot;n$&quot;表示</span></span><br><span class="line"><span class="comment"> *输出可变长参数的第n个参数值.格式为&quot;%b&quot;表示以布尔值的形式输出第二个可变长参数</span></span><br><span class="line"><span class="comment"> *的第一个参数值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式为&quot;%d&quot;表示以十进制整数形式输出;&quot;%o&quot;表示以八进制形式输出;&quot;%x&quot;表示以十六进制</span></span><br><span class="line"><span class="comment"> * 输出;&quot;%X&quot;表示以十六进制输出,并且将字母(A、B、C、D、E、F)换成大写.格式为&quot;%e&quot;表</span></span><br><span class="line"><span class="comment"> * 以科学计数法输出浮点数;格式为&quot;%E&quot;表示以科学计数法输出浮点数,而且将e大写;格式为</span></span><br><span class="line"><span class="comment"> * &quot;%f&quot;表示以十进制浮点数输出,在&quot;%f&quot;之间加上&quot;.n&quot;表示输出时保留小数点后面n位.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式为&quot;%t&quot;表示输出时间日期类型.&quot;%t&quot;之后用y表示输出日期的二位数的年份(如99)、用m</span></span><br><span class="line"><span class="comment"> * 表示输出日期的月份,用d表示输出日期的日号;&quot;%t&quot;之后用Y表示输出日期的四位数的年份</span></span><br><span class="line"><span class="comment"> * (如1999)、用B表示输出日期的月份的完整名,用b表示输出日期的月份的简称.&quot;%t&quot;之后用D</span></span><br><span class="line"><span class="comment"> * 表示以&quot;%tm/%td/%ty&quot;的格式输出日期、用F表示以&quot;%tY-%tm-%td&quot;的格式输出日期.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;%t&quot;之后用H表示输出时间的时(24进制),用I表示输出时间的时(12进制),用M表示输出时间</span></span><br><span class="line"><span class="comment"> * 分,用S表示输出时间的秒,用L表示输出时间的秒中的毫秒数、用 p 表示输出时间的是上午还是</span></span><br><span class="line"><span class="comment"> * 下午.&quot;%t&quot;之后用R表示以&quot;%tH:%tM&quot;的格式输出时间、用T表示以&quot;%tH:%tM:%tS&quot;的格式输出</span></span><br><span class="line"><span class="comment"> * 时间、用r表示以&quot;%tI:%tM:%tS %Tp&quot;的格式输出时间.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;%t&quot;之后用A表示输出日期的全称,用a表示输出日期的星期简称.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1212end <span class="type">line</span></span><br><span class="line"><span class="variable">Name</span> <span class="operator">=</span> <span class="type">Zhangsan</span></span><br><span class="line"><span class="variable">NAME</span> <span class="operator">=</span> <span class="type">Zhangsan</span></span><br><span class="line"><span class="variable">Name</span> <span class="operator">=</span> Zhang <span class="type">san</span></span><br><span class="line"><span class="variable">true</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="literal">false</span> = <span class="literal">false</span></span><br><span class="line">-<span class="number">500</span>; <span class="number">2343</span>; <span class="number">342</span></span><br><span class="line"><span class="number">37777777014</span>; <span class="number">4447</span>; <span class="number">526</span></span><br><span class="line">fffffe0c; <span class="number">927</span>; <span class="number">156</span></span><br><span class="line">FFFFFE0C; <span class="number">927</span>; <span class="number">156</span></span><br><span class="line">-<span class="number">7.564030e+02</span>; <span class="number">7.464233e+03</span>; <span class="number">4.560000e+01</span></span><br><span class="line">-<span class="number">7.564030E+02</span>; <span class="number">7.464233E+03</span>; <span class="number">4.560000E+01</span></span><br><span class="line">-<span class="number">756.403015</span>; <span class="number">7464.232641</span>; <span class="number">45.600000</span></span><br><span class="line">-<span class="number">756.4</span>; <span class="number">7464.233</span>; <span class="number">45.600000</span></span><br><span class="line"><span class="number">24</span>-<span class="number">02</span>-<span class="number">03</span>; <span class="number">24</span>-<span class="number">02</span>-<span class="number">03</span></span><br><span class="line"><span class="number">2024</span>-二月-<span class="number">03</span>; <span class="number">2024</span>-<span class="number">2</span>月-<span class="number">03</span></span><br><span class="line"><span class="number">02</span>/<span class="number">03</span>/<span class="number">24</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">02</span>-<span class="number">03</span></span><br><span class="line"><span class="number">16</span>:<span class="number">24</span>:<span class="number">00</span>; <span class="number">04</span>:<span class="number">24</span>:<span class="number">00</span></span><br><span class="line"><span class="number">16</span>:<span class="number">24</span>:<span class="number">00</span> <span class="number">968</span></span><br><span class="line"><span class="number">16</span>:<span class="number">24</span>:<span class="number">00</span> <span class="number">968</span> 下午</span><br><span class="line"><span class="number">16</span>:<span class="number">24</span></span><br><span class="line"><span class="number">16</span>:<span class="number">24</span>:<span class="number">00</span></span><br><span class="line"><span class="number">04</span>:<span class="number">24</span>:<span class="number">00</span> 下午</span><br><span class="line"><span class="number">2024</span>-<span class="number">02</span>-<span class="number">03</span> 星期六</span><br><span class="line"><span class="number">2024</span>-<span class="number">02</span>-<span class="number">03</span> 周六</span><br><span class="line">周六 <span class="number">2</span>月 <span class="number">03</span> <span class="number">16</span>:<span class="number">24</span>:<span class="number">00</span> CST <span class="number">2024</span></span><br></pre></td></tr></table></figure>

<p>或者是使用<code>String.format()</code>创建格式化字符串但不输出。</p>
<p>格式说明符语法图：</p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240203162901499.png" alt="image-20240203162901499"></p>
<h3 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h3><p>要想读取一个文件，需要构造一个Scanner对象：</p>
<p><code>Scanner in = new Scanner(Path.of(&quot;myfile.txt&quot;),StandardCharsets.UTF_8);</code></p>
<p>要想写入文件，就需要构造一个PrintWriter对象。在构造器(constructor)中，需要提供文件名和字符编码：</p>
<p><code>PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;,StandardCharsets.UTF 8);</code></p>
<h3 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h3><h4 id="一，键盘录入方法："><a href="#一，键盘录入方法：" class="headerlink" title="一，键盘录入方法："></a>一，键盘录入方法：</h4><p>​    <code>next（）</code>、<code>nextLine（）</code>、<code>nextInt（）</code>、<code>nextDouble（）</code>。</p>
<p>1）<code>next（）</code>、<code>nextLine（）</code>：</p>
<p>可以接受任意数据，但是都会返回一个字符串。</p>
<p>比如：键盘录入<code>abc</code>，那么会把<code>abc</code>看做字符串返回。</p>
<p> 键盘录入<code>123</code>，那么会把<code>123</code>看做字符串返回。</p>
<p>2）<code>nextInt（）</code>：</p>
<p> 只能接受整数。</p>
<p>比如：键盘录入123，那么会把123当做<code>int</code>类型的整数返回。</p>
<p> 键盘录入小数或者其他字母，就会报错。</p>
<p>3）<code>nextDouble（）</code>：</p>
<p> 能接收整数和小数，但是都会看做小数返回。</p>
<p> 录入字母会报错。</p>
<h4 id="二，方法底层细节-："><a href="#二，方法底层细节-：" class="headerlink" title="二，方法底层细节 ："></a>二，方法底层细节 ：</h4><p>第一个细节：</p>
<p><code>next（），nextInt（），nextDouble（）</code>在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">System.out.println(d);</span><br><span class="line"><span class="comment">//键盘录入：1.1 2.2//注意录入的时候1.1和2.2之间加空格隔开。</span></span><br><span class="line"><span class="comment">//此时控制台打印1.1</span></span><br><span class="line"><span class="comment">//表示nextDouble方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">//键盘录入：1 2//注意录入的时候1和2之间加空格隔开。</span></span><br><span class="line"><span class="comment">//此时控制台打印1</span></span><br><span class="line"><span class="comment">//表示nextInt方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">//键盘录入：a b//注意录入的时候a和b之间加空格隔开。</span></span><br><span class="line"><span class="comment">//此时控制台打印a</span></span><br><span class="line"><span class="comment">//表示next方法在接收数据的时候，遇到空格就停止了，后面的本次不接收。</span></span><br></pre></td></tr></table></figure>

<p>第二个细节：</p>
<p><code>next（），nextInt（），nextDouble（）</code>在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据。但是这些符号 +<br>后面的数据还在内存中并没有接收。如果后面还有其他键盘录入的方法，会自动将这些数据接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sc.next();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"><span class="comment">//此时值键盘录入一次a b(注意a和b之间用空格隔开)</span></span><br><span class="line"><span class="comment">//那么第一个next();会接收a，a后面是空格，那么就停止，所以打印s1是a</span></span><br><span class="line"><span class="comment">//但是空格+b还在内存中。</span></span><br><span class="line"><span class="comment">//第二个next会去掉前面的空格，只接收b</span></span><br><span class="line"><span class="comment">//所以第二个s2打印出来是b</span></span><br></pre></td></tr></table></figure>

<p>第三个细节：</p>
<p><code>nextLine（）</code>方法是把一整行全部接收完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(s);</span><br><span class="line"><span class="comment">//键盘录入a b(注意a和b之间用空格隔开)</span></span><br><span class="line"><span class="comment">//那么nextLine不会过滤前面和后面的空格，会把这一整行数据全部接收完毕。</span></span><br></pre></td></tr></table></figure>

<h4 id="三、混用引起的后果"><a href="#三、混用引起的后果" class="headerlink" title="三、混用引起的后果"></a>三、混用引起的后果</h4><p>上面说的两套键盘录入不能混用，如果混用会有严重的后果。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//①</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//②</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();<span class="comment">//③</span></span><br><span class="line">System.out.println(i);<span class="comment">//④</span></span><br><span class="line">System.out.println(s);<span class="comment">//⑤</span></span><br></pre></td></tr></table></figure>

<p>当代码运行到第二行，会让我们键盘录入，此时录入123。</p>
<p>但是实际上我们录的是123+回车。</p>
<p>而<code>nextInt</code>是遇到空格，回车，制表符都会停止。</p>
<p>所以<code>nextInt</code>只能接受123，回车还在内存中没有被接收。</p>
<p>此时就被<code>nextLine</code>接收了。</p>
<p>所以，如果混用就会导致<code>nextLine</code>接收不到数据。</p>
<h4 id="四、结论（如何使用）"><a href="#四、结论（如何使用）" class="headerlink" title="四、结论（如何使用）"></a>四、结论（如何使用）</h4><p>键盘录入分为两套：</p>
<ul>
<li><code>next（）、nextInt（）、nextDouble（）</code>这三个配套使用。</li>
</ul>
<p>如果用了这三个其中一个，就不要用<code>nextLine（）</code>。</p>
<ul>
<li><code>nextLine（）</code>单独使用。</li>
</ul>
<p>如果想要整数，那么先接收，再使用<code>Integer.parseInt</code>进行类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();<span class="comment">//键盘录入123</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为字符串&quot;</span> + s);<span class="comment">//此时123是字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//键盘录入123</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为整数：&quot;</span> + i);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();<span class="comment">//键盘录入123</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为字符串&quot;</span> + s);<span class="comment">//此时123是字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(s);<span class="comment">//想要整数再进行转换</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为整数：&quot;</span> + i);</span><br></pre></td></tr></table></figure>

<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>在深入学习控制结构之前，需要了解块(block)的概念。</p>
<p>块（即复合语句）是指由若干条Java语句组成的语句，并用一对大括号括起来。块确定了变量的作用域。一个块可以嵌套在另一个块中。</p>
<p>但是，不能在嵌套的两个块中声明同名的变量。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在Java中，条件语句的形式为<br>if (condition){<br>statement<br>}</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="不确定循环"><a href="#不确定循环" class="headerlink" title="不确定循环"></a>不确定循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">  <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure>

<h4 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强 for 循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重选择：switch语句"><a href="#多重选择：switch语句" class="headerlink" title="多重选择：switch语句"></a>多重选择：switch语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :       </span><br><span class="line">    <span class="comment">//语句       </span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//可选   </span></span><br><span class="line">    <span class="keyword">case</span> value :       </span><br><span class="line">    <span class="comment">//语句       </span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//可选    </span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句    </span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选       </span></span><br><span class="line">    <span class="comment">//语句 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch的扩展知识"><a href="#switch的扩展知识" class="headerlink" title="switch的扩展知识"></a>switch的扩展知识</h4><ul>
<li><p>default的位置和省略情况</p>
<p>default可以放在任意位置，也可以省略</p>
</li>
<li><p>case穿透</p>
<p>不写break会引发case穿透现象</p>
</li>
<li><p>switch在JDK12的新特性</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">&quot;一&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">&quot;二&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch和if第三种格式各自的使用场景</li>
</ul>
<p>当我们需要对一个范围进行判断的时候，用if的第三种格式</p>
<p>当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句</p>
<h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中两个很有用的类：<code>BigInteger</code>和<code>BigDecimal</code><br>。这两个类可以处理包含任意长度数字序列的数值。<code>BigInteger</code>类实现任意精度的整数运算，<code>BigDecimal</code>实现任意精度的浮点数运算。</p>
<p>遗憾的是，不能使用人们熟悉的算术运算符（如：<code>+</code>和<code>*</code>）处理大数，而需要使用大数类中的add和multiply方法。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标(index,或称索引)<br>可以访问数组中的每一个值。例如，如果a是一个整型数组，a[i]就是数组中下标为i的整数。<br>在声明数组变量时，需要指出数组类型（数据元素类型紧跟[]）和数组变量的名字。下<br>面声明了整型数组a:<br>int[] a;<br>不过，这条语句只声明了变量a,并没有将a初始化为一个真正的数组。应该使用new操<br>作符创建数组。<br><code>int[] a = new int[100];//or var a new int[100];</code><br>这条语句声明并初始化了一个可以存储100个整数的数组。<br>数组长度不要求是常量：new int[n]会创建一个长度为n的数组。<br>一旦创建了数组，就不能再改变它的长度（不过，当然可以改变单个的数组元素）。如果程序运行中需要经常扩展数组的大小，就应该使用另一种数据结构一数组列表(<br>array list)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注释：可以使用下面两种形式定义一个数组变量：</span><br><span class="line"><span class="type">int</span>[]a;</span><br><span class="line">或</span><br><span class="line"><span class="type">int</span> a[];</span><br><span class="line">大多数Java应用程序员喜欢使用第一种风格，因为它可以将类型<span class="type">int</span>[们（整型数组)与变量名清晰地分开。</span><br></pre></td></tr></table></figure>

<h3 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h3><h4 id="完整格式"><a href="#完整格式" class="headerlink" title="完整格式"></a>完整格式</h4><p> 数据类型[] 数组名 &#x3D; new 数据类型[]{元素1，元素2，元素3，元素4…};</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br><span class="line"><span class="type">double</span>[] arr = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="格式详解"><a href="#格式详解" class="headerlink" title="格式详解"></a>格式详解</h4><p> 数据类型：限定了数组以后能存什么类型的数据。</p>
<p> 方括号：表示现在定义的是一个数组。</p>
<p> 数组名：其实就是名字而已，方便以后使用，在起名字的时候遵循小驼峰命名法。</p>
<p> new：就是给数组在内存中开辟了一个<code>空间</code>。</p>
<p> 数据类型：限定了数组以后能存什么类型的数据。 前面和后面的数据类型一定要保持一致。</p>
<p> 方括号：表示现在定义的是一个数组。</p>
<p> 大括号：表示数组里面的元素。元素也就是存入到数组中的数据。多个元素之间，一定要用逗号隔开。</p>
<h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>等号前后的数据类型必须保持一致。</li>
<li>数组一旦创建之后，长度不能发生变化。</li>
</ul>
<h4 id="简化格式"><a href="#简化格式" class="headerlink" title="简化格式"></a>简化格式</h4><p> 数据类型[] 数组名 &#x3D; {元素1，元素2，元素3，元素4…};</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span>[] array = &#123;<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数组的动态初始化"><a href="#数组的动态初始化" class="headerlink" title="数组的动态初始化"></a>数组的动态初始化</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>数据类型[] 数组名 &#x3D; new 数据类型[数组的长度];<br>然后对每一个位置array[i]&#x3D;x；进行赋值</p>
<h4 id="数组的默认初始化值"><a href="#数组的默认初始化值" class="headerlink" title="数组的默认初始化值"></a>数组的默认初始化值</h4><p>在动态定义数组时，<code>Java</code>会对每一种类型进行默认初始化。</p>
<p>整数类型：0</p>
<p>小数类型：0.0</p>
<p>布尔类型：false</p>
<p>字符类型：’\u0000’</p>
<p>引用类型：null</p>
<h3 id="数组两种初始化方式的区别"><a href="#数组两种初始化方式的区别" class="headerlink" title="数组两种初始化方式的区别"></a>数组两种初始化方式的区别</h3><p>静态初始化：int[] arr &#x3D; {1,2,3,4,5};</p>
<p>动态初始化：int[] arr &#x3D; new int[3];</p>
<p>静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。</p>
<p>动态初始化：手动指定数组长度，由系统给出默认初始化值。</p>
<h3 id="数组常见问题"><a href="#数组常见问题" class="headerlink" title="数组常见问题"></a>数组常见问题</h3><p>当访问了数组中不存在的索引，就会引发索引越界异常。</p>
<p> 针对于任意一个数组，索引的范围：<br>最小索引：0<br>最大索引：数组名.length - 1</p>
<h3 id="地址值"><a href="#地址值" class="headerlink" title="地址值"></a>地址值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(arr);<span class="comment">//[I@6d03e736</span></span><br></pre></td></tr></table></figure>

<p>打印数组的时候，实际出现的是数组的地址值。</p>
<p>数组的地址值：就表示数组在内存中的位置。</p>
<p>以[I@6d03e736为例：</p>
<p>[ ：表示现在打印的是一个数组。</p>
<p>I：表示现在打印的数组是int类型的。</p>
<p>@：仅仅是一个间隔符号而已。</p>
<p>6d03e736：就是数组在内存中真正的地址值。（十六进制的）</p>
<p>但是，我们习惯性会把[I@6d03e736这个整体称之为数组的地址值。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="两个数组指向不同空间的内存"><a href="#两个数组指向不同空间的内存" class="headerlink" title="两个数组指向不同空间的内存"></a>两个数组指向不同空间的内存</h4><p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106153754590.png" alt="image-20240106153754590"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106153911619.png" alt="image-20240106153911619"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240106155051708.png" alt="image-20240106155051708"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/NeiCun.gif" alt="NeiCun"></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/NeiCun2.gif" alt="NeiCun2"></p>
<p>1.只要是new出来的一定是在堆里面开辟了一个小空间<br>2.如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据</p>
<h4 id="两个数组指向同一个空间的内存"><a href="#两个数组指向同一个空间的内存" class="headerlink" title="两个数组指向同一个空间的内存"></a>两个数组指向同一个空间的内存</h4><p><img src="/2024/01/03/Little-knowledge-of-Java-1/NeiCun3.gif" alt="NeiCun3"></p>
<p>当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。</p>
<h3 id="数组访问"><a href="#数组访问" class="headerlink" title="数组访问"></a>数组访问</h3><p>可以直接访问、for循环访问或是for each循环访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，for each循环语句显得更加简洁、更不易出错，因为你不必为下标的起始值和终止值而操心。</p>
<blockquote>
<p>注释：for each循环语句的循环变量将会遍历数组中的每个元素，而不是下标值。</p>
</blockquote>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p>浅拷贝：直接进行地址值复制。</p>
<p>深拷贝：使用Arrays类的copyof方法或是其他方法。</p>
<p><code>Arrays.copyOf</code>(T[] original,int newLength )：拷贝数组，其内部调用了System.arrayCopy()方法，从下标0开始，如果超过原数组长度，会用null进行填充。</p>
<p><code>Integer[] arr2 = Arrays.copyOf(arr, 3);</code></p>
<p><code>System.arraycopy</code>使用的基本定义<br>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)<br>src:源数组;<br>srcPos:源数组要复制的起始位置;<br>dest:目的数组;<br>destPos:目的数组放置的起始位置;<br>length:复制的长度</p>
<p><code>System.arraycopy(arr,0,arr2,1,3);</code></p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>要想对数值型数组进行排序，可以使用Arrays类中的sort方法：</p>
<p><code>Arrays.sort(a);</code><br>这个方法使用了优化的快速排序（QuickSort)算法。快速排序算法对于大多数数据集合<br>来说都是效率比较高的。Arrays类还提供了另外一些很便捷的方法，在这一节最后的API注<br>释中将介绍这些方法。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>&#x2F;&#x2F; 在定义时初始化<br><code>type[][] arrayName = new type[][]&#123;值 1,值 2,值 3,…,值 n&#125;;</code><br><code>type[][] arrayName = new type[][]&#123;&#123;值 1,值 2,值 3,…,值 n&#125;,…,&#123;值 1,值 2,值 3,…,值 n&#125;&#125;;</code><br>&#x2F;&#x2F; 给定空间，在赋值<br><code>type[][] arrayName = new type[size1][size2];</code></p>
<h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><p>&#x2F;&#x2F; 数组第二维长度为空，可变化<br><code>type[][] arrayName = new type[size][];</code></p>
<p><img src="/2024/01/03/Little-knowledge-of-Java-1/image-20240119104812792.png" alt="image-20240119104812792"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://alsl521.github.io">kyl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://alsl521.github.io/2024/01/03/Little-knowledge-of-Java-1/">https://alsl521.github.io/2024/01/03/Little-knowledge-of-Java-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://alsl521.github.io" target="_blank">kyl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/12/25/Django-HouDuan02/" title="Django实战-2-实现模型选择与地图服务自动发布"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Django实战-2-实现模型选择与地图服务自动发布</div></div><div class="info-2"><div class="info-item-1">项目架构目前的项目主要分为以下几部分：  DatabaseContent：主要负责有关数据库的相关操作。 MapService：主要负责有关GeoServer地图服务的相关操作。 MapService：主要负责有关GeoServer地图服务的相关操作。 PublicServices：Web服务的主要入口文件，负责解析请求信息并进行分发任务。 Utils：将部分常用的功能进行封装，减轻代码编写的工作量。 目前后端只有两个方法，一个是返回已选择模型的菜单selectModels，另一个是处理用户上传的数据upLoadFiles&#96; 返回结果封装由于所有的内容都需要返回值，因此我参照所学内容在该项目中也新建了一个Result文件，用于封装最后的返回值和结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Result:   ...</div></div></div></a><a class="pagination-related" href="/2024/01/06/Little-knowledge-of-Java-2/" title="Java学习（二）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java学习（二）</div></div><div class="info-2"><div class="info-item-1">对象与类面向对象程序设计概述面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。 类类(class)是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的模具，将对象想象为小甜饼。由类构造(construct)对象的过程称为创建类的实例(instance)。 封装(encapsulation),有时称为数据隐藏)是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。对象中的数据称为实例字段(instance...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/01/20/Little-knowledge-of-Java-4/" title="Java学习（四）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-20</div><div class="info-item-2">Java学习（四）</div></div><div class="info-2"><div class="info-item-1">接口接口( interface)，接口用来描述类应该做什么，而不指定它们具体应该如何做。一个类可以实现(implement ) 一个或多个接口。有些悄况可能要求符合这些接口，只要有这种要求，就可以使用实现了这个接口的类（即实现类）的对象。 官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 接口的概念在Java 程序设计语言中，接口不是类，而是对希望符合这个接口的类的一组需求。 接口中的所有方法都自动是public 方法。因此，在接口中声明方法时，不必提供关键字public 。不过，在实现接口时，必须把方法声明为public; 否则，编译器将认为这个方法的访问属性是包可见性，这是类的默认访问属性，之后编译器就会报错，指出你试图提供更严格的访问权限。 1234567//接口的定义格式：interface 接口名称&#123;    // 抽象方法&#125;// 接口的声明：interface//...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-4/" title="Java学习-SSM-4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-4</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-3/" title="Java学习-SSM-3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-3</div></div><div class="info-2"><div class="info-item-1">AOP简介前面我们在介绍Spring的时候说过，Spring有两个核心的概念，一个是IOC/DI，一个是AOP。 前面已经对IOC/DI进行了系统的学习，接下来要学习它的另一个核心内容，就是AOP。 对于AOP,我们前面提过一句话是:AOP是在不改原有代码的前提下对其进行增强。 对于下面的内容，我们主要就是围绕着这一句话进行展开学习，主要学习两方面内容AOP核心概念,AOP作用: 什么是AOP? AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。 OOP(Object Oriented...</div></div></div></a><a class="pagination-related" href="/2024/01/19/Little-knowledge-of-Java-3/" title="Java学习（三）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-19</div><div class="info-item-2">Java学习（三）</div></div><div class="info-2"><div class="info-item-1">Object:所有类的超类Object类是Java中所有类的始祖，在Java中每个类都扩展了Object。 可以使用Object类型的变量引用任何类型的对象。    修饰符和类型 方法 说明    protected native Object clone() 创建并返回该对象的副本。   public boolean equals(Object obj) 指示某个其他对象是否“等于”此对象。   protected void finalize() 当垃圾收集确定不再有对该对象的引用时，由该对象的垃圾收集器调用。   public final native Class&lt;?&gt;  getClass() 返回 this 的运行时类Object。   public native int hashCode() 返回对象的哈希码值。   public final native void notify() 唤醒正在该对象的监视器上等待的单个线程。   public final native void notifyAll() 唤醒在此对象监视器上等待的所有线程。   public...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-5/" title="Java学习-SSM-5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-5</div></div><div class="info-2"><div class="info-item-1">今日内容   完成SSM的整合开发 能够理解并实现统一结果封装与统一异常处理 能够完成前后台功能整合开发 掌握拦截器的编写   SSM整合前面我们已经把Mybatis、Spring和SpringMVC三个框架进行了学习，今天主要的内容就是把这三个框架整合在一起完成我们的业务功能开发，具体如何来整合，我们一步步来学习。 流程分析(1) 创建工程  创建一个Maven的web工程 pom.xml添加SSM需要的依赖jar包 编写Web项目的入口配置类，实现AbstractAnnotationConfigDispatcherServletInitializer重写以下方法 getRootConfigClasses()    ：返回Spring的配置类-&gt;需要SpringConfig配置类 getServletConfigClasses() ：返回SpringMVC的配置类-&gt;需要SpringMvcConfig配置类 getServletMappings()      : 设置SpringMVC请求拦截路径规则 getServletFilters()      ...</div></div></div></a><a class="pagination-related" href="/2024/01/06/Little-knowledge-of-Java-2/" title="Java学习（二）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="info-item-2">Java学习（二）</div></div><div class="info-2"><div class="info-item-1">对象与类面向对象程序设计概述面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。 类类(class)是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的模具，将对象想象为小甜饼。由类构造(construct)对象的过程称为创建类的实例(instance)。 封装(encapsulation),有时称为数据隐藏)是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。对象中的数据称为实例字段(instance...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kyl</div><div class="author-info-description">用于记录平时学习的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/alsl521" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:852970167@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%B8%89%E5%A4%A7%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.</span> <span class="toc-text">Java三大平台</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaSE"><span class="toc-number">1.1.</span> <span class="toc-text">JavaSE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaME"><span class="toc-number">1.2.</span> <span class="toc-text">JavaME</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaEE"><span class="toc-number">1.3.</span> <span class="toc-text">JavaEE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">Java的主要特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">Java语言跨平台的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.5.1.</span> <span class="toc-text">编译型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.5.2.</span> <span class="toc-text">解释型语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JRE%E5%92%8CJDK"><span class="toc-number">1.6.</span> <span class="toc-text">JRE和JDK</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Java"><span class="toc-number">2.</span> <span class="toc-text">认识Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main"><span class="toc-number">2.1.</span> <span class="toc-text">main</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">Java特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98"><span class="toc-number">2.3.</span> <span class="toc-text">Java内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Java的基本程序设计结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">3.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%85%AB%E7%A7%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本数据类型的四类八种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unicode%E5%92%8Cchar%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">Unicode和char类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ASCII%E7%A0%81"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">ASCII码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unicode"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unicode-%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">Unicode 编码方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UTF"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">UTF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UTF-16"><span class="toc-number">3.2.2.5.1.</span> <span class="toc-text">UTF-16</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UTF-8"><span class="toc-number">3.2.2.5.2.</span> <span class="toc-text">UTF-8</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84char%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.5.3.</span> <span class="toc-text">Java中的char类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">变量与常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">3.3.3.</span> <span class="toc-text">变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.3.4.</span> <span class="toc-text">变量初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">变量的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F%E7%AD%89%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%89"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">标识符（类、变量等的名称）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">小驼峰命名法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">大驼峰命名法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.3.5.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.6.</span> <span class="toc-text">枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.2.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.3.</span> <span class="toc-text">扩展赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.4.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.5.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.6.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.7.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%BA%A7%E5%88%AB"><span class="toc-number">3.4.8.</span> <span class="toc-text">运算级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%88%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87%EF%BC%8C%E5%89%8D%E9%9D%A2%E8%A1%A50%EF%BC%89"><span class="toc-number">3.4.9.</span> <span class="toc-text">隐式转换（自动类型提升，前面补0）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">3.4.9.1.</span> <span class="toc-text">什么时候转换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%991"><span class="toc-number">3.4.9.2.</span> <span class="toc-text">转换规则1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%992"><span class="toc-number">3.4.9.3.</span> <span class="toc-text">转换规则2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%89%8D%E9%9D%A2%E5%8E%BB0%EF%BC%89"><span class="toc-number">3.4.10.</span> <span class="toc-text">强制数据转换（前面去0）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5"><span class="toc-number">3.4.11.</span> <span class="toc-text">截尾和舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81"><span class="toc-number">3.4.12.</span> <span class="toc-text">原码、反码、补码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AF%86"><span class="toc-number">3.4.12.1.</span> <span class="toc-text">前提知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81"><span class="toc-number">3.4.12.2.</span> <span class="toc-text">原码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81"><span class="toc-number">3.4.12.3.</span> <span class="toc-text">反码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81"><span class="toc-number">3.4.12.4.</span> <span class="toc-text">补码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.12.5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81-1"><span class="toc-number">3.4.12.5.1.</span> <span class="toc-text">原码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">3.4.12.5.2.</span> <span class="toc-text">原码的弊端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">3.4.12.5.3.</span> <span class="toc-text">反码出现的目的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">3.4.12.5.4.</span> <span class="toc-text">反码的计算规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">3.4.12.5.5.</span> <span class="toc-text">反码的弊端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">3.4.12.5.6.</span> <span class="toc-text">补码出现的目的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">3.4.12.5.7.</span> <span class="toc-text">补码的计算规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.4.12.5.8.</span> <span class="toc-text">补码的注意点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.5.1.</span> <span class="toc-text">String类的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">String类的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.3.</span> <span class="toc-text">创建字符串对象两种方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5"><span class="toc-number">3.5.4.</span> <span class="toc-text">拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.5.</span> <span class="toc-text">不可变字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">3.5.6.</span> <span class="toc-text">检测字符串是否相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E4%B8%B2%E4%B8%8ENull%E4%B8%B2"><span class="toc-number">3.5.7.</span> <span class="toc-text">空串与Null串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%81%E7%82%B9%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83"><span class="toc-number">3.5.8.</span> <span class="toc-text">码点与代码单元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.8.1.</span> <span class="toc-text">遍历一个字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%A0%81%E7%82%B9%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.8.2.</span> <span class="toc-text">将码点数组转为字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.9.</span> <span class="toc-text">构建字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder"><span class="toc-number">3.5.9.1.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.9.1.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">3.5.9.1.2.</span> <span class="toc-text">链式编程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringJoiner"><span class="toc-number">3.5.9.2.</span> <span class="toc-text">StringJoiner</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B0%8F%E6%89%A9%E5%B1%95%EF%BC%9A"><span class="toc-number">3.5.10.</span> <span class="toc-text">关于字符串的小扩展：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">3.6.</span> <span class="toc-text">输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="toc-number">3.6.1.</span> <span class="toc-text">读取输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">3.6.2.</span> <span class="toc-text">格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">3.6.3.</span> <span class="toc-text">文件输入与输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5"><span class="toc-number">3.6.4.</span> <span class="toc-text">键盘录入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">一，键盘录入方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82-%EF%BC%9A"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">二，方法底层细节 ：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B7%B7%E7%94%A8%E5%BC%95%E8%B5%B7%E7%9A%84%E5%90%8E%E6%9E%9C"><span class="toc-number">3.6.4.3.</span> <span class="toc-text">三、混用引起的后果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%93%E8%AE%BA%EF%BC%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">3.6.4.4.</span> <span class="toc-text">四、结论（如何使用）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">控制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.7.1.</span> <span class="toc-text">块作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.7.2.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.7.3.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">不确定循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.7.3.2.</span> <span class="toc-text">确定循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%80%89%E6%8B%A9%EF%BC%9Aswitch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.7.4.</span> <span class="toc-text">多重选择：switch语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E7%9A%84%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-number">3.7.4.1.</span> <span class="toc-text">switch的扩展知识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.7.5.</span> <span class="toc-text">break 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#continue-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.7.6.</span> <span class="toc-text">continue 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.1.</span> <span class="toc-text">声明数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.9.2.</span> <span class="toc-text">数组的静态初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">完整格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.9.2.2.</span> <span class="toc-text">格式详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9-1"><span class="toc-number">3.9.2.3.</span> <span class="toc-text">注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.9.2.4.</span> <span class="toc-text">简化格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.9.3.</span> <span class="toc-text">数组的动态初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.9.3.1.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC"><span class="toc-number">3.9.3.2.</span> <span class="toc-text">数组的默认初始化值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%A4%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.9.4.</span> <span class="toc-text">数组两种初始化方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.5.</span> <span class="toc-text">数组常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%80%BC"><span class="toc-number">3.9.6.</span> <span class="toc-text">地址值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">3.9.7.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">3.9.7.1.</span> <span class="toc-text">两个数组指向不同空间的内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">3.9.7.2.</span> <span class="toc-text">两个数组指向同一个空间的内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%AE%BF%E9%97%AE"><span class="toc-number">3.9.8.</span> <span class="toc-text">数组访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.9.9.</span> <span class="toc-text">数组拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">3.9.10.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.11.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A7%84%E5%88%99%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.12.</span> <span class="toc-text">不规则数组</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/21/NET-ASP-13/" title="ASP.NET学习记录-13-实践2-数据库进阶">ASP.NET学习记录-13-实践2-数据库进阶</a><time datetime="2025-04-21T08:39:19.000Z" title="发表于 2025-04-21 16:39:19">2025-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-12/" title="ASP.NET学习记录-12-实践2-使用MySQL数据库">ASP.NET学习记录-12-实践2-使用MySQL数据库</a><time datetime="2025-04-18T08:11:21.000Z" title="发表于 2025-04-18 16:11:21">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-11/" title="ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API">ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API</a><time datetime="2025-04-18T02:13:44.000Z" title="发表于 2025-04-18 10:13:44">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/NET-ASP-10/" title="ASP.NET学习记录-10-过滤">ASP.NET学习记录-10-过滤</a><time datetime="2025-04-16T12:02:16.000Z" title="发表于 2025-04-16 20:02:16">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/15/Software/" title="记录必备软件">记录必备软件</a><time datetime="2025-04-15T11:29:21.000Z" title="发表于 2025-04-15 19:29:21">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By kyl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>