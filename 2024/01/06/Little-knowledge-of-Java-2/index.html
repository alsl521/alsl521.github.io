<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java学习（二） | kyl的博客</title><meta name="author" content="kyl"><meta name="copyright" content="kyl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对象与类、封装、继承、多态的相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习（二）">
<meta property="og:url" content="https://alsl521.github.io/2024/01/06/Little-knowledge-of-Java-2/index.html">
<meta property="og:site_name" content="kyl的博客">
<meta property="og:description" content="对象与类、封装、继承、多态的相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4">
<meta property="article:published_time" content="2024-01-06T03:03:37.000Z">
<meta property="article:modified_time" content="2025-04-08T08:07:22.210Z">
<meta property="article:author" content="kyl">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java学习（二）",
  "url": "https://alsl521.github.io/2024/01/06/Little-knowledge-of-Java-2/",
  "image": "https://avatars.githubusercontent.com/u/61216968?s=400&u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&v=4",
  "datePublished": "2024-01-06T03:03:37.000Z",
  "dateModified": "2025-04-08T08:07:22.210Z",
  "author": [
    {
      "@type": "Person",
      "name": "kyl",
      "url": "https://alsl521.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://alsl521.github.io/2024/01/06/Little-knowledge-of-Java-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习（二）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">kyl的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Java学习（二）</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java学习（二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-06T03:03:37.000Z" title="发表于 2024-01-06 11:03:37">2024-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-08T08:07:22.210Z" title="更新于 2025-04-08 16:07:22">2025-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h1><h2 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h2><p>面向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类<code>(class)</code>是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的模具，将对象想象为小甜饼。由类构造<code>(construct)</code>对象的过程称为创建类的实例<code>(instance)</code>。</p>
<p><code>封装(encapsulation)</code>,有时称为数据隐藏)是处理对象的一个重要概念。<strong>从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。</strong><code>对象中的数据称为实例字段(instance field)</code>,<code>操作数据的过程称为方法（method)</code>。作为一个类的实例，特定对象都有一组特定的实例字段值。这些值的集合就是这个对象的当前状态(state)。无论何时，只要在对象上调用一个方法，它的状态就有可能发生改变。</p>
<p>实现封装的关键在于，绝对不能让类中的方法直接访问其他类的实例字段。程序只能通过对象的方法与对象数据进行交互。封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。这意味着一个类可以完全改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道也不用关心这个类所发生的变化。</p>
<p>OOP的另一个原则会让用户自定义Java类变得更为容易，这就是：<strong>可以通过扩展其他类来构建新类</strong>。事实上，在Java中，所有的类都源自一个“神通广大的超类”，它就是Object。所有其他类都扩展自这个Object类。</p>
<p>在扩展一个已有的类时，这个扩展后的新类具有被扩展的类的全部属性和方法。你只需要在新类中提供适用于这个新类的新方法和数据字段就可以了。<strong>通过扩展一个类来建立另外一个类的过程称为继承(inheritance)</strong>。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240119113642149.png" alt="-"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240119113950866.png" alt="image-20240119113950866"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240119114107706.png" alt="image-20240119114107706"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240119114200542.png" alt="image-20240119114200542"></p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法来定义的。<br>此外，每个对象都保存着描述当前状况的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现**(如果不经过方法调用就可以改变对象状态，只能说明破坏了封装性)**。<br>但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的标识(identity,或称身份)。需要注意，作为同一个类的实例，每个对象的标识总是不同的，状态也往往存在着差异。对象的这些关键特性会彼此相互影响。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240225151835081.png" alt="image-20240225151835081"></p>
<p>对象本身已知的事物称为<code>实例变量(instance variable)</code>。它们代表对象的<code>状态（数据）</code>，且该类型的每一个对象都会独立的拥有一份<code>该类型的值</code>。<br>所以你也可以把对象当作为<code>实例</code>。<br>对象可以执行的动作称为<code>方法</code>。在设计类时，你也会设计出操作对象数据的方法。对象带有读取或操作实例变量的方法是很常见的情形。举例来说，闹钟对象会有个变量来保存响铃时间，且会有getTime()与setTime()这两个方法来存取该时间。<br>因此说对象带有<code>实例变量和方法（也称成员变量于成员方法）</code>，但它们都是类设计中的部分。</p>
<p>实例变量永远都会有默认值，即便没有明确的赋值给它。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240225152229574.png" alt="image-20240225152229574"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240225152300704.png" alt="image-20240225152300704"></p>
<h4 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h4><p><img src="/Little-knowledge-of-Java-2/image-20240120104222729.png" alt="image-20240120104222729"></p>
<p>1.加载文件</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120104355459.png" alt="image-20240120104355459"></p>
<p>2.声明局部变量</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120104551639.png" alt="image-20240120104551639"></p>
<p>3.在堆内存开辟一个空间</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120104700316.png" alt="image-20240120104700316"></p>
<p>4.默认初始化</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120104732567.png" alt="image-20240120104732567"></p>
<p>5.显式初始化</p>
<p>如果在类中直接给值，则会显式初始化，直接覆盖掉默认初始化的值。</p>
<p>6.构造方法初始化</p>
<p>如果调用了非空构造方法，则会运行该步。</p>
<p>7.将堆内存中的地址值赋值给左边的局部变量</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120105031209.png" alt="image-20240120105031209"></p>
<p>8.结束</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120105118291.png" alt="image-20240120105118291"></p>
<h4 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h4><p>堆中的空间相互独立不受影响，并且<code>.class</code>文件只加载一次。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120105820112.png" alt="image-20240120105820112"></p>
<h4 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h4><p>将地址值共享。若地址值没有对象使用，则会被垃圾回收机制回收掉。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120110144964.png" alt="image-20240120110144964"></p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>在类之间，最常见的关系有</p>
<ul>
<li>依赖（“uses-a”):</li>
<li>聚合（“has-a”):</li>
<li>继承（“is-a”)。</li>
</ul>
<p><code>依赖</code>(dependence),即“uses-a”关系，是一种最明显的、最常见的关系。因此，如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。<br>应该尽可能地将相互依赖的类减至最少。这里的关键是，如果类A不知道B的存在，它就不会关心B的任何改变（这意味着B的改变不会导致A产生任何bug)。用软件工程的术语来说，就是尽可能减少类之间的耦合。</p>
<p><code>聚合</code>(aggregation),即“has-a”关系，很容易理解，因为这种关系很具体。<code>包容</code>关系意味着类A的对象包含类B的对象。</p>
<p><code>继承</code>(inheritance),即“is-a”关系，表示一个更特殊的类与一个更一般的类之间的关系。一般而言，如果类A扩展类B,类A不但包含从类B继承的方法，还会有一些额外的功能。</p>
<h2 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h2><p> 你必须指明程序代码中所使用到的类的完整名称，除非你使用的类来自于java.lang这个包。</p>
<p>一共有两种方法：</p>
<ol>
<li><p>import<br><img src="/Little-knowledge-of-Java-2/Shot_20240225_193458.png" alt="Shot_20240225_193458"></p>
</li>
<li><p>type</p>
<p><img src="/Little-knowledge-of-Java-2/Shot_20240225_193429.png" alt="Shot_20240225_193429"></p>
</li>
</ol>
<h3 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h3><p>要想使用对象，首先必须构造对象，并指定其初始状态。然后对对象应用方法。</p>
<p>在Java程序设计语言中，要使用构造器（constructor,或称构造函数)构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。</p>
<p>在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。new操作符的返回值也是一个引用。下面的语句：</p>
<p>Date deadline &#x3D; new Date()<br>也可以设置这个变量，让它引用一个已有的对象：<br>deadline &#x3D; birthday;</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240204162148290.png" alt="image-20240204162148290"></p>
<h4 id="对象引用（引用数据类型）"><a href="#对象引用（引用数据类型）" class="headerlink" title="对象引用（引用数据类型）"></a>对象引用（引用数据类型）</h4><p><img src="/Little-knowledge-of-Java-2/image-20240120110443849.png" alt="image-20240120110443849"></p>
<ul>
<li>事实上没有对象变量这样的东西存在。</li>
<li>只有引用(reference)到对象的变量。</li>
<li>对象引用变量保存的是存取对象的方法。</li>
<li>它并不是对象的容器，而是类似指向对象的指针。或者可以说是地址。但在Java中我们不会也不该知道引用变量中实际装载的是什么，它只是用来代表单一的对象。只有Java虚拟机才会知道如何使用引用来取得该对象。</li>
</ul>
<p>虽然primitive主数据类型变量是以字节来代表实际的变量值，<strong>但对象引用变量却是以字节来表示取得对象的方法</strong>。</p>
<p>对基本数据类型中的变量来说，变量值就是所代表的值（如5、-26.7或‘a’)。对引用变量来说，变量值是取得特定对象的位表示法。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240106105156613.png" alt="image-20240106105156613"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240106105207618.png" alt="image-20240106105207618"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240106105217858.png" alt="image-20240106105217858"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240106105246826.png" alt="image-20240106105246826"></p>
<p>对于任意一个Java虚拟机来说，所有的引用大小都一样，但不同的Java虚拟机间可能会以不同的方式来表示引用，因此某个Java虚拟机的引用大小可能会大于或小于另一个Java虚拟机的引用。</p>
<p>当一个对象没有被引用时，就会被Java回收机制回收掉。</p>
<h4 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h4><p>更改器方法(mutator method):调用这个方法后，对象的状态会改变。<br>只访问对象而不修改对象的方法有时称为访问器方法（accessor method)。即访问员对象中的内容，然后创建新的对象并将值赋给新创建的数据。</p>
<h4 id="日期类API"><a href="#日期类API" class="headerlink" title="日期类API"></a>日期类API</h4><h5 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h5><p>接下来，我们学习一下Date类，Java中是由这个类的对象用来表示日期或者时间。</p>
<p>Date对象记录的时间是用毫秒值来表示的。Java语言规定，1970年1月1日0时0分0秒认为是时间的起点，此时记作0，那么1000（1秒&#x3D;1000毫秒）就表示1970年1月1日0时0分1秒，依次内推。</p>
<p><img src="/Little-knowledge-of-Java-2/1667399304240-1707035399597-6.png" alt="1667399304240"></p>
<p>下面是Date类的构造方法，和常见的成员方法，利用这些API写代码尝试一下</p>
<p><img src="/Little-knowledge-of-Java-2/1667399443159-1707035399597-7.png" alt="1667399443159"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握Date日期类的使用。</span></span><br><span class="line">        <span class="comment">// 1、创建一个Date的对象：代表系统当前时间信息的。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、拿到时间毫秒值。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把时间毫秒值转换成日期对象： 2s之后的时间是多少。</span></span><br><span class="line">        time += <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、直接把日期对象的时间通过setTime方法进行修改</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        d3.setTime(time);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h5><p>各位同学，前面我们打印Date对象时，发现打印输出的日期格式我们并不喜欢，是不是？你们喜欢那种格式呢？是不是像下面页面中这种格式啊？接下来我们学习的SimpleDateFormat类就可以转换Date对象表示日期时间的显示格式。</p>
<ul>
<li><p>我们把Date对象转换为指定格式的日期字符串这个操作，叫做<strong>日期格式化，</strong></p>
</li>
<li><p>反过来把指定格式的日期符串转换为Date对象的操作，叫做<strong>日期解析。</strong></p>
</li>
</ul>
<p><img src="/Little-knowledge-of-Java-2/1667399510543-1707035399597-8.png" alt="1667399510543"></p>
<p>接下来，我们先演示一下日期格式化，需要用到如下的几个方法</p>
<p><img src="/Little-knowledge-of-Java-2/1667399804244-1707035399597-9.png" alt="1667399804244"></p>
<p>注意：创建SimpleDateFormat对象时，在构造方法的参数位置传递日期格式，而日期格式是由一些特定的字母拼接而来的。我们需要记住常用的几种日期&#x2F;时间格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">字母	   表示含义</span><br><span class="line">yyyy	年</span><br><span class="line">MM		月</span><br><span class="line">dd		日</span><br><span class="line">HH		时</span><br><span class="line">mm		分</span><br><span class="line">ss		秒</span><br><span class="line">SSS		毫秒</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2022年12月12日&quot;</span> 的格式是 <span class="string">&quot;yyyy年MM月dd日&quot;</span></span><br><span class="line"><span class="string">&quot;2022-12-12 12:12:12&quot;</span> 的格式是 <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span></span><br><span class="line">按照上面的格式可以任意拼接，但是字母不能写错</span><br></pre></td></tr></table></figure>

<p>最后，上代码演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2SimpleDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握SimpleDateFormat的使用。</span></span><br><span class="line">        <span class="comment">// 1、准备一些时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、格式化日期对象，和时间 毫秒值。</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> sdf.format(time);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标：掌握SimpleDateFormat解析字符串时间 成为日期对象。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2022-12-12 12:12:11&quot;</span>;</span><br><span class="line">        <span class="comment">// 1、创建简单日期格式化对象 , 指定的时间格式必须与被解析的时间格式一模一样，否则程序会出bug.</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> sdf2.parse(dateStr);</span><br><span class="line">        System.out.println(d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>日期格式化&amp;解析案例</strong></p>
<p><img src="/Little-knowledge-of-Java-2/1667400116263-1707035399597-10.png" alt="1667400116263"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="comment">// 目标：完成秒杀案例。</span></span><br><span class="line">        <span class="comment">// 1、把开始时间、结束时间、小贾下单时间、小皮下单时间拿到程序中来。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;2023年11月11日 0:0:0&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> <span class="string">&quot;2023年11月11日 0:10:0&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xj</span> <span class="operator">=</span> <span class="string">&quot;2023年11月11日 0:01:18&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xp</span> <span class="operator">=</span> <span class="string">&quot;2023年11月11日 0:10:57&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把字符串的时间解析成日期对象。</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">startDt</span> <span class="operator">=</span> sdf.parse(start);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">endDt</span> <span class="operator">=</span> sdf.parse(end);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">xjDt</span> <span class="operator">=</span> sdf.parse(xj);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">xpDt</span> <span class="operator">=</span> sdf.parse(xp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始判断小皮和小贾是否秒杀成功了。</span></span><br><span class="line">        <span class="comment">// 把日期对象转换成时间毫秒值来判断</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> startDt.getTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> endDt.getTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">xjTime</span> <span class="operator">=</span> xjDt.getTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">xpTime</span> <span class="operator">=</span> xpDt.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(xjTime &gt;= startTime &amp;&amp; xjTime &lt;= endTime)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小贾您秒杀成功了~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小贾您秒杀失败了~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(xpTime &gt;= startTime &amp;&amp; xpTime &lt;= endTime)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小皮您秒杀成功了~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小皮您秒杀失败了~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h5><p>学完Date类和SimpleDateFormat类之后，我们再学习一个和日期相关的类，它是Calendar类。Calendar类表示日历，它提供了一些比Date类更好用的方法。</p>
<p>比如下面的案例，用Date类就不太好做，而用Calendar就特别方便。因为Calendar类提供了方法可以直接对日历中的年、月、日、时、分、秒等进行运算。</p>
<p><img src="/Little-knowledge-of-Java-2/1667400242406-1707035399597-11.png" alt="1667400242406"></p>
<p><img src="/Little-knowledge-of-Java-2/1667400365583-1707035399597-12.png" alt="1667400365583"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4Calendar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握Calendar的使用和特点。</span></span><br><span class="line">        <span class="comment">// 1、得到系统此刻时间对应的日历对象。</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">now</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取日历中的某个信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> now.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> now.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、拿到日历中记录的日期对象。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> now.getTime();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、拿到时间毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> now.getTimeInMillis();</span><br><span class="line">        System.out.println(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、修改日历中的某个信息</span></span><br><span class="line">        now.set(Calendar.MONTH, <span class="number">9</span>); <span class="comment">// 修改月份成为10月份。</span></span><br><span class="line">        now.set(Calendar.DAY_OF_YEAR, <span class="number">125</span>); <span class="comment">// 修改成一年中的第125天。</span></span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、为某个信息增加或者减少多少</span></span><br><span class="line">        now.add(Calendar.DAY_OF_YEAR, <span class="number">100</span>);</span><br><span class="line">        now.add(Calendar.DAY_OF_YEAR, -<span class="number">10</span>);</span><br><span class="line">        now.add(Calendar.DAY_OF_MONTH, <span class="number">6</span>);</span><br><span class="line">        now.add(Calendar.HOUR, <span class="number">12</span>);</span><br><span class="line">        now.set(<span class="number">2026</span>, <span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="为什么JDK8要新增日期类"><a href="#为什么JDK8要新增日期类" class="headerlink" title="为什么JDK8要新增日期类"></a>为什么JDK8要新增日期类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：搞清楚为什么要用JDK 8开始新增的时间类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 传统的时间类（Date、SimpleDateFormat、Calendar）存在如下问题：</span></span><br><span class="line">        <span class="comment">// 1、设计不合理，使用不方便，很多都被淘汰了。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//System.out.println(d.getYear() + 1900);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、都是可变对象，修改后会丢失最开始的时间信息。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、线程不安全。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、不能精确到纳秒，只能精确到毫秒。</span></span><br><span class="line">        <span class="comment">// 1秒 = 1000毫秒</span></span><br><span class="line">        <span class="comment">// 1毫秒 = 1000微妙</span></span><br><span class="line">        <span class="comment">// 1微妙 = 1000纳秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK8日期、时间、日期时间"><a href="#JDK8日期、时间、日期时间" class="headerlink" title="JDK8日期、时间、日期时间"></a>JDK8日期、时间、日期时间</h5><p>接下来，我们学习一下JDK8新增的日期类。为什么以前的Date类就可以表示日期，为什么要有新增的日期类呢？原因如下</p>
<p><img src="/Little-knowledge-of-Java-2/1667400465054-1707035399597-13.png" alt="1667400465054"></p>
<p>JDK8新增的日期类分得更细致一些，比如表示年月日用<code>LocalDate</code>类、表示时间秒用<code>LocalTime</code>类、而表示年月日时分秒用**<code>LocalDateTime</code>**类等；除了这些类还提供了对时区、时间间隔进行操作的类等。它们几乎把对日期&#x2F;时间的所有操作都通过了API方法，用起来特别方便。</p>
<p><img src="/Little-knowledge-of-Java-2/1667400655334-1707035399597-14.png" alt="1667400655334"></p>
<p>先学习表示日期、时间、日期时间的类；有LocalDate、LocalTime、以及LocalDateTime类。仔细阅读代码，你会发现这三个类的用法套路都是一样的。</p>
<ul>
<li>LocalDate类的基本使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_LocalDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地日期对象(不可变对象)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">// 年 月 日</span></span><br><span class="line">        System.out.println(ld);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取日期对象中的信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ld.getYear(); <span class="comment">// 年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ld.getMonthValue(); <span class="comment">// 月(1-12)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ld.getDayOfMonth(); <span class="comment">// 日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> ld.getDayOfYear();  <span class="comment">// 一年中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ld.getDayOfWeek().getValue(); <span class="comment">// 星期几</span></span><br><span class="line">        System.out.println(year);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">        System.out.println(dayOfWeek);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、直接修改某个信息: withYear、withMonth、withDayOfMonth、withDayOfYear</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld2</span> <span class="operator">=</span> ld.withYear(<span class="number">2099</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld3</span> <span class="operator">=</span> ld.withMonth(<span class="number">12</span>);</span><br><span class="line">        System.out.println(ld2);</span><br><span class="line">        System.out.println(ld3);</span><br><span class="line">        System.out.println(ld);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把某个信息加多少: plusYears、plusMonths、plusDays、plusWeeks</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld4</span> <span class="operator">=</span> ld.plusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld5</span> <span class="operator">=</span> ld.plusMonths(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把某个信息减多少：minusYears、minusMonths、minusDays、minusWeeks</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld6</span> <span class="operator">=</span> ld.minusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld7</span> <span class="operator">=</span> ld.minusMonths(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定日期的LocalDate对象： public static LocalDate of(int year, int month, int dayOfMonth)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld8</span> <span class="operator">=</span> LocalDate.of(<span class="number">2099</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld9</span> <span class="operator">=</span> LocalDate.of(<span class="number">2099</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter</span></span><br><span class="line">        System.out.println(ld8.equals(ld9));<span class="comment">// true</span></span><br><span class="line">        System.out.println(ld8.isAfter(ld)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(ld8.isBefore(ld)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LocalTime类的基本使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2_LocalTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地时间对象</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now(); <span class="comment">// 时 分 秒 纳秒 不可变的</span></span><br><span class="line">        System.out.println(lt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取时间中的信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> lt.getHour(); <span class="comment">//时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> lt.getMinute(); <span class="comment">//分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> lt.getSecond(); <span class="comment">//秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> lt.getNano(); <span class="comment">//纳秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、修改时间：withHour、withMinute、withSecond、withNano</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt3</span> <span class="operator">=</span> lt.withHour(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt4</span> <span class="operator">=</span> lt.withMinute(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt5</span> <span class="operator">=</span> lt.withSecond(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt6</span> <span class="operator">=</span> lt.withNano(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt7</span> <span class="operator">=</span> lt.plusHours(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt8</span> <span class="operator">=</span> lt.plusMinutes(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt9</span> <span class="operator">=</span> lt.plusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt10</span> <span class="operator">=</span> lt.plusNanos(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt11</span> <span class="operator">=</span> lt.minusHours(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt12</span> <span class="operator">=</span> lt.minusMinutes(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt13</span> <span class="operator">=</span> lt.minusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt14</span> <span class="operator">=</span> lt.minusNanos(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定时间的LocalTime对象：</span></span><br><span class="line">        <span class="comment">// public static LocalTime of(int hour, int minute, int second)</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt15</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt16</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter</span></span><br><span class="line">        System.out.println(lt15.equals(lt16)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(lt15.isAfter(lt)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(lt15.isBefore(lt)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LocalDateTime类的基本使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3_LocalDateTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地日期和时间对象。</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 年 月 日 时 分 秒 纳秒</span></span><br><span class="line">        System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、可以获取日期和时间的全部信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ldt.getYear(); <span class="comment">// 年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ldt.getMonthValue(); <span class="comment">// 月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ldt.getDayOfMonth(); <span class="comment">// 日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> ldt.getDayOfYear();  <span class="comment">// 一年中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ldt.getDayOfWeek().getValue();  <span class="comment">// 获取是周几</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> ldt.getHour(); <span class="comment">//时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> ldt.getMinute(); <span class="comment">//分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> ldt.getSecond(); <span class="comment">//秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> ldt.getNano(); <span class="comment">//纳秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、修改时间信息：</span></span><br><span class="line">        <span class="comment">// withYear withMonth withDayOfMonth withDayOfYear withHour</span></span><br><span class="line">        <span class="comment">// withMinute withSecond withNano</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> ldt.withYear(<span class="number">2029</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt3</span> <span class="operator">=</span> ldt.withMinute(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、加多少:</span></span><br><span class="line">        <span class="comment">// plusYears  plusMonths plusDays plusWeeks plusHours plusMinutes plusSeconds plusNanos</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt4</span> <span class="operator">=</span> ldt.plusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt5</span> <span class="operator">=</span> ldt.plusMinutes(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、减多少：</span></span><br><span class="line">        <span class="comment">// minusDays minusYears minusMonths minusWeeks minusHours minusMinutes minusSeconds minusNanos</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt6</span> <span class="operator">=</span> ldt.minusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt7</span> <span class="operator">=</span> ldt.minusMinutes(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定日期和时间的LocalDateTime对象：</span></span><br><span class="line">        <span class="comment">// public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour,</span></span><br><span class="line">        <span class="comment">//                                  int minute, int second, int nanoOfSecond)</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt8</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1222</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt9</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1222</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、 判断2个日期、时间对象，是否相等，在前还是在后： equals、isBefore、isAfter</span></span><br><span class="line">        System.out.println(ldt9.equals(ldt8));</span><br><span class="line">        System.out.println(ldt9.isAfter(ldt));</span><br><span class="line">        System.out.println(ldt9.isBefore(ldt));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、可以把LocalDateTime转换成LocalDate和LocalTime</span></span><br><span class="line">        <span class="comment">// public LocalDate toLocalDate()</span></span><br><span class="line">        <span class="comment">// public LocalTime toLocalTime()</span></span><br><span class="line">        <span class="comment">// public static LocalDateTime of(LocalDate date, LocalTime time)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> ldt.toLocalDate();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> ldt.toLocalTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt10</span> <span class="operator">=</span> LocalDateTime.of(ld, lt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK8日期（时区）"><a href="#JDK8日期（时区）" class="headerlink" title="JDK8日期（时区）"></a>JDK8日期（时区）</h5><p>接着，我们学习代表时区的两个类。由于世界各个国家与地区的经度不同，各地区的时间也有所不同，因此会划分为不同的时区。每一个时区的时间也不太一样。</p>
<p><img src="/Little-knowledge-of-Java-2/1667400888534-1707035399597-15.png" alt="1667400888534"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4_ZoneId_ZonedDateTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：了解时区和带时区的时间。</span></span><br><span class="line">        <span class="comment">// 1、ZoneId的常见方法：</span></span><br><span class="line">        <span class="comment">// public static ZoneId systemDefault(): 获取系统默认的时区</span></span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">        System.out.println(zoneId.getId());</span><br><span class="line">        System.out.println(zoneId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static Set&lt;String&gt; getAvailableZoneIds(): 获取Java支持的全部时区Id</span></span><br><span class="line">        System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static ZoneId of(String zoneId) : 把某个时区id封装成ZoneId对象。</span></span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">zoneId1</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、ZonedDateTime：带时区的时间。</span></span><br><span class="line">        <span class="comment">// public static ZonedDateTime now(ZoneId zone): 获取某个时区的ZonedDateTime对象。</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now(zoneId1);</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 世界标准时间了</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">now1</span> <span class="operator">=</span> ZonedDateTime.now(Clock.systemUTC());</span><br><span class="line">        System.out.println(now1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static ZonedDateTime now()：获取系统默认时区的ZonedDateTime对象</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">now2</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">        System.out.println(now2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calendar instance = Calendar.getInstance(TimeZone.getTimeZone(zoneId1));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK8日期（Instant类）"><a href="#JDK8日期（Instant类）" class="headerlink" title="JDK8日期（Instant类）"></a>JDK8日期（Instant类）</h5><p>接下来，我们来学习Instant这个类。通过获取Instant的对象可以拿到此刻的时间，该时间由两部分组成：从1970-01-01 00:00:00 开始走到此刻的总秒数+不够1秒的纳秒数。</p>
<p><img src="/Little-knowledge-of-Java-2/1667401284295-1707035399597-16.png" alt="1667401284295"></p>
<p>该类提供的方法如下图所示，可以用来获取当前时间，也可以对时间进行加、减、获取等操作。</p>
<p><img src="/Little-knowledge-of-Java-2/1667401373923-1707035399597-17.png" alt="1667401373923"></p>
<p><strong>作用：可以用来记录代码的执行时间，或用于记录用户操作某个事件的时间点。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Instant的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5_Instant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// 1、创建Instant的对象，获取此刻时间信息</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now(); <span class="comment">// 不可变对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取总秒数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">second</span> <span class="operator">=</span> now.getEpochSecond();</span><br><span class="line">        System.out.println(second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、不够1秒的纳秒数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> now.getNano();</span><br><span class="line">        System.out.println(nano);</span><br><span class="line"></span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> now.plusNanos(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instant对象的作用：做代码的性能分析，或者记录用户的操作时间点</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now1</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        <span class="comment">// 代码执行。。。。</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now2</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">l</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK8日期（格式化器）"><a href="#JDK8日期（格式化器）" class="headerlink" title="JDK8日期（格式化器）"></a>JDK8日期（格式化器）</h5><p>接下来，我们学习一个新增的日期格式化类，叫DateTimeFormater。它可以从来对日期进行格式化和解析。它代替了原来的SimpleDateFormat类。</p>
<p><img src="/Little-knowledge-of-Java-2/1667401511710-1707035399597-18.png" alt="1667401511710"></p>
<p>需要用到的方法，如下图所示</p>
<p><img src="/Little-knowledge-of-Java-2/1667401564173-1707035399597-19.png" alt="1667401564173"></p>
<p>接下来，将上面的方法用代码来演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  目标：掌握JDK 8新增的DateTimeFormatter格式化器的用法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6_DateTimeFormatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个日期时间格式化器对象出来。</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、对时间进行格式化</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> formatter.format(now); <span class="comment">// 正向格式化</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、格式化时间，其实还有一种方案。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> now.format(formatter); <span class="comment">// 反向格式化</span></span><br><span class="line">        System.out.println(rs2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、解析时间：解析时间一般使用LocalDateTime提供的解析方法来解析。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2029年12月12日 12:12:11&quot;</span>;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.parse(dateStr, formatter);</span><br><span class="line">        System.out.println(ldt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="JDK8日期（Period类）"><a href="#JDK8日期（Period类）" class="headerlink" title="JDK8日期（Period类）"></a>JDK8日期（Period类）</h5><p>除以了上新增的类，JDK8还补充了两个类，一个叫Period类、一个叫Duration类；这两个类可以用来对计算两个时间点的时间间隔。</p>
<p>其中Period用来计算日期间隔（年、月、日），Duration用来计算时间间隔（时、分、秒、纳秒）</p>
<p><img src="/Little-knowledge-of-Java-2/1667401637360-1707035399597-20.png" alt="1667401637360"></p>
<p>先来演示Period类的用法，它的方法如下图所示。可以用来计算两个日期之间相隔的年、相隔的月、相隔的日。<strong>只能两个计算LocalDate对象之间的间隔</strong></p>
<p><img src="/Little-knowledge-of-Java-2/1667401886743-1707035399597-21.png" alt="1667401886743"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Period的作用：计算机两个日期相差的年数，月数、天数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test7_Period</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.of(<span class="number">2029</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建Period对象，封装两个日期对象。</span></span><br><span class="line">        <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、通过period对象获取两个日期对象相差的信息。</span></span><br><span class="line">        System.out.println(period.getYears());</span><br><span class="line">        System.out.println(period.getMonths());</span><br><span class="line">        System.out.println(period.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK8日期（Duration类）"><a href="#JDK8日期（Duration类）" class="headerlink" title="JDK8日期（Duration类）"></a>JDK8日期（Duration类）</h5><p>接下来，我们学习Duration类。它是用来表示两个时间对象的时间间隔。<strong>可以用于计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant等时间</strong></p>
<p><img src="/Little-knowledge-of-Java-2/1667401938724-1707035399597-22.png" alt="1667401938724"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test8_Duration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2025</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2025</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 1、得到Duration对象</span></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取两个时间对象间隔的信息</span></span><br><span class="line">        System.out.println(duration.toDays());<span class="comment">// 间隔多少天</span></span><br><span class="line">        System.out.println(duration.toHours());<span class="comment">// 间隔多少小时</span></span><br><span class="line">        System.out.println(duration.toMinutes());<span class="comment">// 间隔多少分</span></span><br><span class="line">        System.out.println(duration.toSeconds());<span class="comment">// 间隔多少秒</span></span><br><span class="line">        System.out.println(duration.toMillis());<span class="comment">// 间隔多少毫秒</span></span><br><span class="line">        System.out.println(duration.toNanos());<span class="comment">// 间隔多少纳秒</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><p>在Java中，最简单的类定义形式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">	field1;</span><br><span class="line">	field2;</span><br><span class="line">    ...</span><br><span class="line">	constructory1;</span><br><span class="line">	constructor2;</span><br><span class="line">    ...</span><br><span class="line">	method1;</span><br><span class="line">	method2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul>
<li>构造器与类同名。</li>
<li>每个类可以有一个以上的构造器。</li>
<li>构造器可以有0个、1个或多个参数。</li>
<li>构造器没有返回值。</li>
<li>构造器总是伴随着new操作符一起调用。</li>
</ul>
<h3 id="构造方法概述"><a href="#构造方法概述" class="headerlink" title="构造方法概述"></a>构造方法概述</h3><p>构造方法是一种特殊的方法</p>
<ul>
<li><p>作用：创建对象   Student stu &#x3D; <strong>new Student();</strong></p>
</li>
<li><p>格式：</p>
<p>public class 类名{</p>
<p>​        修饰符 类名( 参数 ) {</p>
<p>​        }</p>
<p>}</p>
</li>
<li><p>功能：主要是完成对象数据的初始化</p>
</li>
</ul>
<h3 id="构造方法的注意事项"><a href="#构造方法的注意事项" class="headerlink" title="构造方法的注意事项"></a>构造方法的注意事项</h3><ul>
<li>构造方法的创建</li>
</ul>
<p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法<br>如果定义了构造方法，系统将不再提供默认的构造方法</p>
<ul>
<li>构造方法的重载</li>
</ul>
<p>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p>
<ul>
<li>推荐的使用方式</li>
</ul>
<p>无论是否使用，都手工书写无参数构造方法</p>
<ul>
<li>重要功能！</li>
</ul>
<p>可以使用带参构造，为成员变量进行初始化</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><p>方法会运用形参。调用的一方会传入实参。</p>
<p>实参是传给方法的值。当它传入方法后就成了形参。</p>
<ol>
<li>形参：方法定义中的参数</li>
</ol>
<p>​          等同于变量定义格式，例如：int number</p>
<ol start="2">
<li>实参：方法调用中的参数</li>
</ol>
<p>​          等同于使用变量或常量，例如： 10  number</p>
<p><code>Java</code>是通过值传递的，也就是说通过拷贝传递。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240115100621120.png" alt="image-20240115100621120"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240115101004458.png" alt="image-20240115101004458"></p>
<h3 id="显示参数和隐式参数"><a href="#显示参数和隐式参数" class="headerlink" title="显示参数和隐式参数"></a>显示参数和隐式参数</h3><p>显示参数：在方法中明确定义的参数为显示参数</p>
<p>隐式参数：未在方法是定义的，但的确又动态影响到程序运行的“参数”</p>
<p>也就是说，调用函数的对象就是隐式参数，显示参数就是我们通常所说的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriendTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newFriend</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">        GirlFriend gFriend = new GirlFriend()</span>;</span><br><span class="line">        gFriend.setName(<span class="string">&quot;木洺紫&quot;</span>)；</span><br><span class="line">        gFriend.setAge(<span class="number">12</span>);</span><br><span class="line">        gFriend.setHeight(<span class="number">170</span>);</span><br><span class="line">        gFriend.setWeight (<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的参数值，<strong>“木洺紫”，“12”，“170”，“100”</strong></p>
<p>便为显示参数，这里的<strong>调用对象gFriend便为隐式参数</strong>。</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul>
<li><p>方法重载概念</p>
<p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p>
<ul>
<li><strong>多个方法在同一个类中</strong></li>
<li><strong>多个方法具有相同的方法名</strong></li>
<li><strong>多个方法的参数不相同，类型不同或者数量不同</strong></li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><strong>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</strong></li>
<li><strong>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</strong></li>
</ul>
</li>
</ul>
<h3 id="方法调用的内存"><a href="#方法调用的内存" class="headerlink" title="方法调用的内存"></a>方法调用的内存</h3><p><img src="/Little-knowledge-of-Java-2/1.gif" alt="1"></p>
<p><img src="/Little-knowledge-of-Java-2/2.gif" alt="2"></p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="/Little-knowledge-of-Java-2/image-20240119102806713.png" alt="image-20240119102806713"></p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><img src="/Little-knowledge-of-Java-2/image-20240119102843317.png" alt="image-20240119102843317"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240119103019565.png" alt="image-20240119103019565"></p>
<h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><h4 id="一、什么是静态工厂方法？"><a href="#一、什么是静态工厂方法？" class="headerlink" title="一、什么是静态工厂方法？"></a>一、什么是静态工厂方法？</h4><p>对于类而言，在我们需要获取一个实例时，最传统的方法都是通过new新建一个对象，这是jvm通过调用构造函数帮我们实例化出来的对象。而静态工厂方法则是另外一种不通过new来获取一个实例的方法，我们可以通过一个类中公有的静态方法，来返回一个实例。<br>比如有这样一个People类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们传统的获取实例都是通过new：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People People=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br></pre></td></tr></table></figure>

<p>而静态工厂方法可以在类中添加一个公有静态方法来返回一个实例，还是以上面的People类为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> People <span class="title function_">getPeople</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过getPeople这个静态方法来获取一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People firstPeople=People.getPeople();</span><br></pre></td></tr></table></figure>

<h4 id="二、静态工厂方法的优势"><a href="#二、静态工厂方法的优势" class="headerlink" title="二、静态工厂方法的优势"></a>二、静态工厂方法的优势</h4><p>总结的说，静态工厂方法有五大优势：</p>
<h5 id="1、静态工厂方法有名称"><a href="#1、静态工厂方法有名称" class="headerlink" title="1、静态工厂方法有名称"></a>1、静态工厂方法有名称</h5><p>对于构造器来说，我们都知道，构造函数的命名只能是类名，而构造函数重载也只能通过参数的不同去区分调用不同的构造函数，一个类只能有一个带有指定参数的构造器，而若是两个构造器需要的参数是相同类型的话，开发人员通常会通过改变这两个参数的顺序来定义两个构造器，注意，这种情况只能适合多参构造函数，在单参构造器中则无法实现了。而静态工厂方法便显得简单许多，因为它能被我们定义成不同的名字，这使用起来会更加的方便，在某种程度上来说代码也会更易阅读。</p>
<p>还是以之前的Peple类做例子，当我们获取实例时想要对name和age初始化，需要定义这样的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name=name;</span><br><span class="line">		<span class="built_in">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>要是我们同时也需要对name和weight进行初始化，则需要改变参数中String和int类型的位置，以实现不同的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">People</span><span class="params">(<span class="type">int</span> weight,String name)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name=name;</span><br><span class="line">	<span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这样有时候则会让我们不知道该调用哪个构造函数，又或者需要在两个不同的实例中初始化age和weight的值的时候，是没办法同时出现People(int age)和People(int weight)这样的两个构造函数的，因此我们需要通过静态工厂方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> People <span class="title function_">getNameWeightPeople</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		People nwp=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">		nwp.name=name;</span><br><span class="line">		nwp.weight=weight;</span><br><span class="line">		<span class="keyword">return</span> nwp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> People <span class="title function_">getNameAgePeople</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		People nap=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">		nap.name=name;</span><br><span class="line">		nap.age=age;</span><br><span class="line">		<span class="keyword">return</span> nap;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> People <span class="title function_">getAgePeople</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		People ap=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">		ap.age=age;</span><br><span class="line">		<span class="keyword">return</span> ap;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> People <span class="title function_">getWeightPeople</span><span class="params">(<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">		People wp=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">		wp.weight=weight;</span><br><span class="line">		<span class="keyword">return</span> wp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们便能通过静态工厂方法定义不同初始化属性但参数类型相同的方法来获取不同的实例对象了。</p>
<h5 id="2、静态工厂方法不用在每次调用的时候都创建一个新的对象"><a href="#2、静态工厂方法不用在每次调用的时候都创建一个新的对象" class="headerlink" title="2、静态工厂方法不用在每次调用的时候都创建一个新的对象"></a>2、静态工厂方法不用在每次调用的时候都创建一个新的对象</h5><p>“如果程序经常请求创建相同的对象，并且创建对象的代价很高，则静态工厂方法能极大地提升程序的性能。”这是《Effective Java》这本书中对这一优势的说法。<br>如果我们的代码在调用某个类的时候只需要一个实例，但是并不关心这个实例是否是一个新的对象，此时通过静态工厂方法便可以很方便的实现，提升程序性能。<br>例如加载数据库驱动的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure>

<p>我们通过这样的一句代码便能加载驱动，而我们根本不关心这个方法返回的实例，因此便可以不创建实例对象。</p>
<p><strong>3、静态工厂方法可以返回原返回类型的任何子类型对象</strong><br>这样子看起来貌似有点绕，简单的来说，在构造器中我们只能返回当前构造器所在类的对象，而通过静态工厂方法我们可以任意选择返回类型，因此便可以返回该类的任何子类型。<br>还是以People类为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> People <span class="title function_">getWomen</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Women</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、静态工厂方法所返回的对象可以随着每次调用而发生变化，这取决于参数值"><a href="#4、静态工厂方法所返回的对象可以随着每次调用而发生变化，这取决于参数值" class="headerlink" title="4、静态工厂方法所返回的对象可以随着每次调用而发生变化，这取决于参数值"></a>4、静态工厂方法所返回的对象可以随着每次调用而发生变化，这取决于参数值</h5><p>也就是说，我们可以通过参数值的不同，来选择返回哪个实例（注意，这里说的是参数值而不是参数类型），而这个实例的类型只要是已经声明好的返回类型的子类型，就都是被允许的。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> People <span class="title function_">getOne</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(age&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Adult</span>();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adult</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，Child和Adult这两个类的存在对于客户端来说是不可见的，客户端永远不知道也不关心他们从这个静态工厂方法中得到的对象是一个什么类型，它们只关心这个对象是People的某个子类。</p>
<p>5、静态工厂方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在<br>这个优势构成了服务提供者框架的基础，服务提供者框架是指多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个实现中解耦出来。<br>以JDBC的API为例，对于JDBC来说，Connection就是服务接口的一部分，DriverManager.registerDriver是提供者注册API，DriverManager.getConnection是服务访问API，Driver是服务提供者接口。<br>我们要通过jdbc获取一个mysql连接，是这样获取的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);   </span><br><span class="line">Connection connection=DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/database&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);  </span><br></pre></td></tr></table></figure>

<p>这里我们获取的连接对象是Connection，按住Ctrl点进去我们可以发现Connection是一个接口，而接口又如何能操作数据库，所以我们这里得到的其实是Connection接口的实现类，而这个实现类是对我们不可见的，因为我们根本不需要去关心这个实现类是什么，我们只需要用这个Connection接口便可以实现对数据库的操作。而我们获取到的这个实现类，是通过DriverManager.getConnection这个方法得到的，我们通过查看这个方法的源码可以知道这个方法其实是一个静态工厂方法，而很明显Connection的实现类并不存在于包含这个静态工厂方法的DriverManager类中。</p>
<h4 id="三、静态工厂方法的缺点"><a href="#三、静态工厂方法的缺点" class="headerlink" title="三、静态工厂方法的缺点"></a>三、静态工厂方法的缺点</h4><p>1、类如果不含公有的或者受保护的构造器，就不能被子类化<br>这个很好理解，如果类不含上述的这两种构造器，当然就没办法被继承。但实际这样或许也是一个好处，因为这样能鼓励程序员使用复合，而不是继承，这正是不可变类型所需要的。</p>
<p>2、程序员很难发现静态工厂方法<br>因为静态工厂方法是自定义的，它们没有像构造器那样被明确规定如何实例化，因此程序员往往很难查明如何通过静态工厂方法实例化一个类，因此我们便需要遵守一些静态工厂方法的惯用名称。<br>以下列出一小部分：</p>
<p>①from——类型转换方法，只有单个参数。返回该类型的一个相对应实例，例如：</p>
<p><code>Date d=Date.from(instant)</code></p>
<p>②of——聚合方法，有多个参数，返回该类型的一个实例，把它们合并起来，例如：</p>
<p><code>Set＜Rank＞ facecards=Enumset.of(JACK， QUEEN， KING);</code></p>
<p>③valueOf——比from和of更烦琐的一种替代方法，例如:</p>
<p><code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></p>
<p>④ instance或者getInstance——返回的实例是通过方法的(如有)参数来描述的，但是不能说与参数具有同样的值，例如:</p>
<p><code>Stackwalker luke -Stackwalker.getInstance(options);</code></p>
<p>⑤create或者 newInstance——像 instance或者 getInstance一样，但 create或者 newInstance能够确保每次调用都返回一个新的实例，例如:</p>
<p><code>Object newArray=Array.newInstance(classObject,arrayLen);</code></p>
<p>⑥getType——像 getInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型，例如:</p>
<p><code>FileStore fs=Files.getFileStore(path);</code></p>
<p>⑦newtype——像newInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型，例如:</p>
<p><code>BufferedReader br=Files.newBufferedReader(path);</code></p>
<p>⑧type——getType和 newType的简版，例如：</p>
<p><code>List&lt;Complaint&gt; litany=Collections.list(legacyLitany);</code></p>
<p>四、总结<br>总而言之，静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。<br>往往静态工厂方法会更加合适，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂</p>
<h3 id="final实例字段"><a href="#final实例字段" class="headerlink" title="final实例字段"></a>final实例字段</h3><p>可以将实例字段定义为final。这样的字段必须在构造对象时初始化。也就是说，必须确保在每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个字段。</p>
<h2 id="静态字段与静态方法"><a href="#静态字段与静态方法" class="headerlink" title="静态字段与静态方法"></a>静态字段与静态方法</h2><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>以前我们定义过如下类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> sex; <span class="comment">// &#x27;男&#x27;  &#x27;女&#x27;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有参数构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String  a)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。</p>
<p>而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。</p>
<p>所以Java中成员（<strong>变量和方法</strong>）等是存在所属性的，Java是通过static关键字来区分的。<strong>static关键字在Java开发非常的重要，对于理解面向对象非常关键。</strong></p>
<p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p>
<p><strong>静态变量是随着类的加载而加载的，优先于对象出现的</strong></p>
<h4 id="定义格式和使用"><a href="#定义格式和使用" class="headerlink" title="定义格式和使用"></a>定义格式和使用</h4><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p>
<h5 id="静态变量及其访问"><a href="#静态变量及其访问" class="headerlink" title="静态变量及其访问"></a>静态变量及其访问</h5><p>有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。</p>
<p><strong>如何使用呢</strong></p>
<p>例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。</p>
<p><strong>定义格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 数据类型 变量名 = 初始值；    </span><br></pre></td></tr></table></figure>

<p><strong>静态成员变量的访问:</strong></p>
<p><strong>格式：类名.静态变量</strong></p>
<h5 id="实例变量及其访问"><a href="#实例变量及其访问" class="headerlink" title="实例变量及其访问"></a>实例变量及其访问</h5><p>无static修饰的成员变量属于每个对象的，  这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p>
<p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。   </p>
<p><strong>格式：对象.实例成员变量</strong></p>
<h5 id="静态方法及其访问"><a href="#静态方法及其访问" class="headerlink" title="静态方法及其访问"></a>静态方法及其访问</h5><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者</strong>静态方法**。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p>
<p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p>
<p><strong>静态成员变量的访问:</strong></p>
<p><strong>格式：类名.静态方法</strong></p>
<h5 id="实例方法及其访问"><a href="#实例方法及其访问" class="headerlink" title="实例方法及其访问"></a>实例方法及其访问</h5><p>无static修饰的成员方法属于每个对象的，这个成员方法也叫做<strong>实例方法</strong>。</p>
<p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。  </p>
<p><strong>格式：对象.实例方法</strong></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121145435335.png" alt="image-20240121145435335"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121145025819.png" alt="image-20240121145025819"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121145053310.png" alt="image-20240121145053310"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p>
<p>2.无<code>static</code>修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p>
<p>3.<code>static</code>修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p>
<p>4.无<code>static</code>修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121150926364.png" alt="image-20240121150926364"></p>
<p>1.静态方法不能访问非静态</p>
<p>2.非静态可以访问所有</p>
<p>由于两者存在于内存的不同位置，，静态区中的数据先于对象的创建，因此静态无法访问非静态数据，但反过来可以。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121151815897.png" alt="image-20240121151815897"></p>
<p>通常在工具类中使用。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121145810522.png" alt="image-20240121145810522"></p>
<p><code>this</code>的内存</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120110748030.png" alt="image-20240120110748030"></p>
<h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>如果将一个字段定义为static,每个类只有一个这样的字段。而对于非静态的实例字段，每个对象都有自己的一个副本。</p>
<p>现在，每一个Employee对象都有一个自己的id字段，但这个类的所有实例将共享一个nextId字段。换句话说，如果有1000个Employee类对象，则有1000个实例字段id,分别对应每一个对象。但是，只有一个静态字段nextId。,即使没有Employee对象，静态字段nextId也存在（<code>它的值对所有的实例来说都相同</code>）。<code>它属于类，而不属于任何单个的对象。</code></p>
<blockquote>
<p><code>静态变量会在该类的任何对象创建之前就完成初始化。</code><br><code>静态变量会在该类的任何静态方法执行之前就初始化。</code></p>
</blockquote>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>通过<code>static final</code>修饰的数据。常数变量的名称应该要都是大写字母 ，并且必须声明值或在静态初始化程序中赋值。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法是不在对象上执行的方法。可以认为静态方法是没有this参数的方法。</p>
<p>类的静态方法不能访问id实例字段，因为它不能在对象上执行操作。但是，静态方法可以访问静态字段。</p>
<p>在下面两种情况下可以使用静态方法：</p>
<ul>
<li>方法不需要访问对象状态，因为它需要的所有参数都通过显式参数提供。</li>
<li>方法只需要访问类的静态字段。</li>
</ul>
<blockquote>
<p>静态方法是在无关特定类的实例情况下执行的，甚至也不会有该类的实例出现。因为静态方法是通过类的名称调用，所以静态方法无法引用到该类的任何实例变量和方法。因此，<code>静态方法不能调用非静态变量和非静态方法。</code></p>
</blockquote>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>有些类有多个构造器，这种功能叫做重载(overloading)。如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数，便出现了重载。编译器必须挑选出具体调用哪个方法。它用各个方法首部中的参数类型与特定方法调用中所使用的值类型进行匹配，来选出正确的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好（这个查找匹配的过程被称为重载解析(overloading resolution))。</p>
<h3 id="默认字段初始化"><a href="#默认字段初始化" class="headerlink" title="默认字段初始化"></a>默认字段初始化</h3><p>如果在构造器中没有显式地为字段设置初值，那么就会被自动地赋为默认值：数值为0、布尔值为fa1se、对象引用为null。</p>
<h3 id="无参数的构造器"><a href="#无参数的构造器" class="headerlink" title="无参数的构造器"></a>无参数的构造器</h3><p>如果写一个类时没有编写构造器，就会为你提供一个无参数构造器。这个构造器将所有的实例字段设置为默认值。于是，实例字段中的数值型数据设置为日，布尔型数据设置为false,所有对象变量将设置为null。<br>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，那么构造对象时如果不提供参数就是不合法的。</p>
<blockquote>
<p>警告：请记住，仅当类没有任何其他构造器的时候，你才会得到一个默认的无参数构造器。</p>
</blockquote>
<h3 id="显式字段初始化"><a href="#显式字段初始化" class="headerlink" title="显式字段初始化"></a>显式字段初始化</h3><p>在执行构造器之前先完成这个赋值操作。如果一个类的所有构造器都希望把某个特定的实例字段设置为同一个值，这个语法就特别有用。</p>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>实际上，Java还有第三种机制，称为初始化块(initialization block)。在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static init block A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;common init block A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor without params A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>告诉我们，如何正确设计对象的属性和方法</p>
<p>对象代表什么，就得封装对应的数据，并提供数据对应的行为，为了安全的保护数据。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240119115327009.png" alt="image-20240119115327009"></p>
<p><code>private</code>关键字</p>
<ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员（成员变量和成员方法）</li>
<li>被<code>private</code>修饰的成员只能在本类中才能访问</li>
</ul>
<ol>
<li><code>private</code>关键字是一个权限修饰符</li>
<li>可以修饰成员（成员变量和成员方法)</li>
<li>被<code>private</code>修饰的成员只能在本类中才能访问</li>
<li>针对<code>private</code>修饰的成员变量，如果需要被其他类使用，提供相应的操作</li>
<li>提供“<code>setXxx(参数)</code>”方法，用于给成员变量赋值，方法用<code>public</code>修饰</li>
<li>提供“<code>getXxx()</code>”方法，用于获取成员变量的值，方法用<code>public</code>修饰</li>
</ol>
<p><img src="/Little-knowledge-of-Java-2/image-20240120101104441.png" alt="image-20240120101104441"></p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h2><p>this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）</p>
<ul>
<li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</li>
<li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li>
</ul>
<p>1.就近原则<br><code>System.out.println(age);</code><br><code>System.out.println(this.age);</code><br>2.<code>this</code>的作用？<br>可以区别成员变量和局部变量</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>创造对象的时候，虚拟机会自动调用构造方法，作用是给成员变量进行初始化的。</p>
<ul>
<li>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</li>
<li>如果定义了构造方法，系统将不再提供默认的构造方法</li>
<li>带参构造方法，和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载</li>
<li>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法</li>
</ul>
<p><img src="/Little-knowledge-of-Java-2/image-20240120102621998.png" alt="image-20240120102621998"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240120103609032.png" alt="image-20240120103609032"></p>
<h2 id="标准的JavaBean类"><a href="#标准的JavaBean类" class="headerlink" title="标准的JavaBean类"></a>标准的<code>JavaBean</code>类</h2><ol>
<li>类名需要见名知意</li>
<li>成员变量使用private修饰</li>
<li>提供至少两个构造方法<ul>
<li>无参构造方法</li>
<li>带全部参数的构造方法</li>
</ul>
</li>
<li>成员方法<ul>
<li>提供每一个成员变量对应的<code>setXxx()/getXxx()</code></li>
<li>如果还有其他行为，也需要写上</li>
</ul>
</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的含义"><a href="#继承的含义" class="headerlink" title="继承的含义"></a>继承的含义</h2><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p>
<p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p>
<p>每一个类都直接或者间接的继承于Object。</p>
<p><code>但一个类只能有一个父类。</code></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121154155736.png" alt="image-20240121154155736"></p>
<h2 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h2><ol>
<li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li>
<li>使类与类之间产生了关系。</li>
</ol>
<h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><h3 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h3><p>关键字extends表明正在构造的新类派生于一个已存在的类。这个已存在的类称为<code>超类(super class)</code>、<code>基类(base class)</code>或<code>父类(parent class)</code>;新类称为<code>子类(sub class)</code>、<code>派生类(derived class)</code>或<code>孩子类(child class)</code>。超类和子类是Java程序员最常用的两个术语，而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这也能很贴切地体现“继承”。</p>
<p>通过 <code>extends</code> 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</strong></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121153901209.png" alt="image-20240121153901209"></p>
<p>但是<code>继承≠直接使用</code>，因此<code>private</code>的成员变量不能直接使用。</p>
<p>公共成员变量</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121155754306.png" alt="image-20240121155754306"></p>
<p>私有成员变量</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121160109302.png" alt="image-20240121160109302"></p>
<p>所有的方法都放在了虚方法表中。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121160643586.png" alt="image-20240121160643586"></p>
<h3 id="子类不能继承的内容"><a href="#子类不能继承的内容" class="headerlink" title="子类不能继承的内容"></a>子类不能继承的内容</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>并不是父类的所有内容都可以给子类继承的：</p>
<p><strong>子类不能继承父类的构造方法。</strong></p>
<p><strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter&#x2F;setter方法访问父类的private成员变量。</strong></p>
<h4 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        System.out.println(z.num1);</span><br><span class="line">        System.out.println(z.getNum2());</span><br><span class="line">        z.show1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承后的特点—成员变量"><a href="#继承后的特点—成员变量" class="headerlink" title="继承后的特点—成员变量"></a>继承后的特点—成员变量</h3><p>成员变量不重名：</p>
<p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。</p>
<p>成员变量重名：</p>
<p>如果子类父类中出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。</p>
<p>子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121162505664.png" alt="image-20240121162505664"></p>
<h4 id="super访问父类成员变量"><a href="#super访问父类成员变量" class="headerlink" title="super访问父类成员变量"></a>super访问父类成员变量</h4><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p>
<p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong></p>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.父类成员变量名</span><br></pre></td></tr></table></figure>

<p>子类方法需要修改，代码如下：</p>
<blockquote>
<p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的<code>getXxx</code>方法和<code>setXxx</code>方法。</p>
</blockquote>
<h3 id="继承后的特点—成员方法"><a href="#继承后的特点—成员方法" class="headerlink" title="继承后的特点—成员方法"></a>继承后的特点—成员方法</h3><p>同样适用就近原则。</p>
<p>成员方法不重名：</p>
<p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>
<p>成员方法重名：</p>
<p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，<strong>子类对象会优先调用自己的方法</strong>。</p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p><img src="/Little-knowledge-of-Java-2/image-20240121163249464.png" alt="image-20240121163249464"></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。<br>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。</p>
<h4 id="Override重写注解"><a href="#Override重写注解" class="headerlink" title="@Override重写注解"></a>@Override重写注解</h4><ul>
<li><p>@Override:注解，重写注解校验！</p>
</li>
<li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p>
</li>
<li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p>
</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>方法重写是发生在子父类之间的关系。</li>
<li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li>
<li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li>
</ol>
<p><img src="/Little-knowledge-of-Java-2/image-20240121163404381.png" alt="image-20240121163404381"></p>
<h3 id="继承后的特点—构造方法"><a href="#继承后的特点—构造方法" class="headerlink" title="继承后的特点—构造方法"></a>继承后的特点—构造方法</h3><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><p>当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？<br>首先我们要回忆两个事情，构造方法的定义格式和作用。</p>
<ol>
<li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li>
<li>构造方法的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个<code>super()</code> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（<strong>先有爸爸，才能有儿子</strong>）</li>
</ol>
<p><strong>继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法。如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java编译器就会报告一个错误。</strong></p>
<p><code>每个构造函数可以选择调用super()或this()，但不能同时调用！</code></p>
<blockquote>
<ul>
<li>super(参数列表)执行的操作父类初始化，为了保证初始化的顺序，其需要放在构造方法的第一行 当第一行没有写super()语句时，编译器会自动在构造方法的第一行加上无参super()语句。</li>
<li>this关键字执行的操作也是初始化，为了保证初始化的顺序，其需要放在构造方法的第一行。</li>
<li>一个对象不能被反复初始化，表现为this()和super()都要写在构造方法的第一行来执行初始化操作，所以注定两者不能同时出现在同一个构造方法中。</li>
</ul>
</blockquote>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>子类构造方法执行的时候，都会在<code>第一行</code>默认先调用父类无参数构造方法一次。</li>
<li>子类构造方法的第一行都隐含了一个<code>super()</code>去调用父类无参数构造方法，<code>super()</code>可以省略不写。这样就会出现“构造函数链”，即从该对象一直通过构造函数创建出直到<code>Object</code>的部分。</li>
</ul>
<p><img src="/Little-knowledge-of-Java-2/image-20240305200923809.png" alt="image-20240305200923809"></p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121191630393.png" alt="image-20240121191630393"></p>
<h2 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h2><p>有时候，我们可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。</p>
<ol>
<li>仅对本类可见—private。</li>
<li>对外部完全可见一public。</li>
<li>对本包和所有子类可见protected。</li>
<li>对本包可见一默认，不需要修饰符。</li>
</ol>
<h2 id="super-…-和this-…"><a href="#super-…-和this-…" class="headerlink" title="super(…)和this(…)"></a>super(…)和this(…)</h2><p>我们发现，子类有参数构造方法只是初始化了自己对象中的成员变量，而父类中的成员变量依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(…)去调用父类构造方法，以便初始化继承自父类对象的name和age.</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121192332167.png" alt="image-20240121192332167"></p>
<h3 id="super和this的用法格式"><a href="#super和this的用法格式" class="headerlink" title="super和this的用法格式"></a>super和this的用法格式</h3><p>super和this完整的用法如下，其中this，super访问成员我们已经接触过了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.成员变量    	--    本类的</span><br><span class="line"><span class="built_in">super</span>.成员变量    	--    父类的</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.成员方法名()  	--    本类的    </span><br><span class="line"><span class="built_in">super</span>.成员方法名()   --    父类的</span><br></pre></td></tr></table></figure>

<p>接下来我们使用调用构造方法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(...) -- 调用父类的构造方法，根据参数匹配确认</span><br><span class="line"><span class="built_in">this</span>(...) -- 调用本类的其他构造方法，根据参数匹配确认</span><br></pre></td></tr></table></figure>

<h3 id="super-…"><a href="#super-…" class="headerlink" title="super(….)"></a>super(….)</h3><p><strong>注意：</strong></p>
<p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p>
<p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
<p>super(..)是根据参数去确定调用父类哪个构造方法的。</p>
<h3 id="super-…-案例图解"><a href="#super-…-案例图解" class="headerlink" title="super(…)案例图解"></a>super(…)案例图解</h3><p><strong>父类空间优先于子类对象产生</strong></p>
<p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下：</p>
<p><img src="/Little-knowledge-of-Java-2/2.jpg"></p>
<h3 id="this-…-用法演示"><a href="#this-…-用法演示" class="headerlink" title="this(…)用法演示"></a>this(…)用法演示</h3><p>this(…)</p>
<ul>
<li>默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。</li>
<li>为了借用其他构造方法的功能。</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p>
</li>
<li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
</li>
<li><p><strong>super(..)和this(…)是根据参数去确定调用父类哪个构造方法的。</strong></p>
</li>
<li><p>super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。</p>
</li>
<li><p>this(..)可以调用本类中的其他构造方法。</p>
</li>
</ul>
<h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ol>
<li>Java只支持单继承，不支持多继承。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个类只能有一个父类，不可以有多个父类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// class C2 extends A, B &#123;&#125; // error</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一个类可以有多个子类。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A可以有多个子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> <span class="keyword">extends</span>  <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可以多层继承。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C1</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
</blockquote>
<h2 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h2><ul>
<li>将公共操作和字段放在超类中。</li>
<li>不要使用受保护的字段。</li>
<li>使用继承实现“is-a” 关系。</li>
<li>除非所有继承的方法都有意义，否则不要使用继承。</li>
<li>在覆盖方法时，不要改变预期的行为。</li>
<li>使用多态，而不要使用类型信息。</li>
<li>不要滥用反射。</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><img src="/Little-knowledge-of-Java-2/image-20240121193501455.png" alt="image-20240121193501455"></p>
<h2 id="多态的形式"><a href="#多态的形式" class="headerlink" title="多态的形式"></a>多态的形式</h2><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p>
<p><strong>多态是出现在继承或者实现关系中的</strong>。</p>
<p><strong>多态体现的格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类/实现类构造器;</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>

<p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。</p>
<p>“is-a”规则的另一种表述是替换原则（substitution principle)。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。</p>
<p>在Java程序设计语言中，对象变量是多态的（polymorphic)。一个Employee类型的变量既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类的对象（例如，Manager、Executive、Secretary等)。</p>
<h2 id="多态的使用场景"><a href="#多态的使用场景" class="headerlink" title="多态的使用场景"></a>多态的使用场景</h2><p>如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。</p>
<p><img src="/Little-knowledge-of-Java-2/%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF1.png" alt="多态的应用场景"></p>
<p>有了多态之后，方法的形参就可以定义为共同的父类Person。</p>
<p><strong>要注意的是：</strong></p>
<ul>
<li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li>
<li>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象（后面会学）。</li>
<li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li>
</ul>
<p><img src="/Little-knowledge-of-Java-2/%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF2.png" alt="多态的应用场景"></p>
<h2 id="多态的定义和前提"><a href="#多态的定义和前提" class="headerlink" title="多态的定义和前提"></a>多态的定义和前提</h2><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p>
<p>从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。</p>
<p> <strong>前提【重点】</strong></p>
<ol>
<li><p>有继承或者实现关系</p>
</li>
<li><p>方法的重写【意义体现：不重写，无意义】</p>
</li>
<li><p>父类引用指向子类对象【格式体现】</p>
<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p>
</blockquote>
</li>
</ol>
<h2 id="多态的运行特点"><a href="#多态的运行特点" class="headerlink" title="多态的运行特点"></a>多态的运行特点</h2><p><img src="/Little-knowledge-of-Java-2/image-20240121195017765.png" alt="image-20240121195017765"></p>
<p>调用成员变量时：编译看左边，运行看左边</p>
<p>调用成员方法时：编译看左边，运行看右边</p>
<p><img src="/Little-knowledge-of-Java-2/image-20240121194204519.png" alt="image-20240121194204519"></p>
<h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><p>在多态形式下，右边对象可以实现解耦合，便于扩展和维护</p>
<p>定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。</p>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p>
<h2 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h2><h3 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p>
<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p>
<p>回顾基本数据类型转换</p>
<ul>
<li>自动转换: 范围小的赋值给范围大的.自动完成:double d &#x3D; 5; </li>
<li>强制转换: 范围大的赋值给范围小的,强制转换:int i &#x3D; (int)3.14</li>
</ul>
<p>​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p>
<h3 id="向上转型（自动转换）"><a href="#向上转型（自动转换）" class="headerlink" title="向上转型（自动转换）"></a>向上转型（自动转换）</h3><ul>
<li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p>**原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。**所以子类范围小可以直接自动转型给父类类型的变量。</p>
<p>但会丢失除与父类对象共有的其他方法。</p>
<ul>
<li>编译类型取决于&#x3D;号左边，运行类型取决于&#x3D;号右边；</li>
<li>子类可以调用父类的所有成员，但需遵守访问权限；</li>
<li>父类不能调用子类的特有成员；</li>
<li>最终的运行效果取决于子类的具体实现。</li>
</ul>
<h3 id="向下转型（强制转换）"><a href="#向下转型（强制转换）" class="headerlink" title="向下转型（强制转换）"></a>向下转型（强制转换）</h3><ul>
<li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li>
</ul>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:<span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">   <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span>(Cat) a;  </span><br></pre></td></tr></table></figure>

<ul>
<li>只能强制转换父类的引用，不能强制转换父类的对象；</li>
<li>父类的引用必须指向子类目标类型的对象；</li>
<li>向下转型后，父类可以调用子类类型中的所有成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchHouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat(); 				<span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;       </span><br><span class="line">        c.catchMouse(); 		<span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转型的异常"><a href="#转型的异常" class="headerlink" title="转型的异常"></a>转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;       </span><br><span class="line">        d.watchHouse();        <span class="comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p>
<h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a><code>instanceof</code>关键字</h3><p>为了避免<code>ClassCastException</code>的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型 </span><br><span class="line">如果变量属于该数据类型或者其子类类型，返回<span class="literal">true</span>。</span><br><span class="line">如果变量不属于该数据类型或者其子类类型，返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>

<p>所以，转换前，我们最好先做一个判断，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;       </span><br><span class="line">            c.catchMouse();        <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;       </span><br><span class="line">            d.watchHouse();       <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof新特性"><a href="#instanceof新特性" class="headerlink" title="instanceof新特性"></a><code>instanceof</code>新特性</h3><p>JDK14的时候提出了新特性，把判断和强转合并成了一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新特性</span></span><br><span class="line"><span class="comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line"><span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d)&#123;</span><br><span class="line">    d.lookHome();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c)&#123;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有这个类型，无法转换&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>准确地理解如何在对象上应用方法调用非常重要。下面假设要调用x.f(ags),隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：<br>1.编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为f但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举C类中所有名为千的方法和其超类中所有名为f而且可访问的方法（<code>超类的私有方法不可访问</code>）。<br>至此，编译器已知道所有可能被调用的候选方法。<br>2.接下来，编译器要确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析(overloading resolution)。例如，对于调用x.f(“Hello’”),编译器将会挑选f(String),而不是f(int)。由于允许类型转换(int可以转换double,Manager可以转换成Employee,等等)，所以情况可能会变得很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报告一个错误。<br>至此，编译器已经知道需要调用的方法的名字和参数类型。</p>
<blockquote>
<p>注释：前面曾经说过，方法的名字和参数列表称为方法的签名。例如，f(t)和f(String)是两个有相同名字、不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就会覆盖超类中这个相同签名的方法。<br>返回类型不是签名的一部分。不过在覆盖一个方法时，需要保证返回类型的兼容性。允许子类将覆盖方法的返回类型改为原返回类型的子类型。例如，假设Employee类</p>
</blockquote>
<p>3.如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为<code>静态绑定</code>(static binding)。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用动态绑定。在我们的示例中，编译器会利用动态绑定生成一个调用f(String)的指令。<br>4.程序运行并且采用<code>动态绑定</code>调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。假设×的实际类型是D,它是C类的子类。如果D类定义了方法f(String),就会调用这个方法；否则，将在D类的超类中寻找f(String),以此类推。<br>每次调用方法都要完成这个搜索，时间开销相当大。<code>因此，虚拟机预先为每个类计算了一个方法表（method table),其中列出了所有方法的签名和要调用的实际方法。</code>这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在前面的例子中，虚拟机搜索D类的方法表，寻找与调用f(Sting)相匹配的方法。这个方法既有可能是D.f(String),也有可能是X.f(String),这里的X是D的某个超类。这里需要提醒一点，如果调用是super.f(param),那么编译器将对隐式参数超类的方法表进行搜索。</p>
<blockquote>
<p>这种多态其实是通过<strong>动态绑定</strong>（dynamic binding）技术来实现，是指<strong>在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</strong>。也就是说，只有程序运行起来，你才知道调用的是哪个子类的方法。这种多态可通过函数的重写以及向上转型来实现。<br>与动态绑定相对应的就是<strong>静态绑定</strong>，指的是<strong>在JVM解析时便能够直接识别目标方法的情况</strong>。<br><strong>JVM 虚方法表</strong>（Virtual Method Table）,也称为vtable,是<strong>动态调度</strong>用来依次调用<strong>虚方法</strong>的一种表结构，是一种特殊的<strong>索引表</strong>。<br>面向对象编程，会频繁地触发<strong>动态分派</strong>，如果每次动态分配的过程都要重新在类的方法 元数据中搜索合适的目标的方法，就可能影响到执行效率，所以JVM选择了 用<strong>空间换取时间</strong>的策略来实现动态绑定，<strong>为每个类生成一张虚方法表</strong>，然后直接通过虚方法表，使用索引来代替循环查找，快速定位目标方法。</p>
</blockquote>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>为此，Java提供了一种称为抽象方法(abstract method )的机制。这是一个不完整的方法，它只有一个声明,没有方法体。以下是抽象方法声明的语法：</p>
<p><code>abstract void f();</code></p>
<p>包含抽象方法的类称为抽象类。如果一个类包含一个或多个抽象方法，则该类必须被定义为抽象类,否则编译器会产生错误消息。<code>我们创建抽象类，是想通过一个公共接口来操作一组类</code>。</p>
<h2 id="abstract使用格式"><a href="#abstract使用格式" class="headerlink" title="abstract使用格式"></a>abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>实现抽象的方法就如同覆盖过方法一样。抽象的方法没有内容，它只是为了标记出多态而存在。这表示在继承树结构下的第一个具体类必须要实现出所有的抽象方法。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表)；</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br></pre></td></tr></table></figure>

<h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名字 &#123; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类的使用"><a href="#抽象类的使用" class="headerlink" title="抽象类的使用"></a>抽象类的使用</h3><p><strong>要求</strong>：继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。</p>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类,抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="comment">// 抽象方法必须要放在抽象类中</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(id, name, salary);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2.重写父类的抽象方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;管理其他人&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(id, name, salary);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;厨师炒菜多加点盐...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建抽象类,抽象类不能创建对象</span></span><br><span class="line">		<span class="comment">// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象</span></span><br><span class="line"><span class="comment">//		Employee e = new Employee();</span></span><br><span class="line"><span class="comment">//		e.work();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3.创建子类</span></span><br><span class="line">		<span class="type">Manager</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">		m.work();</span><br><span class="line">		</span><br><span class="line">		<span class="type">Cook</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(<span class="string">&quot;ap002&quot;</span>, <span class="string">&quot;库克&quot;</span>, <span class="number">1</span>);</span><br><span class="line">		c.work();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h2 id="抽象类的特征"><a href="#抽象类的特征" class="headerlink" title="抽象类的特征"></a>抽象类的特征</h2><p>抽象类的特征总结起来可以说是 <strong>有得有失</strong></p>
<p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p>
<p><strong>有失：抽象类失去了创建对象的能力。</strong></p>
<p>其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。</p>
<h2 id="抽象类的细节"><a href="#抽象类的细节" class="headerlink" title="抽象类的细节"></a>抽象类的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p>
<p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<ol>
<li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
</li>
<li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
</blockquote>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
</li>
<li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 </p>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
</li>
<li><p>抽象类存在的意义是为了被子类继承。</p>
<blockquote>
<p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p>
</blockquote>
</li>
</ol>
<h2 id="抽象类存在的意义"><a href="#抽象类存在的意义" class="headerlink" title="抽象类存在的意义"></a>抽象类存在的意义</h2><pre><code>抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://alsl521.github.io">kyl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://alsl521.github.io/2024/01/06/Little-knowledge-of-Java-2/">https://alsl521.github.io/2024/01/06/Little-knowledge-of-Java-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://alsl521.github.io" target="_blank">kyl的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/01/03/Little-knowledge-of-Java-1/" title="Java学习（一）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java学习（一）</div></div><div class="info-2"><div class="info-item-1">Java三大平台JavaSE、JavaME、JavaE...</div></div></div></a><a class="pagination-related" href="/2024/01/19/Little-knowledge-of-Java-3/" title="Java学习（三）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java学习（三）</div></div><div class="info-2"><div class="info-item-1">Object:所有类的超类Object类是Java中所有类的始祖，在Java中每个类都扩展了Object。 可以使用Object类型的变量引用任何类型的对象。    修饰符和类型 方法 说明    protected native Object clone() 创建并返回该对象的副本。   public boolean equals(Object obj) 指示某个其他对象是否“等于”此对象。   protected void finalize() 当垃圾收集确定不再有对该对象的引用时，由该对象的垃圾收集器调用。   public final native Class&lt;?&gt;  getClass() 返回 this 的运行时类Object。   public native int hashCode() 返回对象的哈希码值。   public final native void notify() 唤醒正在该对象的监视器上等待的单个线程。   public final native void notifyAll() 唤醒在此对象监视器上等待的所有线程。   public...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/02/01/SSM-2/" title="Java学习-SSM-2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">Java学习-SSM-2</div></div><div class="info-2"><div class="info-item-1">核心容器前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的核心容器。 这里所说的核心容器，大家可以把它简单的理解为ApplicationContext，前面虽然已经用到过，但是并没有系统的学习，接下来咱们从以下几个问题入手来学习下容器的相关知识:  如何创建容器? 创建好容器后，如何从容器中获取bean对象? 容器类的层次结构是什么? BeanFactory是什么?  环境准备在学习和解决上述问题之前，先来准备下案例环境:  创建一个Maven项目  pom.xml添加Spring的依赖 1234567&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;   ...</div></div></div></a><a class="pagination-related" href="/2024/01/03/Little-knowledge-of-Java-1/" title="Java学习（一）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-03</div><div class="info-item-2">Java学习（一）</div></div><div class="info-2"><div class="info-item-1">Java三大平台JavaSE、JavaME、JavaE...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-3/" title="Java学习-SSM-3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-3</div></div><div class="info-2"><div class="info-item-1">AOP简介前面我们在介绍Spring的时候说过，Spring有两个核心的概念，一个是IOC/DI，一个是AOP。 前面已经对IOC/DI进行了系统的学习，接下来要学习它的另一个核心内容，就是AOP。 对于AOP,我们前面提过一句话是:AOP是在不改原有代码的前提下对其进行增强。 对于下面的内容，我们主要就是围绕着这一句话进行展开学习，主要学习两方面内容AOP核心概念,AOP作用: 什么是AOP? AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。 OOP(Object Oriented...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-6/" title="Java学习-SSM-6"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-6</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-4/" title="Java学习-SSM-4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-4</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/02/02/SSM-7/" title="Java学习-SSM-7"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-02</div><div class="info-item-2">Java学习-SSM-7</div></div><div class="info-2"><div class="info-item-1">今日目标：   掌握基于SpringBoot框架的程序开发步骤 熟练使用SpringBoot配置信息修改服务器配置 基于SpringBoot的完成SSM整合项目开发   SpringBoot简介SpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。 使用了 Spring 框架后已经简化了我们的开发。而 SpringBoot 又是对 Spring 开发进行简化的，可想而知 SpringBoot 使用的简单及广泛性。既然 SpringBoot 是用来简化 Spring 开发的，那我们就先回顾一下，以 SpringMVC 开发为例：  创建工程，并在 pom.xml 配置文件中配置所依赖的坐标     编写 web3.0 的配置类 作为 web 程序，web3.0 的配置类不能缺少，而这个配置类还是比较麻烦的，代码如下      编写 SpringMVC 的配置类    ​	做到这只是将工程的架子搭起来。要想被外界访问，最起码还需要提供一个 Controller 类，在该类中提供一个方法。  编写...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/61216968?s=400&amp;u=d5b61cbc7946e6309e4318dabc2d459a18e0fe55&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kyl</div><div class="author-info-description">用于记录平时学习的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/alsl521" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:852970167@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象程序设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">一个对象的内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">两个对象的内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">两个引用指向同一个对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">使用预定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">对象与对象变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%88%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">对象引用（引用数据类型）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%99%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">更改器方法与访问器方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BBAPI"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">日期类API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">Date类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SimpleDateFormat%E7%B1%BB"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">SimpleDateFormat类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">Calendar类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JDK8%E8%A6%81%E6%96%B0%E5%A2%9E%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.2.1.3.4.</span> <span class="toc-text">为什么JDK8要新增日期类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK8%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.1.3.5.</span> <span class="toc-text">JDK8日期、时间、日期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK8%E6%97%A5%E6%9C%9F%EF%BC%88%E6%97%B6%E5%8C%BA%EF%BC%89"><span class="toc-number">1.2.1.3.6.</span> <span class="toc-text">JDK8日期（时区）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK8%E6%97%A5%E6%9C%9F%EF%BC%88Instant%E7%B1%BB%EF%BC%89"><span class="toc-number">1.2.1.3.7.</span> <span class="toc-text">JDK8日期（Instant类）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK8%E6%97%A5%E6%9C%9F%EF%BC%88%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8%EF%BC%89"><span class="toc-number">1.2.1.3.8.</span> <span class="toc-text">JDK8日期（格式化器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK8%E6%97%A5%E6%9C%9F%EF%BC%88Period%E7%B1%BB%EF%BC%89"><span class="toc-number">1.2.1.3.9.</span> <span class="toc-text">JDK8日期（Period类）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK8%E6%97%A5%E6%9C%9F%EF%BC%88Duration%E7%B1%BB%EF%BC%89"><span class="toc-number">1.2.1.3.10.</span> <span class="toc-text">JDK8日期（Duration类）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">用户自定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">构造方法概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.3.</span> <span class="toc-text">构造方法的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">形参和实参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%8F%82%E6%95%B0%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">显示参数和隐式参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">1.3.6.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">1.3.7.</span> <span class="toc-text">方法调用的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.8.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.9.</span> <span class="toc-text">引用数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.10.</span> <span class="toc-text">静态工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">一、什么是静态工厂方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">二、静态工厂方法的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%90%8D%E7%A7%B0"><span class="toc-number">1.3.10.2.1.</span> <span class="toc-text">1、静态工厂方法有名称</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%B8%8D%E7%94%A8%E5%9C%A8%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.10.2.2.</span> <span class="toc-text">2、静态工厂方法不用在每次调用的时候都创建一个新的对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%89%80%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E9%9A%8F%E7%9D%80%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E8%80%8C%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%EF%BC%8C%E8%BF%99%E5%8F%96%E5%86%B3%E4%BA%8E%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">1.3.10.2.3.</span> <span class="toc-text">4、静态工厂方法所返回的对象可以随着每次调用而发生变化，这取决于参数值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">三、静态工厂方法的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.11.</span> <span class="toc-text">final实例字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">静态字段与静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.1.</span> <span class="toc-text">static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">定义格式和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">静态变量及其访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">实例变量及其访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.1.2.3.</span> <span class="toc-text">静态方法及其访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.1.2.4.</span> <span class="toc-text">实例方法及其访问</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">静态字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">静态常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">1.5.</span> <span class="toc-text">对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.2.</span> <span class="toc-text">默认字段初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">无参数的构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.4.</span> <span class="toc-text">显式字段初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="toc-number">1.5.5.</span> <span class="toc-text">初始化块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">2.1.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9A%84JavaBean%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">标准的JavaBean类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">继承的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.2.</span> <span class="toc-text">继承的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">类、超类和子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%AD%90%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">定义子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">子类不能继承的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">演示代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">继承后的特点—成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">super访问父类成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">继承后的特点—成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.3.5.</span> <span class="toc-text">方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Override%E9%87%8D%E5%86%99%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">@Override重写注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.5.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8E%E7%9A%84%E7%89%B9%E7%82%B9%E2%80%94%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.6.</span> <span class="toc-text">继承后的特点—构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-1"><span class="toc-number">3.3.6.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.3.6.2.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BF%EF%BC%9Afinal%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">阻止继承：final类和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super-%E2%80%A6-%E5%92%8Cthis-%E2%80%A6"><span class="toc-number">3.5.</span> <span class="toc-text">super(…)和this(…)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%92%8Cthis%E7%9A%84%E7%94%A8%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">super和this的用法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E2%80%A6"><span class="toc-number">3.5.2.</span> <span class="toc-text">super(….)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E2%80%A6-%E6%A1%88%E4%BE%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">3.5.3.</span> <span class="toc-text">super(…)案例图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E2%80%A6-%E7%94%A8%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">3.5.4.</span> <span class="toc-text">this(…)用法演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">3.5.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.6.</span> <span class="toc-text">继承的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">3.7.</span> <span class="toc-text">继承的设计技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">多态的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.</span> <span class="toc-text">多态的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%89%8D%E6%8F%90"><span class="toc-number">4.3.</span> <span class="toc-text">多态的定义和前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">多态的运行特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">4.5.</span> <span class="toc-text">多态的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">4.6.</span> <span class="toc-text">多态的弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.7.</span> <span class="toc-text">引用类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BD%AC%E5%9E%8B"><span class="toc-number">4.7.1.</span> <span class="toc-text">为什么要转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%88%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">4.7.2.</span> <span class="toc-text">向上转型（自动转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%88%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">4.7.3.</span> <span class="toc-text">向下转型（强制转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%9E%8B%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">4.7.4.</span> <span class="toc-text">转型的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.7.5.</span> <span class="toc-text">instanceof关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.7.6.</span> <span class="toc-text">instanceof新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">4.8.</span> <span class="toc-text">理解方法调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">abstract使用格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-1"><span class="toc-number">5.1.2.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">抽象类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">5.2.</span> <span class="toc-text">抽象类的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">5.3.</span> <span class="toc-text">抽象类的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">5.4.</span> <span class="toc-text">抽象类存在的意义</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/21/NET-ASP-13/" title="ASP.NET学习记录-13-实践2-数据库进阶">ASP.NET学习记录-13-实践2-数据库进阶</a><time datetime="2025-04-21T08:39:19.000Z" title="发表于 2025-04-21 16:39:19">2025-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-12/" title="ASP.NET学习记录-12-实践2-使用MySQL数据库">ASP.NET学习记录-12-实践2-使用MySQL数据库</a><time datetime="2025-04-18T08:11:21.000Z" title="发表于 2025-04-18 16:11:21">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/18/NET-ASP-11/" title="ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API">ASP.NET学习记录-11-实践1-使用 ASP.NET Core 生成基于控制器的 Web API</a><time datetime="2025-04-18T02:13:44.000Z" title="发表于 2025-04-18 10:13:44">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/NET-ASP-10/" title="ASP.NET学习记录-10-过滤">ASP.NET学习记录-10-过滤</a><time datetime="2025-04-16T12:02:16.000Z" title="发表于 2025-04-16 20:02:16">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/15/Software/" title="记录必备软件">记录必备软件</a><time datetime="2025-04-15T11:29:21.000Z" title="发表于 2025-04-15 19:29:21">2025-04-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By kyl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>